###############################################################################
#
# IAR C/C++ Compiler V10.20.1.5333 for 8051               18/Jun/2021  15:12:20
# Copyright 2004-2018 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  D:\SRC\DemoPrj\Components\stack\zdo\ZDSecMgr.c
#    Command line       =  
#        -f C:\Users\ADMINI~1\AppData\Local\Temp\EW2728.tmp
#        (D:\SRC\DemoPrj\Components\stack\zdo\ZDSecMgr.c -D ZIGBEEPRO -D
#        HAL_UART=TRUE -D SERIAL_APP_PORT=0 -D LCD_SUPPORTED -lC
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\CoordinatorEB-Pro\List
#        -lA
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\CoordinatorEB-Pro\List
#        --diag_suppress Pe001,Pa010 -o
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\CoordinatorEB-Pro\Obj
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 8 -f
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wCoord.cfg
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRUE
#        -DZDO_COORDINATOR -DRTR_NWK -DBLINK_LEDS) -f
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg
#        (-DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0x1223
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_POLLED=3000
#        -DNWK_INDIRECT_MSG_TIMEOUT=7 -DMAX_RREQ_ENTRIES=8
#        -DAPSC_MAX_FRAME_RETRIES=3 -DNWK_MAX_DATA_RETRIES=2
#        -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9 -DAPS_MAX_GROUPS=16
#        -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 "-DCONST=const __code"
#        -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000
#        -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100
#        -DREJOIN_POLL_RATE=440) -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\ -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\SOURCE\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\ZMAIN\TI2530DB\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\MT\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\INCLUDE\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\TARGET\CC2530EB\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\MCU\CCSOC\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\INCLUDE\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\AF\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\NWK\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SEC\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SAPI\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SYS\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\ZDO\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\F8W\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\SERVICES\SADDR\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\SERVICES\SDATA\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\INCLUDE\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\HIGH_LEVEL\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW_LEVEL\srf04\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW_LEVEL\srf04\SINGLE_CHIP\
#        -Ohz --require_prototypes)
#    Locale             =  Chinese (Simplified)_CHN.936
#    List file          =  
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\CoordinatorEB-Pro\List\ZDSecMgr.lst
#    Object file        =  
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\CoordinatorEB-Pro\Obj\ZDSecMgr.r51
#
###############################################################################

D:\SRC\DemoPrj\Components\stack\zdo\ZDSecMgr.c
      1          /**************************************************************************************************
      2            Filename:       ZDSecMgr.c
      3            Revised:        $Date: 2009-03-31 09:06:47 -0700 (Tue, 31 Mar 2009) $
      4            Revision:       $Revision: 19604 $
      5          
      6            Description:    The ZigBee Device Security Manager.
      7          
      8          
      9            Copyright 2005-2008 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          #ifdef __cplusplus
     41          extern "C"
     42          {
     43          #endif
     44          
     45          /******************************************************************************
     46           * INCLUDES
     47           */
     48          #include "ZComdef.h"
     49          #include "OSAL.h"
     50          #include "OSAL_NV.h"
     51          #include "ZGlobals.h"
     52          #include "ssp.h"
     53          #include "nwk_globals.h"
     54          #include "nwk.h"
     55          #include "NLMEDE.h"
     56          #include "AddrMgr.h"
     57          #include "AssocList.h"
     58          #include "APSMEDE.h"
     59          #include "AF.h"
     60          #include "ZDConfig.h"
     61          #include "ZDApp.h"
     62          #include "ZDSecMgr.h"
     63          
     64          
     65          /******************************************************************************
     66           * CONSTANTS
     67           */
     68          // maximum number of devices managed by this Security Manager
     69          #if !defined ( ZDSECMGR_DEVICE_MAX )
     70            #define ZDSECMGR_DEVICE_MAX 3
     71          #endif
     72          
     73          // total number of preconfigured devices (EXT address, MASTER key)
     74          //devtag.pro.security
     75          //#define ZDSECMGR_PRECONFIG_MAX ZDSECMGR_DEVICE_MAX
     76          #define ZDSECMGR_PRECONFIG_MAX 0
     77          
     78          // maximum number of MASTER keys this device may hold
     79          #define ZDSECMGR_MASTERKEY_MAX ZDSECMGR_DEVICE_MAX
     80          
     81          // maximum number of LINK keys this device may store
     82          #define ZDSECMGR_ENTRY_MAX ZDSECMGR_DEVICE_MAX
     83          
     84          // total number of devices under control - authentication, SKKE, etc.
     85          #define ZDSECMGR_CTRL_MAX ZDSECMGR_DEVICE_MAX
     86          
     87          // total number of stored devices
     88          #if !defined ( ZDSECMGR_STORED_DEVICES )
     89            #define ZDSECMGR_STORED_DEVICES 3
     90          #endif
     91            
     92          #define ZDSECMGR_CTRL_NONE       0
     93          #define ZDSECMGR_CTRL_INIT       1
     94          #define ZDSECMGR_CTRL_TK_MASTER  2
     95          #define ZDSECMGR_CTRL_SKKE_INIT  3
     96          #define ZDSECMGR_CTRL_SKKE_WAIT  4
     97          #define ZDSECMGR_CTRL_SKKE_DONE  5
     98          #define ZDSECMGR_CTRL_SKKE_FAIL  6
     99          #define ZDSECMGR_CTRL_TK_NWK     7
    100          
    101          #define ZDSECMGR_CTRL_BASE_CNTR      1
    102          #define ZDSECMGR_CTRL_SKKE_INIT_CNTR 1
    103          #define ZDSECMGR_CTRL_TK_NWK_CNTR    1
    104          
    105          // set SKA slot maximum
    106          #define ZDSECMGR_SKA_SLOT_MAX 1
    107          
    108          // APSME Stub Implementations
    109          #define ZDSecMgrMasterKeyGet   APSME_MasterKeyGet
    110          #define ZDSecMgrLinkKeySet     APSME_LinkKeySet
    111          #define ZDSecMgrLinkKeyDataGet APSME_LinkKeyDataGet
    112          #define ZDSecMgrKeyFwdToChild  APSME_KeyFwdToChild
    113          
    114          #if !defined( MAX_APS_FRAMECOUNTER_CHANGES )
    115            // The number of times the frame counter can change before
    116            // saving to NV
    117            #define MAX_APS_FRAMECOUNTER_CHANGES    10
    118          #endif
    119          
    120          /******************************************************************************
    121           * TYPEDEFS
    122           */
    123          typedef struct
    124          {
    125            uint8 extAddr[Z_EXTADDR_LEN];
    126            uint8 key[SEC_KEY_LEN];
    127          } ZDSecMgrPreConfigData_t;
    128          
    129          typedef struct
    130          {
    131            uint16 ami;
    132            uint8  key[SEC_KEY_LEN];
    133          } ZDSecMgrMasterKeyData_t;
    134          
    135          //should match APSME_LinkKeyData_t;
    136          typedef struct
    137          {
    138            uint8               key[SEC_KEY_LEN];
    139            APSME_LinkKeyData_t apsmelkd;
    140          } ZDSecMgrLinkKeyData_t;
    141          
    142          typedef struct
    143          {
    144            uint16                ami;
    145            ZDSecMgrLinkKeyData_t lkd;
    146            ZDSecMgr_Authentication_Option authenticateOption;
    147          } ZDSecMgrEntry_t;
    148          
    149          typedef struct
    150          {
    151            ZDSecMgrEntry_t* entry;
    152            uint16           parentAddr;
    153            uint8            secure;
    154            uint8            state;
    155            uint8            cntr;
    156            //uint8          next;
    157          } ZDSecMgrCtrl_t;
    158          
    159          typedef struct
    160          {
    161            uint16          nwkAddr;
    162            uint8*          extAddr;
    163            uint16          parentAddr;
    164            uint8           secure;
    165            uint8           devStatus;
    166            ZDSecMgrCtrl_t* ctrl;
    167          } ZDSecMgrDevice_t;
    168          
    169          /******************************************************************************
    170           * LOCAL VARIABLES
    171           */
    172          #if 0 // Taken out because the following functionality is only used for test
    173                // purpose. A more efficient (above) way is used. It can be put
    174                // back in if customers request for a white/black list feature.
    175          uint8 ZDSecMgrStoredDeviceList[ZDSECMGR_STORED_DEVICES][Z_EXTADDR_LEN] =
    176          {
    177            { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    178            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 },
    179            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    180          };
    181          #endif
    182          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    183          uint8 ZDSecMgrTCExtAddr[Z_EXTADDR_LEN]=
   \                     ZDSecMgrTCExtAddr:
   \   000000                DS 8
   \   000008                REQUIRE __INIT_XDATA_Z
    184            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
    185          

   \                                 In  segment XDATA_I, align 1, keep-with-next
    186          uint8 ZDSecMgrTCMasterKey[SEC_KEY_LEN] =
   \                     ZDSecMgrTCMasterKey:
   \   000000                DS 16
   \   000010                REQUIRE `?<Initializer for ZDSecMgrTCMasterKey>`
   \   000010                REQUIRE __INIT_XDATA_I
    187            {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    188             0x89,0x67,0x45,0x23,0x01,0xEF,0xCD,0xAB};
    189          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    190          uint8 ZDSecMgrTCAuthenticated = FALSE;
   \                     ZDSecMgrTCAuthenticated:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    191          uint8 ZDSecMgrTCDataLoaded    = FALSE;
   \                     ZDSecMgrTCDataLoaded:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    192          
    193          //devtag.pro.security - remove this
    194          #if ( ZDSECMGR_PRECONFIG_MAX != 0 )
    195          const ZDSecMgrPreConfigData_t ZDSecMgrPreConfigData[ZDSECMGR_PRECONFIG_MAX] =
    196          {
    197            //---------------------------------------------------------------------------
    198            // DEVICE A
    199            //---------------------------------------------------------------------------
    200            {
    201              // extAddr
    202              {0x7C,0x01,0x12,0x13,0x14,0x15,0x16,0x17},
    203          
    204              // key
    205              {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    206               0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
    207            },
    208            //---------------------------------------------------------------------------
    209            // DEVICE B
    210            //---------------------------------------------------------------------------
    211            {
    212              // extAddr
    213              {0x84,0x03,0x00,0x00,0x00,0x4B,0x12,0x00},
    214          
    215              // key
    216              {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    217               0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
    218            },
    219            //---------------------------------------------------------------------------
    220            // DEVICE C
    221            //---------------------------------------------------------------------------
    222            {
    223              // extAddr
    224              {0x3E,0x01,0x12,0x13,0x14,0x15,0x16,0x17},
    225          
    226              // key
    227              {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    228               0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
    229            },
    230          };
    231          #endif // ( ZDSECMGR_PRECONFIG_MAX != 0 )
    232          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    233          ZDSecMgrMasterKeyData_t* ZDSecMgrMasterKeyData = NULL;
   \                     ZDSecMgrMasterKeyData:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    234          ZDSecMgrEntry_t*         ZDSecMgrEntries       = NULL;
   \                     ZDSecMgrEntries:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    235          ZDSecMgrCtrl_t*          ZDSecMgrCtrlData      = NULL;
   \                     ZDSecMgrCtrlData:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    236          void ZDSecMgrAddrMgrUpdate( uint16 ami, uint16 nwkAddr );
    237          void ZDSecMgrAddrMgrCB( uint8 update, AddrMgrEntry_t* newEntry, AddrMgrEntry_t* oldEntry );
    238          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    239          uint8 ZDSecMgrPermitJoiningEnabled;
   \                     ZDSecMgrPermitJoiningEnabled:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    240          uint8 ZDSecMgrPermitJoiningTimed;
   \                     ZDSecMgrPermitJoiningTimed:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    241          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    242          APSME_LinkKeyData_t TrustCenterLinkKey;
   \                     TrustCenterLinkKey:
   \   000000                DS 10
   \   00000A                REQUIRE __INIT_XDATA_Z
    243          
    244          /******************************************************************************
    245           * PRIVATE FUNCTIONS
    246           *
    247           *   ZDSecMgrMasterKeyInit
    248           *   ZDSecMgrAddrStore
    249           *   ZDSecMgrExtAddrStore
    250           *   ZDSecMgrExtAddrLookup
    251           *   ZDSecMgrMasterKeyLookup
    252           *   ZDSecMgrMasterKeyStore
    253           *   ZDSecMgrEntryInit
    254           *   ZDSecMgrEntryLookup
    255           *   ZDSecMgrEntryLookupAMI
    256           *   ZDSecMgrEntryLookupExt
    257           *   ZDSecMgrEntryFree
    258           *   ZDSecMgrEntryNew
    259           *   ZDSecMgrCtrlInit
    260           *   ZDSecMgrCtrlRelease
    261           *   ZDSecMgrCtrlLookup
    262           *   ZDSecMgrCtrlSet
    263           *   ZDSecMgrCtrlAdd
    264           *   ZDSecMgrCtrlTerm
    265           *   ZDSecMgrCtrlReset
    266           *   ZDSecMgrMasterKeyLoad
    267           *   ZDSecMgrAppKeyGet
    268           *   ZDSecMgrAppKeyReq
    269           *   ZDSecMgrEstablishKey
    270           *   ZDSecMgrSendMasterKey
    271           *   ZDSecMgrSendNwkKey
    272           *   ZDSecMgrDeviceEntryRemove
    273           *   ZDSecMgrDeviceEntryAdd
    274           *   ZDSecMgrDeviceCtrlHandler
    275           *   ZDSecMgrDeviceCtrlSetup
    276           *   ZDSecMgrDeviceCtrlUpdate
    277           *   ZDSecMgrDeviceRemove
    278           *   ZDSecMgrDeviceValidateSKKE
    279           *   ZDSecMgrDeviceValidateRM
    280           *   ZDSecMgrDeviceValidateCM
    281           *   ZDSecMgrDeviceValidate
    282           *   ZDSecMgrDeviceJoin
    283           *   ZDSecMgrDeviceJoinDirect
    284           *   ZDSecMgrDeviceJoinFwd
    285           *   ZDSecMgrDeviceNew
    286           *   ZDSecMgrAssocDeviceAuth
    287           *   ZDSecMgrAuthInitiate
    288           *   ZDSecMgrAuthNwkKey
    289           */
    290          //-----------------------------------------------------------------------------
    291          // master key data
    292          //-----------------------------------------------------------------------------
    293          void ZDSecMgrMasterKeyInit( void );
    294          
    295          //-----------------------------------------------------------------------------
    296          // address management
    297          //-----------------------------------------------------------------------------
    298          ZStatus_t ZDSecMgrAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami );
    299          ZStatus_t ZDSecMgrExtAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami );
    300          ZStatus_t ZDSecMgrExtAddrLookup( uint8* extAddr, uint16* ami );
    301          
    302          //-----------------------------------------------------------------------------
    303          // MASTER key data
    304          //-----------------------------------------------------------------------------
    305          ZStatus_t ZDSecMgrMasterKeyLookup( uint16 ami, uint8** key );
    306          ZStatus_t ZDSecMgrMasterKeyStore( uint16 ami, uint8* key );
    307          
    308          //-----------------------------------------------------------------------------
    309          // entry data
    310          //-----------------------------------------------------------------------------
    311          void ZDSecMgrEntryInit( void );
    312          ZStatus_t ZDSecMgrEntryLookup( uint16 nwkAddr, ZDSecMgrEntry_t** entry );
    313          ZStatus_t ZDSecMgrEntryLookupAMI( uint16 ami, ZDSecMgrEntry_t** entry );
    314          ZStatus_t ZDSecMgrEntryLookupExt( uint8* extAddr, ZDSecMgrEntry_t** entry );
    315          void ZDSecMgrEntryFree( ZDSecMgrEntry_t* entry );
    316          ZStatus_t ZDSecMgrEntryNew( ZDSecMgrEntry_t** entry );
    317          ZStatus_t ZDSecMgrAuthenticationSet( uint8* extAddr, ZDSecMgr_Authentication_Option option );
    318          
    319          //-----------------------------------------------------------------------------
    320          // control data
    321          //-----------------------------------------------------------------------------
    322          void ZDSecMgrCtrlInit( void );
    323          void ZDSecMgrCtrlRelease( ZDSecMgrCtrl_t* ctrl );
    324          void ZDSecMgrCtrlLookup( ZDSecMgrEntry_t* entry, ZDSecMgrCtrl_t** ctrl );
    325          void ZDSecMgrCtrlSet( ZDSecMgrDevice_t* device,
    326                                ZDSecMgrEntry_t*  entry,
    327                                ZDSecMgrCtrl_t*   ctrl );
    328          ZStatus_t ZDSecMgrCtrlAdd( ZDSecMgrDevice_t* device, ZDSecMgrEntry_t*  entry );
    329          void ZDSecMgrCtrlTerm( ZDSecMgrEntry_t* entry );
    330          ZStatus_t ZDSecMgrCtrlReset( ZDSecMgrDevice_t* device,
    331                                       ZDSecMgrEntry_t*  entry );
    332          
    333          //-----------------------------------------------------------------------------
    334          // key support
    335          //-----------------------------------------------------------------------------
    336          ZStatus_t ZDSecMgrMasterKeyLoad( uint8* extAddr, uint8* key );
    337          ZStatus_t ZDSecMgrAppKeyGet( uint16  initNwkAddr,
    338                                       uint8*  initExtAddr,
    339                                       uint16  partNwkAddr,
    340                                       uint8*  partExtAddr,
    341                                       uint8** key,
    342                                       uint8*  keyType );
    343          void ZDSecMgrAppKeyReq( ZDO_RequestKeyInd_t* ind );
    344          ZStatus_t ZDSecMgrEstablishKey( ZDSecMgrDevice_t* device );
    345          ZStatus_t ZDSecMgrSendMasterKey( ZDSecMgrDevice_t* device );
    346          ZStatus_t ZDSecMgrSendNwkKey( ZDSecMgrDevice_t* device );
    347          
    348          //-----------------------------------------------------------------------------
    349          // device entry
    350          //-----------------------------------------------------------------------------
    351          void ZDSecMgrDeviceEntryRemove( ZDSecMgrEntry_t* entry );
    352          ZStatus_t ZDSecMgrDeviceEntryAdd( ZDSecMgrDevice_t* device, uint16 ami );
    353          
    354          //-----------------------------------------------------------------------------
    355          // device control
    356          //-----------------------------------------------------------------------------
    357          void ZDSecMgrDeviceCtrlHandler( ZDSecMgrDevice_t* device );
    358          void ZDSecMgrDeviceCtrlSetup( ZDSecMgrDevice_t* device );
    359          void ZDSecMgrDeviceCtrlUpdate( uint8* extAddr, uint8 state );
    360          
    361          //-----------------------------------------------------------------------------
    362          // device management
    363          //-----------------------------------------------------------------------------
    364          void ZDSecMgrDeviceRemove( ZDSecMgrDevice_t* device );
    365          ZStatus_t ZDSecMgrDeviceValidateSKKE( ZDSecMgrDevice_t* device );
    366          ZStatus_t ZDSecMgrDeviceValidateRM( ZDSecMgrDevice_t* device );
    367          ZStatus_t ZDSecMgrDeviceValidateCM( ZDSecMgrDevice_t* device );
    368          ZStatus_t ZDSecMgrDeviceValidate( ZDSecMgrDevice_t* device );
    369          ZStatus_t ZDSecMgrDeviceJoin( ZDSecMgrDevice_t* device );
    370          ZStatus_t ZDSecMgrDeviceJoinDirect( ZDSecMgrDevice_t* device );
    371          ZStatus_t ZDSecMgrDeviceJoinFwd( ZDSecMgrDevice_t* device );
    372          ZStatus_t ZDSecMgrDeviceNew( ZDSecMgrDevice_t* device );
    373          
    374          //-----------------------------------------------------------------------------
    375          // association management
    376          //-----------------------------------------------------------------------------
    377          void ZDSecMgrAssocDeviceAuth( associated_devices_t* assoc );
    378          
    379          //-----------------------------------------------------------------------------
    380          // authentication management
    381          //-----------------------------------------------------------------------------
    382          void ZDSecMgrAuthInitiate( uint8* responder );
    383          void ZDSecMgrAuthNwkKey( void );
    384          
    385          /******************************************************************************
    386           * @fn          ZDSecMgrMasterKeyInit                     ]
    387           *
    388           * @brief       Initialize master key data.
    389           *
    390           * @param       none
    391           *
    392           * @return      none
    393           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    394          void ZDSecMgrMasterKeyInit( void )
   \                     ZDSecMgrMasterKeyInit:
    395          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    396            uint16 index;
    397            uint16 size;
    398          
    399            // allocate MASTER key data
    400            size = (short)( sizeof(ZDSecMgrMasterKeyData_t) * ZDSECMGR_MASTERKEY_MAX );
    401          
    402            ZDSecMgrMasterKeyData = osal_mem_alloc( size );
   \   000004                ; Setup parameters for call to function osal_mem_alloc
   \   000004   7A36         MOV       R2,#0x36
   \   000006   7B00         MOV       R3,#0x0
   \   000008   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00000B   90....       MOV       DPTR,#ZDSecMgrMasterKeyData
   \   00000E   12....       LCALL     ?Subroutine24 & 0xFFFF
    403          
    404            // initialize MASTER key data
    405            if ( ZDSecMgrMasterKeyData != NULL )
   \                     ??CrossCallReturnLabel_12:
   \   000011   6025         JZ        ??ZDSecMgrMasterKeyInit_0
    406            {
    407              for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX; index++ )
   \   000013   7800         MOV       R0,#0x0
   \   000015   7900         MOV       R1,#0x0
    408              {
    409                ZDSecMgrMasterKeyData[index].ami = INVALID_NODE_ADDR;
   \                     ??ZDSecMgrMasterKeyInit_1:
   \   000017   E8           MOV       A,R0
   \   000018   FA           MOV       R2,A
   \   000019   E9           MOV       A,R1
   \   00001A   FB           MOV       R3,A
   \   00001B   EA           MOV       A,R2
   \   00001C   75F012       MOV       B,#0x12
   \   00001F   A4           MUL       AB
   \   000020   FA           MOV       R2,A
   \   000021   ACF0         MOV       R4,B
   \   000023   75F012       MOV       B,#0x12
   \   000026   EB           MOV       A,R3
   \   000027   A4           MUL       AB
   \   000028   2C           ADD       A,R4
   \   000029   FB           MOV       R3,A
   \   00002A   90....       MOV       DPTR,#ZDSecMgrMasterKeyData
   \   00002D   12....       LCALL     ?Subroutine39 & 0xFFFF
    410              }
   \                     ??CrossCallReturnLabel_39:
   \   000030   7001         JNZ       ??ZDSecMgrMasterKeyInit_2
   \   000032   09           INC       R1
   \                     ??ZDSecMgrMasterKeyInit_2:
   \   000033   12....       LCALL     ?Subroutine57 & 0xFFFF
    411            }
   \                     ??CrossCallReturnLabel_71:
   \   000036   40DF         JC        ??ZDSecMgrMasterKeyInit_1
    412          }
   \                     ??ZDSecMgrMasterKeyInit_0:
   \   000038   02....       LJMP      ??Subroutine86_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine39:
   \   000000   12....       LCALL     ?Subroutine72 & 0xFFFF
   \                     ??CrossCallReturnLabel_102:
   \   000003   74FE         MOV       A,#-0x2
   \   000005   F0           MOVX      @DPTR,A
   \   000006   A3           INC       DPTR
   \   000007   04           INC       A
   \   000008   F0           MOVX      @DPTR,A
   \   000009   08           INC       R0
   \   00000A   E8           MOV       A,R0
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   EA           MOV       A,R2
   \   000001   F0           MOVX      @DPTR,A
   \   000002   A3           INC       DPTR
   \   000003   EB           MOV       A,R3
   \   000004   F0           MOVX      @DPTR,A
   \   000005   F9           MOV       R1,A
   \   000006   EA           MOV       A,R2
   \   000007   49           ORL       A,R1
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine57:
   \   000000   C3           CLR       C
   \   000001   9403         SUBB      A,#0x3
   \   000003   E9           MOV       A,R1
   \   000004   9400         SUBB      A,#0x0
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine72:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   2A           ADD       A,R2
   \   000002   FC           MOV       R4,A
   \   000003   A3           INC       DPTR
   \   000004   E0           MOVX      A,@DPTR
   \   000005   3B           ADDC      A,R3
   \   000006   8C82         MOV       DPL,R4
   \   000008   F583         MOV       DPH,A
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine86_0:
   \   000000   D083         POP       DPH
   \   000002   D082         POP       DPL
   \   000004   02....       LJMP      ?BRET
    413          //devtag.pro.security
    414          #if 0
    415          void ZDSecMgrMasterKeyInit( void )
    416          {
    417            uint16         index;
    418            uint16         size;
    419            AddrMgrEntry_t entry;
    420          
    421          
    422            // allocate MASTER key data
    423            size = (short)( sizeof(ZDSecMgrMasterKeyData_t) * ZDSECMGR_MASTERKEY_MAX );
    424          
    425            ZDSecMgrMasterKeyData = osal_mem_alloc( size );
    426          
    427            // initialize MASTER key data
    428            if ( ZDSecMgrMasterKeyData != NULL )
    429            {
    430              for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX; index++ )
    431              {
    432                ZDSecMgrMasterKeyData[index].ami = INVALID_NODE_ADDR;
    433              }
    434          
    435              // check if preconfigured keys are enabled
    436              //-------------------------------------------------------------------------
    437              #if ( ZDSECMGR_PRECONFIG_MAX != 0 )
    438              //-------------------------------------------------------------------------
    439              if ( zgPreConfigKeys == TRUE )
    440              {
    441                // sync configured data
    442                entry.user = ADDRMGR_USER_SECURITY;
    443          
    444                for ( index = 0; index < ZDSECMGR_PRECONFIG_MAX; index++ )
    445                {
    446                  // check for Address Manager entry
    447                  AddrMgrExtAddrSet( entry.extAddr,
    448                                     (uint8*)ZDSecMgrPreConfigData[index].extAddr );
    449          
    450                  if ( AddrMgrEntryLookupExt( &entry ) != TRUE )
    451                  {
    452                    // update Address Manager
    453                    AddrMgrEntryUpdate( &entry );
    454                  }
    455          
    456                  if ( entry.index != INVALID_NODE_ADDR )
    457                  {
    458                    // sync MASTER keys with Address Manager index
    459                    ZDSecMgrMasterKeyData[index].ami = entry.index;
    460          
    461                    osal_memcpy( ZDSecMgrMasterKeyData[index].key,
    462                             (void*)ZDSecMgrPreConfigData[index].key, SEC_KEY_LEN );
    463                  }
    464                }
    465              }
    466              //-------------------------------------------------------------------------
    467              #endif // ( ZDSECMGR_PRECONFIG_MAX != 0 )
    468              //-------------------------------------------------------------------------
    469            }
    470          }
    471          #endif
    472          
    473          /******************************************************************************
    474           * @fn          ZDSecMgrAddrStore
    475           *
    476           * @brief       Store device addresses.
    477           *
    478           * @param       nwkAddr - [in] NWK address
    479           * @param       extAddr - [in] EXT address
    480           * @param       ami     - [out] Address Manager index
    481           *
    482           * @return      ZStatus_t
    483           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    484          ZStatus_t ZDSecMgrAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami )
   \                     ZDSecMgrAddrStore:
    485          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV       A,#-0xd
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
    486            ZStatus_t      status;
    487            AddrMgrEntry_t entry;
    488          
    489          
    490            // add entry
    491            entry.user    = ADDRMGR_USER_SECURITY;
   \   00000A   85..82       MOV       DPL,?XSP + 0
   \   00000D   85..83       MOV       DPH,?XSP + 1
   \   000010   7402         MOV       A,#0x2
   \   000012   F0           MOVX      @DPTR,A
    492            entry.nwkAddr = nwkAddr;
   \   000013   14           DEC       A
   \   000014   12....       LCALL     ?XSTACK_DISP0_8
   \   000017   12....       LCALL     ?Subroutine35 & 0xFFFF
    493            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \                     ??CrossCallReturnLabel_29:
   \   00001A                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   00001A   7403         MOV       A,#0x3
   \   00001C   12....       LCALL     ?XSTACK_DISP0_8
   \   00001F   AA82         MOV       R2,DPL
   \   000021   AB83         MOV       R3,DPH
   \   000023   12....       LCALL     `??AddrMgrExtAddrSet::?relay`; Banked call to: AddrMgrExtAddrSet
   \   000026   7416         MOV       A,#0x16
   \   000028   12....       LCALL     ?XSTACK_DISP0_8
   \   00002B   12....       LCALL     ?Subroutine41 & 0xFFFF
    494          
    495            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \                     ??CrossCallReturnLabel_43:
   \   00002E   700A         JNZ       ??ZDSecMgrAddrStore_0
    496            {
    497              // return successful results
    498              *ami   = entry.index;
   \   000030   740B         MOV       A,#0xb
   \   000032   12....       LCALL     ?XSTACK_DISP0_8
   \   000035   12....       LCALL     ?Subroutine27 & 0xFFFF
    499              status = ZSuccess;
    500            }
   \                     ??CrossCallReturnLabel_19:
   \   000038   8008         SJMP      ??CrossCallReturnLabel_22
    501            else
    502            {
    503              // return failed results
    504              *ami   = entry.index;
   \                     ??ZDSecMgrAddrStore_0:
   \   00003A   740B         MOV       A,#0xb
   \   00003C   12....       LCALL     ?XSTACK_DISP0_8
   \   00003F   12....       LCALL     ?Subroutine28 & 0xFFFF
    505              status = ZNwkUnknownDevice;
    506            }
    507          
    508            return status;
   \                     ??CrossCallReturnLabel_22:
   \   000042   02....       LJMP      ?Subroutine8 & 0xFFFF
    509          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine41:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FE           MOV       R6,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   FF           MOV       R7,A
   \   000005                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000005                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000005   AA..         MOV       R2,?XSP + 0
   \   000007   AB..         MOV       R3,?XSP + 1
   \   000009   12....       LCALL     `??AddrMgrEntryUpdate::?relay`; Banked call to: AddrMgrEntryUpdate
   \   00000C   E9           MOV       A,R1
   \   00000D   6401         XRL       A,#0x1
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine28:
   \   000000   12....       LCALL     ?Subroutine63 & 0xFFFF
   \                     ??CrossCallReturnLabel_188:
   \   000003   79C8         MOV       R1,#-0x38
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine27:
   \   000000   12....       LCALL     ?Subroutine63 & 0xFFFF
   \                     ??CrossCallReturnLabel_187:
   \   000003   7900         MOV       R1,#0x0
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   740D         MOV       A,#0xd
   \   000002   02....       LJMP      ??Subroutine88_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine88_0:
   \   000000   12....       LCALL     ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine89_0
   \   000003                ; // Fall through to label ??Subroutine89_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine89_0:
   \   000000   7F01         MOV       R7,#0x1
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine35:
   \   000000   EA           MOV       A,R2
   \   000001   F0           MOVX      @DPTR,A
   \   000002   A3           INC       DPTR
   \   000003   EB           MOV       A,R3
   \   000004   F0           MOVX      @DPTR,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine63:
   \   000000   12....       LCALL     ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_212:
   \   000003   8E82         MOV       DPL,R6
   \   000005   8F83         MOV       DPH,R7
   \   000007                REQUIRE ??Subroutine97_0
   \   000007                ; // Fall through to label ??Subroutine97_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine97_0:
   \   000000   E8           MOV       A,R0
   \   000001   F0           MOVX      @DPTR,A
   \   000002   A3           INC       DPTR
   \   000003   E9           MOV       A,R1
   \   000004   F0           MOVX      @DPTR,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine73:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F8           MOV       R0,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   F9           MOV       R1,A
   \   000005   22           RET
    510          
    511          /******************************************************************************
    512           * @fn          ZDSecMgrExtAddrStore
    513           *
    514           * @brief       Store EXT address.
    515           *
    516           * @param       extAddr - [in] EXT address
    517           * @param       ami     - [out] Address Manager index
    518           *
    519           * @return      ZStatus_t
    520           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    521          ZStatus_t ZDSecMgrExtAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami )
   \                     ZDSecMgrExtAddrStore:
    522          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV       A,#-0xd
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
    523            ZStatus_t      status;
    524            AddrMgrEntry_t entry;
    525          
    526          
    527            // add entry
    528            entry.user    = ADDRMGR_USER_SECURITY;
   \   00000A   85..82       MOV       DPL,?XSP + 0
   \   00000D   85..83       MOV       DPH,?XSP + 1
   \   000010   7402         MOV       A,#0x2
   \   000012   F0           MOVX      @DPTR,A
    529            entry.nwkAddr = nwkAddr;
   \   000013   14           DEC       A
   \   000014   12....       LCALL     ?XSTACK_DISP0_8
   \   000017   12....       LCALL     ?Subroutine35 & 0xFFFF
    530            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \                     ??CrossCallReturnLabel_30:
   \   00001A                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   00001A   7403         MOV       A,#0x3
   \   00001C   12....       LCALL     ?XSTACK_DISP0_8
   \   00001F   AA82         MOV       R2,DPL
   \   000021   AB83         MOV       R3,DPH
   \   000023   12....       LCALL     `??AddrMgrExtAddrSet::?relay`; Banked call to: AddrMgrExtAddrSet
   \   000026   7416         MOV       A,#0x16
   \   000028   12....       LCALL     ?XSTACK_DISP0_8
   \   00002B   12....       LCALL     ?Subroutine41 & 0xFFFF
    531          
    532            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \                     ??CrossCallReturnLabel_44:
   \   00002E   700A         JNZ       ??ZDSecMgrExtAddrStore_0
    533            {
    534              // return successful results
    535              *ami   = entry.index;
   \   000030   740B         MOV       A,#0xb
   \   000032   12....       LCALL     ?XSTACK_DISP0_8
   \   000035   12....       LCALL     ?Subroutine27 & 0xFFFF
    536              status = ZSuccess;
    537            }
   \                     ??CrossCallReturnLabel_20:
   \   000038   8008         SJMP      ??CrossCallReturnLabel_23
    538            else
    539            {
    540              // return failed results
    541              *ami   = entry.index;
   \                     ??ZDSecMgrExtAddrStore_0:
   \   00003A   740B         MOV       A,#0xb
   \   00003C   12....       LCALL     ?XSTACK_DISP0_8
   \   00003F   12....       LCALL     ?Subroutine28 & 0xFFFF
    542              status = ZNwkUnknownDevice;
    543            }
    544          
    545            return status;
   \                     ??CrossCallReturnLabel_23:
   \   000042   80..         SJMP      ?Subroutine8
    546          }
    547          
    548          /******************************************************************************
    549           * @fn          ZDSecMgrExtAddrLookup
    550           *
    551           * @brief       Lookup index for specified EXT address.
    552           *
    553           * @param       extAddr - [in] EXT address
    554           * @param       ami     - [out] Address Manager index
    555           *
    556           * @return      ZStatus_t
    557           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    558          ZStatus_t ZDSecMgrExtAddrLookup( uint8* extAddr, uint16* ami )
   \                     ZDSecMgrExtAddrLookup:
    559          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV       A,#-0xd
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EC           MOV       A,R4
   \   00000B   FE           MOV       R6,A
   \   00000C   ED           MOV       A,R5
   \   00000D   FF           MOV       R7,A
    560            ZStatus_t      status;
    561            AddrMgrEntry_t entry;
    562          
    563          
    564            // lookup entry
    565            entry.user = ADDRMGR_USER_SECURITY;
   \   00000E   85..82       MOV       DPL,?XSP + 0
   \   000011   85..83       MOV       DPH,?XSP + 1
   \   000014   7402         MOV       A,#0x2
   \   000016   F0           MOVX      @DPTR,A
    566            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \   000017                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000017   EA           MOV       A,R2
   \   000018   FC           MOV       R4,A
   \   000019   EB           MOV       A,R3
   \   00001A   FD           MOV       R5,A
   \   00001B   7403         MOV       A,#0x3
   \   00001D   12....       LCALL     ?XSTACK_DISP0_8
   \   000020   AA82         MOV       R2,DPL
   \   000022   AB83         MOV       R3,DPH
   \   000024   12....       LCALL     `??AddrMgrExtAddrSet::?relay`; Banked call to: AddrMgrExtAddrSet
    567          
    568            if ( AddrMgrEntryLookupExt( &entry ) == TRUE )
   \   000027                ; Setup parameters for call to function AddrMgrEntryLookupExt
   \   000027   AA..         MOV       R2,?XSP + 0
   \   000029   AB..         MOV       R3,?XSP + 1
   \   00002B   12....       LCALL     `??AddrMgrEntryLookupExt::?relay`; Banked call to: AddrMgrEntryLookupExt
   \   00002E   E9           MOV       A,R1
   \   00002F   6401         XRL       A,#0x1
   \   000031   700A         JNZ       ??ZDSecMgrExtAddrLookup_0
    569            {
    570              // return successful results
    571              *ami   = entry.index;
   \   000033   740B         MOV       A,#0xb
   \   000035   12....       LCALL     ?XSTACK_DISP0_8
   \   000038   12....       LCALL     ?Subroutine27 & 0xFFFF
    572              status = ZSuccess;
    573            }
   \                     ??CrossCallReturnLabel_21:
   \   00003B   8008         SJMP      ??CrossCallReturnLabel_24
    574            else
    575            {
    576              // return failed results
    577              *ami   = entry.index;
   \                     ??ZDSecMgrExtAddrLookup_0:
   \   00003D   740B         MOV       A,#0xb
   \   00003F   12....       LCALL     ?XSTACK_DISP0_8
   \   000042   12....       LCALL     ?Subroutine28 & 0xFFFF
    578              status = ZNwkUnknownDevice;
    579            }
    580          
    581            return status;
   \                     ??CrossCallReturnLabel_24:
   \   000045                REQUIRE ?Subroutine8
   \   000045                ; // Fall through to label ?Subroutine8
    582          }
    583          
    584          /******************************************************************************
    585           * @fn          ZDSecMgrMasterKeyLookup
    586           *
    587           * @brief       Lookup MASTER key for specified address index.
    588           *
    589           * @param       ami - [in] Address Manager index
    590           * @param       key - [out] valid MASTER key
    591           *
    592           * @return      ZStatus_t
    593           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    594          ZStatus_t ZDSecMgrMasterKeyLookup( uint16 ami, uint8** key )
   \                     ZDSecMgrMasterKeyLookup:
    595          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   12....       LCALL     ?Subroutine64 & 0xFFFF
    596            ZStatus_t status;
    597            uint16    index;
    598          
    599          
    600            // initialize results
    601            *key   = NULL;
    602            status = ZNwkUnknownDevice;
    603          
    604            // verify data is available
    605            if ( ZDSecMgrMasterKeyData != NULL )
   \                     ??CrossCallReturnLabel_109:
   \   000008   90....       MOV       DPTR,#ZDSecMgrMasterKeyData
   \   00000B   12....       LCALL     ??Subroutine94_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_166:
   \   00000E   604C         JZ        ??ZDSecMgrMasterKeyLookup_0
    606            {
    607              for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX ; index++ )
   \   000010   7800         MOV       R0,#0x0
   \   000012   7900         MOV       R1,#0x0
    608              {
    609                if ( ZDSecMgrMasterKeyData[index].ami == ami )
   \                     ??ZDSecMgrMasterKeyLookup_1:
   \   000014   E8           MOV       A,R0
   \   000015   FC           MOV       R4,A
   \   000016   E9           MOV       A,R1
   \   000017   FD           MOV       R5,A
   \   000018   EC           MOV       A,R4
   \   000019   75F012       MOV       B,#0x12
   \   00001C   A4           MUL       AB
   \   00001D   FC           MOV       R4,A
   \   00001E   85F0..       MOV       ?V1,B
   \   000021   75F012       MOV       B,#0x12
   \   000024   ED           MOV       A,R5
   \   000025   A4           MUL       AB
   \   000026   25..         ADD       A,?V1
   \   000028   FD           MOV       R5,A
   \   000029   90....       MOV       DPTR,#ZDSecMgrMasterKeyData
   \   00002C   E0           MOVX      A,@DPTR
   \   00002D   2C           ADD       A,R4
   \   00002E   FC           MOV       R4,A
   \   00002F   A3           INC       DPTR
   \   000030   E0           MOVX      A,@DPTR
   \   000031   3D           ADDC      A,R5
   \   000032   FD           MOV       R5,A
   \   000033   8C82         MOV       DPL,R4
   \   000035   F583         MOV       DPH,A
   \   000037   E0           MOVX      A,@DPTR
   \   000038   6A           XRL       A,R2
   \   000039   7003         JNZ       ??ZDSecMgrMasterKeyLookup_2
   \   00003B   A3           INC       DPTR
   \   00003C   E0           MOVX      A,@DPTR
   \   00003D   6B           XRL       A,R3
   \                     ??ZDSecMgrMasterKeyLookup_2:
   \   00003E   7012         JNZ       ??CrossCallReturnLabel_105
    610                {
    611                  // return successful results
    612                  *key   = ZDSecMgrMasterKeyData[index].key;
   \   000040   EC           MOV       A,R4
   \   000041   2402         ADD       A,#0x2
   \   000043   F8           MOV       R0,A
   \   000044   E4           CLR       A
   \   000045   3D           ADDC      A,R5
   \   000046   F9           MOV       R1,A
   \   000047   8E82         MOV       DPL,R6
   \   000049   8F83         MOV       DPH,R7
   \   00004B   E8           MOV       A,R0
   \   00004C   F0           MOVX      @DPTR,A
   \   00004D   A3           INC       DPTR
   \   00004E   E9           MOV       A,R1
   \   00004F   12....       LCALL     ??Subroutine77_0 & 0xFFFF
    613                  status = ZSuccess;
    614          
    615                  // break from loop
    616                  index  = ZDSECMGR_MASTERKEY_MAX;
    617                }
    618              }
   \                     ??CrossCallReturnLabel_105:
   \   000052   08           INC       R0
   \   000053   E8           MOV       A,R0
   \   000054   7001         JNZ       ??ZDSecMgrMasterKeyLookup_3
   \   000056   09           INC       R1
   \                     ??ZDSecMgrMasterKeyLookup_3:
   \   000057   12....       LCALL     ?Subroutine57 & 0xFFFF
    619            }
   \                     ??CrossCallReturnLabel_72:
   \   00005A   40B8         JC        ??ZDSecMgrMasterKeyLookup_1
    620          
    621            return status;
   \                     ??ZDSecMgrMasterKeyLookup_0:
   \   00005C                REQUIRE ?Subroutine11
   \   00005C                ; // Fall through to label ?Subroutine11
    622          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   A9..         MOV       R1,?V0
   \   000002   02....       LJMP      ??Subroutine102_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine64:
   \   000000   EC           MOV       A,R4
   \   000001   FE           MOV       R6,A
   \   000002   ED           MOV       A,R5
   \   000003   FF           MOV       R7,A
   \   000004   8C82         MOV       DPL,R4
   \   000006   F583         MOV       DPH,A
   \   000008                REQUIRE ??Subroutine75_0
   \   000008                ; // Fall through to label ??Subroutine75_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine75_0:
   \   000000   E4           CLR       A
   \   000001   F0           MOVX      @DPTR,A
   \   000002   A3           INC       DPTR
   \   000003   F0           MOVX      @DPTR,A
   \   000004   75..C8       MOV       ?V0,#-0x38
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine77_0:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   75..00       MOV       ?V0,#0x0
   \   000004   7803         MOV       R0,#0x3
   \   000006   7900         MOV       R1,#0x0
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine94_0:
   \   000000   12....       LCALL     ?Subroutine71 & 0xFFFF
   \                     ??CrossCallReturnLabel_209:
   \   000003   E8           MOV       A,R0
   \   000004   49           ORL       A,R1
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine71:
   \   000000   12....       LCALL     ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_214:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine102_0:
   \   000000   7F02         MOV       R7,#0x2
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA
    623          
    624          /******************************************************************************
    625           * @fn          ZDSecMgrMasterKeyStore
    626           *
    627           * @brief       Store MASTER key for specified address index.
    628           *
    629           * @param       ami - [in] Address Manager index
    630           * @param       key - [in] valid key to store
    631           *
    632           * @return      ZStatus_t
    633           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    634          ZStatus_t ZDSecMgrMasterKeyStore( uint16 ami, uint8* key )
   \                     ZDSecMgrMasterKeyStore:
    635          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV       A,#-0xe
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V4,R2
   \   000007   8B..         MOV       ?V5,R3
   \   000009   EC           MOV       A,R4
   \   00000A   FE           MOV       R6,A
   \   00000B   ED           MOV       A,R5
   \   00000C   FF           MOV       R7,A
    636            ZStatus_t status;
    637            uint16    index;
    638            uint8*    entry;
    639          
    640          
    641            // initialize results
    642            status = ZNwkUnknownDevice;
   \   00000D   7CC8         MOV       R4,#-0x38
    643          
    644            // verify data is available
    645            if ( ZDSecMgrMasterKeyData != NULL )
   \   00000F   90....       MOV       DPTR,#ZDSecMgrMasterKeyData
   \   000012   12....       LCALL     ??Subroutine94_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_167:
   \   000015   606F         JZ        ??ZDSecMgrMasterKeyStore_0
    646            {
    647              for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX ; index++ )
   \   000017   7800         MOV       R0,#0x0
   \   000019   7900         MOV       R1,#0x0
    648              {
    649                if ( ZDSecMgrMasterKeyData[index].ami == INVALID_NODE_ADDR )
   \                     ??ZDSecMgrMasterKeyStore_1:
   \   00001B   E8           MOV       A,R0
   \   00001C   FA           MOV       R2,A
   \   00001D   E9           MOV       A,R1
   \   00001E   FB           MOV       R3,A
   \   00001F   EA           MOV       A,R2
   \   000020   75F012       MOV       B,#0x12
   \   000023   A4           MUL       AB
   \   000024   FA           MOV       R2,A
   \   000025   ADF0         MOV       R5,B
   \   000027   75F012       MOV       B,#0x12
   \   00002A   EB           MOV       A,R3
   \   00002B   A4           MUL       AB
   \   00002C   2D           ADD       A,R5
   \   00002D   FB           MOV       R3,A
   \   00002E   90....       MOV       DPTR,#ZDSecMgrMasterKeyData
   \   000031   12....       LCALL     ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_54:
   \   000034   64FE         XRL       A,#0xfe
   \   000036   7003         JNZ       ??ZDSecMgrMasterKeyStore_2
   \   000038   A3           INC       DPTR
   \   000039   E0           MOVX      A,@DPTR
   \   00003A   F4           CPL       A
   \                     ??ZDSecMgrMasterKeyStore_2:
   \   00003B   703F         JNZ       ??ZDSecMgrMasterKeyStore_3
    650                {
    651                  // store EXT address index
    652                  ZDSecMgrMasterKeyData[index].ami = ami;
   \   00003D   8A82         MOV       DPL,R2
   \   00003F   8B83         MOV       DPH,R3
   \   000041   E5..         MOV       A,?V4
   \   000043   F0           MOVX      @DPTR,A
   \   000044   A3           INC       DPTR
   \   000045   E5..         MOV       A,?V5
   \   000047   F0           MOVX      @DPTR,A
    653          
    654                  entry = ZDSecMgrMasterKeyData[index].key;
   \   000048   EA           MOV       A,R2
   \   000049   2402         ADD       A,#0x2
   \   00004B   FA           MOV       R2,A
   \   00004C   5001         JNC       ??ZDSecMgrMasterKeyStore_4
   \   00004E   0B           INC       R3
    655          
    656                  if ( key != NULL )
   \                     ??ZDSecMgrMasterKeyStore_4:
   \   00004F   EE           MOV       A,R6
   \   000050   4F           ORL       A,R7
   \   000051   601A         JZ        ??ZDSecMgrMasterKeyStore_5
    657                  {
    658                    osal_memcpy( entry, key,  SEC_KEY_LEN );
   \   000053                ; Setup parameters for call to function osal_memcpy
   \   000053   8E..         MOV       ?V0,R6
   \   000055   8F..         MOV       ?V1,R7
   \   000057   75..00       MOV       ?V2,#0x0
   \   00005A   78..         MOV       R0,#?V0
   \   00005C   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   00005F   7C10         MOV       R4,#0x10
   \   000061   7D00         MOV       R5,#0x0
   \   000063   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000066   7403         MOV       A,#0x3
   \   000068   12....       LCALL     ?DEALLOC_XSTACK8
   \   00006B   8009         SJMP      ??ZDSecMgrMasterKeyStore_6
    659                  }
    660                  else
    661                  {
    662                    osal_memset( entry, 0, SEC_KEY_LEN );
   \                     ??ZDSecMgrMasterKeyStore_5:
   \   00006D                ; Setup parameters for call to function osal_memset
   \   00006D   7C10         MOV       R4,#0x10
   \   00006F   7D00         MOV       R5,#0x0
   \   000071   7900         MOV       R1,#0x0
   \   000073   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
    663                  }
    664          
    665                  // return successful results
    666                  status = ZSuccess;
   \                     ??ZDSecMgrMasterKeyStore_6:
   \   000076   7C00         MOV       R4,#0x0
    667          
    668                  // break from loop
    669                  index  = ZDSECMGR_MASTERKEY_MAX;
   \   000078   7803         MOV       R0,#0x3
   \   00007A   7900         MOV       R1,#0x0
    670                }
    671              }
   \                     ??ZDSecMgrMasterKeyStore_3:
   \   00007C   08           INC       R0
   \   00007D   E8           MOV       A,R0
   \   00007E   7001         JNZ       ??ZDSecMgrMasterKeyStore_7
   \   000080   09           INC       R1
   \                     ??ZDSecMgrMasterKeyStore_7:
   \   000081   12....       LCALL     ?Subroutine57 & 0xFFFF
    672            }
   \                     ??CrossCallReturnLabel_73:
   \   000084   4095         JC        ??ZDSecMgrMasterKeyStore_1
    673          
    674            return status;
   \                     ??ZDSecMgrMasterKeyStore_0:
   \   000086   EC           MOV       A,R4
   \   000087   F9           MOV       R1,A
   \   000088                REQUIRE ?Subroutine3
   \   000088                ; // Fall through to label ?Subroutine3
    675          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   7F06         MOV       R7,#0x6
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine47:
   \   000000   12....       LCALL     ?Subroutine69 & 0xFFFF
   \                     ??CrossCallReturnLabel_98:
   \   000003   E0           MOVX      A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine69:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   2A           ADD       A,R2
   \   000002   FA           MOV       R2,A
   \   000003   A3           INC       DPTR
   \   000004   E0           MOVX      A,@DPTR
   \   000005   3B           ADDC      A,R3
   \   000006   FB           MOV       R3,A
   \   000007   8A82         MOV       DPL,R2
   \   000009   F583         MOV       DPH,A
   \   00000B   22           RET
    676          
    677          /******************************************************************************
    678           * @fn          ZDSecMgrEntryInit
    679           *
    680           * @brief       Initialize entry sub module
    681           *
    682           * @param       none
    683           *
    684           * @return      none
    685           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    686          void ZDSecMgrEntryInit( void )
   \                     ZDSecMgrEntryInit:
    687          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    688            uint16 size;
    689            uint16 index;
    690          
    691            // allocate entry data
    692            size = (short)( sizeof(ZDSecMgrEntry_t) * ZDSECMGR_ENTRY_MAX );
    693          
    694            ZDSecMgrEntries = osal_mem_alloc( size );
   \   000004                ; Setup parameters for call to function osal_mem_alloc
   \   000004   7A57         MOV       R2,#0x57
   \   000006   7B00         MOV       R3,#0x0
   \   000008   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00000B   90....       MOV       DPTR,#ZDSecMgrEntries
   \   00000E   12....       LCALL     ?Subroutine24 & 0xFFFF
    695          
    696            // initialize data
    697            if ( ZDSecMgrEntries != NULL )
   \                     ??CrossCallReturnLabel_13:
   \   000011   6025         JZ        ??ZDSecMgrEntryInit_0
    698            {
    699              for( index = 0; index < ZDSECMGR_ENTRY_MAX; index++ )
   \   000013   7800         MOV       R0,#0x0
   \   000015   7900         MOV       R1,#0x0
    700              {
    701                ZDSecMgrEntries[index].ami = INVALID_NODE_ADDR;
   \                     ??ZDSecMgrEntryInit_1:
   \   000017   E8           MOV       A,R0
   \   000018   FA           MOV       R2,A
   \   000019   E9           MOV       A,R1
   \   00001A   FB           MOV       R3,A
   \   00001B   EA           MOV       A,R2
   \   00001C   75F01D       MOV       B,#0x1d
   \   00001F   A4           MUL       AB
   \   000020   FA           MOV       R2,A
   \   000021   ACF0         MOV       R4,B
   \   000023   75F01D       MOV       B,#0x1d
   \   000026   EB           MOV       A,R3
   \   000027   A4           MUL       AB
   \   000028   2C           ADD       A,R4
   \   000029   FB           MOV       R3,A
   \   00002A   90....       MOV       DPTR,#ZDSecMgrEntries
   \   00002D   12....       LCALL     ?Subroutine39 & 0xFFFF
    702              }
   \                     ??CrossCallReturnLabel_40:
   \   000030   7001         JNZ       ??ZDSecMgrEntryInit_2
   \   000032   09           INC       R1
   \                     ??ZDSecMgrEntryInit_2:
   \   000033   12....       LCALL     ?Subroutine57 & 0xFFFF
    703            }
   \                     ??CrossCallReturnLabel_74:
   \   000036   40DF         JC        ??ZDSecMgrEntryInit_1
    704            ZDSecMgrRestoreFromNV();
   \                     ??ZDSecMgrEntryInit_0:
   \   000038                ; Setup parameters for call to function ZDSecMgrRestoreFromNV
   \   000038   12....       LCALL     `??ZDSecMgrRestoreFromNV::?relay`; Banked call to: ZDSecMgrRestoreFromNV
    705          }
   \   00003B   02....       LJMP      ??Subroutine86_0 & 0xFFFF
    706          
    707          /******************************************************************************
    708           * @fn          ZDSecMgrEntryLookup
    709           *
    710           * @brief       Lookup entry index using specified NWK address.
    711           *
    712           * @param       nwkAddr - [in] NWK address
    713           * @param       entry   - [out] valid entry
    714           *
    715           * @return      ZStatus_t
    716           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    717          ZStatus_t ZDSecMgrEntryLookup( uint16 nwkAddr, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookup:
    718          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV       A,#-0xd
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EC           MOV       A,R4
   \   00000B   FE           MOV       R6,A
   \   00000C   ED           MOV       A,R5
   \   00000D   FF           MOV       R7,A
    719            ZStatus_t      status;
    720            uint16         index;
    721            AddrMgrEntry_t addrMgrEntry;
    722          
    723          
    724            // initialize results
    725            *entry = NULL;
   \   00000E   8C82         MOV       DPL,R4
   \   000010   12....       LCALL     ?Subroutine15 & 0xFFFF
    726            status = ZNwkUnknownDevice;
    727          
    728            // verify data is available
    729            if ( ZDSecMgrEntries != NULL )
   \                     ??CrossCallReturnLabel_106:
   \   000013   605A         JZ        ??ZDSecMgrEntryLookup_0
    730            {
    731              addrMgrEntry.user    = ADDRMGR_USER_SECURITY;
   \   000015   85..82       MOV       DPL,?XSP + 0
   \   000018   85..83       MOV       DPH,?XSP + 1
   \   00001B   7402         MOV       A,#0x2
   \   00001D   F0           MOVX      @DPTR,A
    732              addrMgrEntry.nwkAddr = nwkAddr;
   \   00001E   14           DEC       A
   \   00001F   12....       LCALL     ?XSTACK_DISP0_8
   \   000022   12....       LCALL     ?Subroutine33 & 0xFFFF
    733          
    734              if ( AddrMgrEntryLookupNwk( &addrMgrEntry ) == TRUE )
   \                     ??CrossCallReturnLabel_138:
   \   000025   12....       LCALL     `??AddrMgrEntryLookupNwk::?relay`; Banked call to: AddrMgrEntryLookupNwk
   \   000028   E9           MOV       A,R1
   \   000029   6401         XRL       A,#0x1
   \   00002B   7042         JNZ       ??ZDSecMgrEntryLookup_0
    735              {
    736                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   00002D   7800         MOV       R0,#0x0
   \   00002F   7900         MOV       R1,#0x0
    737                {
    738                  if ( addrMgrEntry.index == ZDSecMgrEntries[index].ami )
   \                     ??ZDSecMgrEntryLookup_1:
   \   000031   E8           MOV       A,R0
   \   000032   FA           MOV       R2,A
   \   000033   E9           MOV       A,R1
   \   000034   FB           MOV       R3,A
   \   000035   EA           MOV       A,R2
   \   000036   75F01D       MOV       B,#0x1d
   \   000039   A4           MUL       AB
   \   00003A   FA           MOV       R2,A
   \   00003B   ACF0         MOV       R4,B
   \   00003D   75F01D       MOV       B,#0x1d
   \   000040   EB           MOV       A,R3
   \   000041   A4           MUL       AB
   \   000042   2C           ADD       A,R4
   \   000043   FB           MOV       R3,A
   \   000044   90....       MOV       DPTR,#ZDSecMgrEntries
   \   000047   E0           MOVX      A,@DPTR
   \   000048   2A           ADD       A,R2
   \   000049   FA           MOV       R2,A
   \   00004A   A3           INC       DPTR
   \   00004B   E0           MOVX      A,@DPTR
   \   00004C   3B           ADDC      A,R3
   \   00004D   FB           MOV       R3,A
   \   00004E   740B         MOV       A,#0xb
   \   000050   12....       LCALL     ?XSTACK_DISP0_8
   \   000053   12....       LCALL     ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_61:
   \   000056   6C           XRL       A,R4
   \   000057   7003         JNZ       ??ZDSecMgrEntryLookup_2
   \   000059   A3           INC       DPTR
   \   00005A   E0           MOVX      A,@DPTR
   \   00005B   6D           XRL       A,R5
   \                     ??ZDSecMgrEntryLookup_2:
   \   00005C   7007         JNZ       ??CrossCallReturnLabel_103
    739                  {
    740                    // return successful results
    741                    *entry = &ZDSecMgrEntries[index];
   \   00005E   8E82         MOV       DPL,R6
   \   000060   8F83         MOV       DPH,R7
   \   000062   12....       LCALL     ?Subroutine20 & 0xFFFF
    742                    status = ZSuccess;
    743          
    744                    // break from loop
    745                    index = ZDSECMGR_ENTRY_MAX;
    746                  }
    747                }
   \                     ??CrossCallReturnLabel_103:
   \   000065   08           INC       R0
   \   000066   E8           MOV       A,R0
   \   000067   7001         JNZ       ??ZDSecMgrEntryLookup_3
   \   000069   09           INC       R1
   \                     ??ZDSecMgrEntryLookup_3:
   \   00006A   12....       LCALL     ?Subroutine57 & 0xFFFF
    748              }
    749            }
   \                     ??CrossCallReturnLabel_75:
   \   00006D   40C2         JC        ??ZDSecMgrEntryLookup_1
    750          
    751            return status;
   \                     ??ZDSecMgrEntryLookup_0:
   \   00006F                REQUIRE ?Subroutine12
   \   00006F                ; // Fall through to label ?Subroutine12
    752          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   A9..         MOV       R1,?V0
   \   000002                REQUIRE ??Subroutine76_0
   \   000002                ; // Fall through to label ??Subroutine76_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine76_0:
   \   000000   740D         MOV       A,#0xd
   \   000002   02....       LJMP      ??Subroutine101_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   EA           MOV       A,R2
   \   000001   F0           MOVX      @DPTR,A
   \   000002   A3           INC       DPTR
   \   000003   EB           MOV       A,R3
   \   000004                REQUIRE ??Subroutine77_0
   \   000004                ; // Fall through to label ??Subroutine77_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   F583         MOV       DPH,A
   \   000002                REQUIRE ??Subroutine78_0
   \   000002                ; // Fall through to label ??Subroutine78_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine78_0:
   \   000000   12....       LCALL     ??Subroutine75_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_111:
   \   000003   90....       MOV       DPTR,#ZDSecMgrEntries
   \   000006   12....       LCALL     ?Subroutine71 & 0xFFFF
   \                     ??CrossCallReturnLabel_208:
   \   000009   E8           MOV       A,R0
   \   00000A   49           ORL       A,R1
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine51:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FC           MOV       R4,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   FD           MOV       R5,A
   \   000005   8A82         MOV       DPL,R2
   \   000007   8B83         MOV       DPH,R3
   \   000009   E0           MOVX      A,@DPTR
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine33:
   \   000000   EA           MOV       A,R2
   \   000001   F0           MOVX      @DPTR,A
   \   000002   A3           INC       DPTR
   \   000003   EB           MOV       A,R3
   \   000004                REQUIRE ??Subroutine90_0
   \   000004                ; // Fall through to label ??Subroutine90_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine90_0:
   \   000000   F0           MOVX      @DPTR,A
   \   000001                ; Setup parameters for call to function AddrMgrEntryLookupNwk
   \   000001                ; Setup parameters for call to function AddrMgrEntryGet
   \   000001                ; Setup parameters for call to function APSME_EstablishKeyReq
   \   000001                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000001                ; Setup parameters for call to function NLME_LeaveReq
   \   000001                ; Setup parameters for call to function APSME_UpdateDeviceReq
   \   000001                ; Setup parameters for call to function APSME_AuthenticateReq
   \   000001                ; Setup parameters for call to function ZDSecMgrDeviceNew
   \   000001                ; Setup parameters for call to function APSME_EstablishKeyRsp
   \   000001                ; Setup parameters for call to function ZDSecMgrDeviceRemove
   \   000001                ; Setup parameters for call to function APSME_SwitchKeyReq
   \   000001   AA..         MOV       R2,?XSP + 0
   \   000003   AB..         MOV       R3,?XSP + 1
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine101_0:
   \   000000   12....       LCALL     ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine102_0
   \   000003                ; // Fall through to label ??Subroutine102_0
    753          
    754          /******************************************************************************
    755           * @fn          ZDSecMgrEntryLookupAMI
    756           *
    757           * @brief       Lookup entry using specified address index
    758           *
    759           * @param       ami   - [in] Address Manager index
    760           * @param       entry - [out] valid entry
    761           *
    762           * @return      ZStatus_t
    763           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    764          ZStatus_t ZDSecMgrEntryLookupAMI( uint16 ami, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookupAMI:
    765          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
    766            ZStatus_t status;
    767            uint16    index;
    768          
    769          
    770            // initialize results
    771            *entry = NULL;
   \   000009   8C82         MOV       DPL,R4
   \   00000B   8D83         MOV       DPH,R5
   \   00000D   12....       LCALL     ??Subroutine78_0 & 0xFFFF
    772            status = ZNwkUnknownDevice;
    773          
    774            // verify data is available
    775            if ( ZDSecMgrEntries != NULL )
   \                     ??CrossCallReturnLabel_108:
   \   000010   6038         JZ        ??ZDSecMgrEntryLookupAMI_0
    776            {
    777              for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   000012   7800         MOV       R0,#0x0
   \   000014   7900         MOV       R1,#0x0
    778              {
    779                if ( ZDSecMgrEntries[index].ami == ami )
   \                     ??ZDSecMgrEntryLookupAMI_1:
   \   000016   E8           MOV       A,R0
   \   000017   FA           MOV       R2,A
   \   000018   E9           MOV       A,R1
   \   000019   FB           MOV       R3,A
   \   00001A   EA           MOV       A,R2
   \   00001B   75F01D       MOV       B,#0x1d
   \   00001E   A4           MUL       AB
   \   00001F   FA           MOV       R2,A
   \   000020   85F0..       MOV       ?V1,B
   \   000023   75F01D       MOV       B,#0x1d
   \   000026   EB           MOV       A,R3
   \   000027   A4           MUL       AB
   \   000028   25..         ADD       A,?V1
   \   00002A   FB           MOV       R3,A
   \   00002B   90....       MOV       DPTR,#ZDSecMgrEntries
   \   00002E   12....       LCALL     ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_55:
   \   000031   6E           XRL       A,R6
   \   000032   7003         JNZ       ??ZDSecMgrEntryLookupAMI_2
   \   000034   A3           INC       DPTR
   \   000035   E0           MOVX      A,@DPTR
   \   000036   6F           XRL       A,R7
   \                     ??ZDSecMgrEntryLookupAMI_2:
   \   000037   7007         JNZ       ??CrossCallReturnLabel_104
    780                {
    781                  // return successful results
    782                  *entry = &ZDSecMgrEntries[index];
   \   000039   8C82         MOV       DPL,R4
   \   00003B   8D83         MOV       DPH,R5
   \   00003D   12....       LCALL     ?Subroutine20 & 0xFFFF
    783                  status = ZSuccess;
    784          
    785                  // break from loop
    786                  index = ZDSECMGR_ENTRY_MAX;
    787                }
    788              }
   \                     ??CrossCallReturnLabel_104:
   \   000040   08           INC       R0
   \   000041   E8           MOV       A,R0
   \   000042   7001         JNZ       ??ZDSecMgrEntryLookupAMI_3
   \   000044   09           INC       R1
   \                     ??ZDSecMgrEntryLookupAMI_3:
   \   000045   12....       LCALL     ?Subroutine57 & 0xFFFF
    789            }
   \                     ??CrossCallReturnLabel_76:
   \   000048   40CC         JC        ??ZDSecMgrEntryLookupAMI_1
    790          
    791            return status;
   \                     ??ZDSecMgrEntryLookupAMI_0:
   \   00004A   02....       LJMP      ?Subroutine11 & 0xFFFF
    792          }
    793          
    794          /******************************************************************************
    795           * @fn          ZDSecMgrEntryLookupExt
    796           *
    797           * @brief       Lookup entry index using specified EXT address.
    798           *
    799           * @param       extAddr - [in] EXT address
    800           * @param       entry   - [out] valid entry
    801           *
    802           * @return      ZStatus_t
    803           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    804          ZStatus_t ZDSecMgrEntryLookupExt( uint8* extAddr, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookupExt:
    805          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   12....       LCALL     ?Subroutine64 & 0xFFFF
    806            ZStatus_t status;
    807            uint16    ami;
    808          
    809          
    810            // initialize results
    811            *entry = NULL;
    812            status = ZNwkUnknownDevice;
    813          
    814            // lookup address index
    815            if ( ZDSecMgrExtAddrLookup( extAddr, &ami ) == ZSuccess )
   \                     ??CrossCallReturnLabel_110:
   \   00000D                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00000D   AC..         MOV       R4,?XSP + 0
   \   00000F   AD..         MOV       R5,?XSP + 1
   \   000011   12....       LCALL     `??ZDSecMgrExtAddrLookup::?relay`; Banked call to: ZDSecMgrExtAddrLookup
   \   000014   E9           MOV       A,R1
   \   000015   7010         JNZ       ??ZDSecMgrEntryLookupExt_0
    816            {
    817              status = ZDSecMgrEntryLookupAMI( ami, entry );
   \   000017                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   000017   EE           MOV       A,R6
   \   000018   FC           MOV       R4,A
   \   000019   EF           MOV       A,R7
   \   00001A   FD           MOV       R5,A
   \   00001B   85..82       MOV       DPL,?XSP + 0
   \   00001E   85..83       MOV       DPH,?XSP + 1
   \   000021   12....       LCALL     ?Subroutine52 & 0xFFFF
    818            }
   \                     ??CrossCallReturnLabel_63:
   \   000024   E9           MOV       A,R1
   \   000025   F5..         MOV       ?V0,A
    819          
    820            return status;
   \                     ??ZDSecMgrEntryLookupExt_0:
   \   000027   02....       LJMP      ?Subroutine1 & 0xFFFF
    821          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   A9..         MOV       R1,?V0
   \   000002                REQUIRE ??Subroutine87_0
   \   000002                ; // Fall through to label ??Subroutine87_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine87_0:
   \   000000   7402         MOV       A,#0x2
   \   000002                REQUIRE ??Subroutine88_0
   \   000002                ; // Fall through to label ??Subroutine88_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine52:
   \   000000   12....       LCALL     ??Subroutine105_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_226:
   \   000003   12....       LCALL     `??ZDSecMgrEntryLookupAMI::?relay`; Banked call to: ZDSecMgrEntryLookupAMI
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine105_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FA           MOV       R2,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   FB           MOV       R3,A
   \   000005   22           RET
    822          
    823          /******************************************************************************
    824           * @fn          ZDSecMgrEntryFree
    825           *
    826           * @brief       Free entry.
    827           *
    828           * @param       entry - [in] valid entry
    829           *
    830           * @return      ZStatus_t
    831           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    832          void ZDSecMgrEntryFree( ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrEntryFree:
    833          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    834            entry->ami = INVALID_NODE_ADDR;
   \   000004   8A82         MOV       DPL,R2
   \   000006   8B83         MOV       DPH,R3
   \   000008   74FE         MOV       A,#-0x2
   \   00000A   F0           MOVX      @DPTR,A
   \   00000B   A3           INC       DPTR
   \   00000C   04           INC       A
   \   00000D   F0           MOVX      @DPTR,A
    835          }
   \   00000E   02....       LJMP      ??Subroutine86_0 & 0xFFFF
    836          
    837          /******************************************************************************
    838           * @fn          ZDSecMgrEntryNew
    839           *
    840           * @brief       Get a new entry.
    841           *
    842           * @param       entry - [out] valid entry
    843           *
    844           * @return      ZStatus_t
    845           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    846          ZStatus_t ZDSecMgrEntryNew( ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryNew:
    847          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
    848            ZStatus_t status;
    849            uint16    index;
    850          
    851          
    852            // initialize results
    853            *entry = NULL;
   \   000009   8A82         MOV       DPL,R2
   \   00000B   12....       LCALL     ?Subroutine15 & 0xFFFF
    854            status = ZNwkUnknownDevice;
    855          
    856            // verify data is available
    857            if ( ZDSecMgrEntries != NULL )
   \                     ??CrossCallReturnLabel_107:
   \   00000E   6060         JZ        ??ZDSecMgrEntryNew_0
    858            {
    859              // find available entry
    860              for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   000010   7A00         MOV       R2,#0x0
   \   000012   7B00         MOV       R3,#0x0
    861              {
    862                if ( ZDSecMgrEntries[index].ami == INVALID_NODE_ADDR )
   \                     ??ZDSecMgrEntryNew_1:
   \   000014   EA           MOV       A,R2
   \   000015   F8           MOV       R0,A
   \   000016   EB           MOV       A,R3
   \   000017   F9           MOV       R1,A
   \   000018   E8           MOV       A,R0
   \   000019   75F01D       MOV       B,#0x1d
   \   00001C   A4           MUL       AB
   \   00001D   F8           MOV       R0,A
   \   00001E   ACF0         MOV       R4,B
   \   000020   75F01D       MOV       B,#0x1d
   \   000023   E9           MOV       A,R1
   \   000024   A4           MUL       AB
   \   000025   2C           ADD       A,R4
   \   000026   F9           MOV       R1,A
   \   000027   90....       MOV       DPTR,#ZDSecMgrEntries
   \   00002A   E0           MOVX      A,@DPTR
   \   00002B   28           ADD       A,R0
   \   00002C   FC           MOV       R4,A
   \   00002D   A3           INC       DPTR
   \   00002E   E0           MOVX      A,@DPTR
   \   00002F   39           ADDC      A,R1
   \   000030   FD           MOV       R5,A
   \   000031   8C82         MOV       DPL,R4
   \   000033   F583         MOV       DPH,A
   \   000035   E0           MOVX      A,@DPTR
   \   000036   64FE         XRL       A,#0xfe
   \   000038   7003         JNZ       ??ZDSecMgrEntryNew_2
   \   00003A   A3           INC       DPTR
   \   00003B   E0           MOVX      A,@DPTR
   \   00003C   F4           CPL       A
   \                     ??ZDSecMgrEntryNew_2:
   \   00003D   7024         JNZ       ??ZDSecMgrEntryNew_3
    863                {
    864                  // return successful result
    865                  *entry = &ZDSecMgrEntries[index];
   \   00003F   8E82         MOV       DPL,R6
   \   000041   8F83         MOV       DPH,R7
   \   000043   EC           MOV       A,R4
   \   000044   F0           MOVX      @DPTR,A
   \   000045   A3           INC       DPTR
   \   000046   ED           MOV       A,R5
   \   000047   F0           MOVX      @DPTR,A
    866                  status = ZSuccess;
   \   000048   75..00       MOV       ?V0,#0x0
    867          
    868                  // Set the authentication option to default
    869                  ZDSecMgrEntries[index].authenticateOption = ZDSecMgr_Not_Authenticated;
   \   00004B   90....       MOV       DPTR,#ZDSecMgrEntries
   \   00004E   E0           MOVX      A,@DPTR
   \   00004F   28           ADD       A,R0
   \   000050   F8           MOV       R0,A
   \   000051   A3           INC       DPTR
   \   000052   E0           MOVX      A,@DPTR
   \   000053   39           ADDC      A,R1
   \   000054   F9           MOV       R1,A
   \   000055   E8           MOV       A,R0
   \   000056   241C         ADD       A,#0x1c
   \   000058   F582         MOV       DPL,A
   \   00005A   E4           CLR       A
   \   00005B   39           ADDC      A,R1
   \   00005C   F583         MOV       DPH,A
   \   00005E   E4           CLR       A
   \   00005F   F0           MOVX      @DPTR,A
    870          
    871                  // break from loop
    872                  index = ZDSECMGR_ENTRY_MAX;
   \   000060   7A03         MOV       R2,#0x3
   \   000062   FB           MOV       R3,A
    873                }
    874              }
   \                     ??ZDSecMgrEntryNew_3:
   \   000063   0A           INC       R2
   \   000064   EA           MOV       A,R2
   \   000065   7001         JNZ       ??ZDSecMgrEntryNew_4
   \   000067   0B           INC       R3
   \                     ??ZDSecMgrEntryNew_4:
   \   000068   C3           CLR       C
   \   000069   9403         SUBB      A,#0x3
   \   00006B   EB           MOV       A,R3
   \   00006C   9400         SUBB      A,#0x0
   \   00006E   40A4         JC        ??ZDSecMgrEntryNew_1
    875            }
    876          
    877            return status;
   \                     ??ZDSecMgrEntryNew_0:
   \   000070   02....       LJMP      ?Subroutine11 & 0xFFFF
    878          }
    879          
    880          /******************************************************************************
    881           * @fn          ZDSecMgrCtrlInit
    882           *
    883           * @brief       Initialize control sub module
    884           *
    885           * @param       none
    886           *
    887           * @return      none
    888           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    889          void ZDSecMgrCtrlInit( void )
   \                     ZDSecMgrCtrlInit:
    890          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    891            uint16 size;
    892            uint16 index;
    893          
    894            // allocate entry data
    895            size = (short)( sizeof(ZDSecMgrCtrl_t) * ZDSECMGR_CTRL_MAX );
    896          
    897            ZDSecMgrCtrlData = osal_mem_alloc( size );
   \   000004                ; Setup parameters for call to function osal_mem_alloc
   \   000004   7A15         MOV       R2,#0x15
   \   000006   7B00         MOV       R3,#0x0
   \   000008   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00000B   90....       MOV       DPTR,#ZDSecMgrCtrlData
   \   00000E   12....       LCALL     ?Subroutine24 & 0xFFFF
    898          
    899            // initialize data
    900            if ( ZDSecMgrCtrlData != NULL )
   \                     ??CrossCallReturnLabel_14:
   \   000011   602E         JZ        ??ZDSecMgrCtrlInit_0
    901            {
    902              for( index = 0; index < ZDSECMGR_CTRL_MAX; index++ )
   \   000013   7800         MOV       R0,#0x0
   \   000015   7900         MOV       R1,#0x0
    903              {
    904                ZDSecMgrCtrlData[index].state = ZDSECMGR_CTRL_NONE;
   \                     ??ZDSecMgrCtrlInit_1:
   \   000017   E8           MOV       A,R0
   \   000018   FA           MOV       R2,A
   \   000019   E9           MOV       A,R1
   \   00001A   FB           MOV       R3,A
   \   00001B   EA           MOV       A,R2
   \   00001C   75F007       MOV       B,#0x7
   \   00001F   A4           MUL       AB
   \   000020   FA           MOV       R2,A
   \   000021   ACF0         MOV       R4,B
   \   000023   75F007       MOV       B,#0x7
   \   000026   EB           MOV       A,R3
   \   000027   A4           MUL       AB
   \   000028   2C           ADD       A,R4
   \   000029   FB           MOV       R3,A
   \   00002A   90....       MOV       DPTR,#ZDSecMgrCtrlData
   \   00002D   12....       LCALL     ?Subroutine72 & 0xFFFF
    905              }
   \                     ??CrossCallReturnLabel_101:
   \   000030   A3           INC       DPTR
   \   000031   A3           INC       DPTR
   \   000032   A3           INC       DPTR
   \   000033   A3           INC       DPTR
   \   000034   A3           INC       DPTR
   \   000035   E4           CLR       A
   \   000036   F0           MOVX      @DPTR,A
   \   000037   08           INC       R0
   \   000038   E8           MOV       A,R0
   \   000039   7001         JNZ       ??ZDSecMgrCtrlInit_2
   \   00003B   09           INC       R1
   \                     ??ZDSecMgrCtrlInit_2:
   \   00003C   12....       LCALL     ?Subroutine57 & 0xFFFF
    906            }
   \                     ??CrossCallReturnLabel_77:
   \   00003F   40D6         JC        ??ZDSecMgrCtrlInit_1
    907          }
   \                     ??ZDSecMgrCtrlInit_0:
   \   000041   02....       LJMP      ??Subroutine86_0 & 0xFFFF
    908          
    909          /******************************************************************************
    910           * @fn          ZDSecMgrCtrlRelease
    911           *
    912           * @brief       Release control data.
    913           *
    914           * @param       ctrl - [in] valid control data
    915           *
    916           * @return      none
    917           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    918          void ZDSecMgrCtrlRelease( ZDSecMgrCtrl_t* ctrl )
   \                     ZDSecMgrCtrlRelease:
    919          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    920            // should always be enough entry control data
    921            ctrl->state = ZDSECMGR_CTRL_NONE;
   \   000004   8A82         MOV       DPL,R2
   \   000006   8B83         MOV       DPH,R3
   \   000008   A3           INC       DPTR
   \   000009   A3           INC       DPTR
   \   00000A   A3           INC       DPTR
   \   00000B   A3           INC       DPTR
   \   00000C   A3           INC       DPTR
   \   00000D   E4           CLR       A
   \   00000E   F0           MOVX      @DPTR,A
    922          }
   \   00000F   02....       LJMP      ??Subroutine86_0 & 0xFFFF
    923          
    924          /******************************************************************************
    925           * @fn          ZDSecMgrCtrlLookup
    926           *
    927           * @brief       Lookup control data.
    928           *
    929           * @param       entry - [in] valid entry data
    930           * @param       ctrl  - [out] control data - NULL if not found
    931           *
    932           * @return      none
    933           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    934          void ZDSecMgrCtrlLookup( ZDSecMgrEntry_t* entry, ZDSecMgrCtrl_t** ctrl )
   \                     ZDSecMgrCtrlLookup:
    935          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
    936            uint16 index;
    937          
    938          
    939            // initialize search results
    940            *ctrl = NULL;
   \   000009   8C82         MOV       DPL,R4
   \   00000B   8D83         MOV       DPH,R5
   \   00000D   E4           CLR       A
   \   00000E   F0           MOVX      @DPTR,A
   \   00000F   A3           INC       DPTR
   \   000010   F0           MOVX      @DPTR,A
    941          
    942            // verify data is available
    943            if ( ZDSecMgrCtrlData != NULL )
   \   000011   90....       MOV       DPTR,#ZDSecMgrCtrlData
   \   000014   12....       LCALL     ??Subroutine94_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_168:
   \   000017   6047         JZ        ??ZDSecMgrCtrlLookup_0
    944            {
    945              for ( index = 0; index < ZDSECMGR_CTRL_MAX; index++ )
   \   000019   7800         MOV       R0,#0x0
   \   00001B   7900         MOV       R1,#0x0
    946              {
    947                // make sure control data is in use
    948                if ( ZDSecMgrCtrlData[index].state != ZDSECMGR_CTRL_NONE )
   \                     ??ZDSecMgrCtrlLookup_1:
   \   00001D   E8           MOV       A,R0
   \   00001E   FA           MOV       R2,A
   \   00001F   E9           MOV       A,R1
   \   000020   FB           MOV       R3,A
   \   000021   EA           MOV       A,R2
   \   000022   75F007       MOV       B,#0x7
   \   000025   A4           MUL       AB
   \   000026   FA           MOV       R2,A
   \   000027   85F0..       MOV       ?V0,B
   \   00002A   75F007       MOV       B,#0x7
   \   00002D   EB           MOV       A,R3
   \   00002E   A4           MUL       AB
   \   00002F   25..         ADD       A,?V0
   \   000031   12....       LCALL     ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_41:
   \   000034   6020         JZ        ??ZDSecMgrCtrlLookup_2
    949                {
    950                  // check for entry match
    951                  if ( ZDSecMgrCtrlData[index].entry == entry )
   \   000036   8A82         MOV       DPL,R2
   \   000038   8B83         MOV       DPH,R3
   \   00003A   E0           MOVX      A,@DPTR
   \   00003B   F5..         MOV       ?V0,A
   \   00003D   A3           INC       DPTR
   \   00003E   E0           MOVX      A,@DPTR
   \   00003F   F5..         MOV       ?V1,A
   \   000041   EE           MOV       A,R6
   \   000042   65..         XRL       A,?V0
   \   000044   7003         JNZ       ??ZDSecMgrCtrlLookup_3
   \   000046   EF           MOV       A,R7
   \   000047   65..         XRL       A,?V1
   \                     ??ZDSecMgrCtrlLookup_3:
   \   000049   700B         JNZ       ??ZDSecMgrCtrlLookup_2
    952                  {
    953                    // return this control data
    954                    *ctrl = &ZDSecMgrCtrlData[index];
   \   00004B   8C82         MOV       DPL,R4
   \   00004D   8D83         MOV       DPH,R5
   \   00004F   12....       LCALL     ?Subroutine35 & 0xFFFF
    955          
    956                    // break from loop
    957                    index = ZDSECMGR_CTRL_MAX;
   \                     ??CrossCallReturnLabel_31:
   \   000052   7803         MOV       R0,#0x3
   \   000054   7900         MOV       R1,#0x0
    958                  }
    959                }
    960              }
   \                     ??ZDSecMgrCtrlLookup_2:
   \   000056   08           INC       R0
   \   000057   E8           MOV       A,R0
   \   000058   7001         JNZ       ??ZDSecMgrCtrlLookup_4
   \   00005A   09           INC       R1
   \                     ??ZDSecMgrCtrlLookup_4:
   \   00005B   12....       LCALL     ?Subroutine57 & 0xFFFF
    961            }
   \                     ??CrossCallReturnLabel_78:
   \   00005E   40BD         JC        ??ZDSecMgrCtrlLookup_1
    962          }
   \                     ??ZDSecMgrCtrlLookup_0:
   \   000060   02....       LJMP      ??Subroutine102_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine40:
   \   000000   FB           MOV       R3,A
   \   000001   90....       MOV       DPTR,#ZDSecMgrCtrlData
   \   000004   12....       LCALL     ?Subroutine69 & 0xFFFF
   \                     ??CrossCallReturnLabel_97:
   \   000007   A3           INC       DPTR
   \   000008   A3           INC       DPTR
   \   000009   A3           INC       DPTR
   \   00000A   A3           INC       DPTR
   \   00000B   A3           INC       DPTR
   \   00000C   E0           MOVX      A,@DPTR
   \   00000D   22           RET
    963          
    964          /******************************************************************************
    965           * @fn          ZDSecMgrCtrlSet
    966           *
    967           * @brief       Set control data.
    968           *
    969           * @param       device - [in] valid device data
    970           * @param       entry  - [in] valid entry data
    971           * @param       ctrl   - [in] valid control data
    972           *
    973           * @return      none
    974           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    975          void ZDSecMgrCtrlSet( ZDSecMgrDevice_t* device,
   \                     ZDSecMgrCtrlSet:
    976                                ZDSecMgrEntry_t*  entry,
    977                                ZDSecMgrCtrl_t*   ctrl )
    978          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   7409         MOV       A,#0x9
   \   000007   12....       LCALL     ?XSTACK_DISP0_8
   \   00000A   12....       LCALL     ??Subroutine99_0 & 0xFFFF
    979            // set control date
    980            ctrl->parentAddr = device->parentAddr;
   \                     ??CrossCallReturnLabel_195:
   \   00000D   8A82         MOV       DPL,R2
   \   00000F   8B83         MOV       DPH,R3
   \   000011   A3           INC       DPTR
   \   000012   A3           INC       DPTR
   \   000013   A3           INC       DPTR
   \   000014   A3           INC       DPTR
   \   000015   E0           MOVX      A,@DPTR
   \   000016   FE           MOV       R6,A
   \   000017   A3           INC       DPTR
   \   000018   E0           MOVX      A,@DPTR
   \   000019   FF           MOV       R7,A
   \   00001A   8882         MOV       DPL,R0
   \   00001C   8983         MOV       DPH,R1
   \   00001E   A3           INC       DPTR
   \   00001F   A3           INC       DPTR
   \   000020   EE           MOV       A,R6
   \   000021   F0           MOVX      @DPTR,A
   \   000022   A3           INC       DPTR
   \   000023   EF           MOV       A,R7
   \   000024   12....       LCALL     ?Subroutine25 & 0xFFFF
    981            ctrl->secure     = device->secure;
   \                     ??CrossCallReturnLabel_15:
   \   000027   E0           MOVX      A,@DPTR
   \   000028   8882         MOV       DPL,R0
   \   00002A   8983         MOV       DPH,R1
   \   00002C   A3           INC       DPTR
   \   00002D   A3           INC       DPTR
   \   00002E   A3           INC       DPTR
   \   00002F   A3           INC       DPTR
   \   000030   12....       LCALL     ?Subroutine65 & 0xFFFF
    982            ctrl->entry      = entry;
   \                     ??CrossCallReturnLabel_90:
   \   000033   EC           MOV       A,R4
   \   000034   F0           MOVX      @DPTR,A
   \   000035   A3           INC       DPTR
   \   000036   ED           MOV       A,R5
   \   000037   12....       LCALL     ?Subroutine26 & 0xFFFF
    983            ctrl->state      = ZDSECMGR_CTRL_INIT;
   \                     ??CrossCallReturnLabel_17:
   \   00003A   7401         MOV       A,#0x1
   \   00003C   12....       LCALL     ?Subroutine26 & 0xFFFF
    984            ctrl->cntr       = 0;
   \                     ??CrossCallReturnLabel_18:
   \   00003F   A3           INC       DPTR
   \   000040   E4           CLR       A
   \   000041   12....       LCALL     ?Subroutine25 & 0xFFFF
    985          
    986            // set device pointer
    987            device->ctrl = ctrl;
   \                     ??CrossCallReturnLabel_16:
   \   000044   A3           INC       DPTR
   \   000045   A3           INC       DPTR
   \   000046   12....       LCALL     ??Subroutine91_0 & 0xFFFF
    988          }
   \                     ??CrossCallReturnLabel_149:
   \   000049   02....       LJMP      ??Subroutine89_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   12....       LCALL     ?Subroutine65 & 0xFFFF
   \                     ??CrossCallReturnLabel_91:
   \   000003   A3           INC       DPTR
   \   000004   A3           INC       DPTR
   \   000005   A3           INC       DPTR
   \   000006   A3           INC       DPTR
   \   000007   A3           INC       DPTR
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   8A82         MOV       DPL,R2
   \   000003   8B83         MOV       DPH,R3
   \   000005   A3           INC       DPTR
   \   000006   A3           INC       DPTR
   \   000007   A3           INC       DPTR
   \   000008   A3           INC       DPTR
   \   000009   A3           INC       DPTR
   \   00000A   A3           INC       DPTR
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine65:
   \   000000   F0           MOVX      @DPTR,A
   \   000001                ; Setup parameters for call to function AssocGetWithExt
   \   000001   8882         MOV       DPL,R0
   \   000003   8983         MOV       DPH,R1
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine91_0:
   \   000000   12....       LCALL     ??Subroutine97_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_190:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine99_0:
   \   000000   12....       LCALL     ?Subroutine71 & 0xFFFF
   \                     ??CrossCallReturnLabel_210:
   \   000003   22           RET
    989          
    990          /******************************************************************************
    991           * @fn          ZDSecMgrCtrlAdd
    992           *
    993           * @brief       Add control data.
    994           *
    995           * @param       device - [in] valid device data
    996           * @param       entry  - [in] valid entry data
    997           *
    998           * @return      ZStatus_t
    999           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1000          ZStatus_t ZDSecMgrCtrlAdd( ZDSecMgrDevice_t* device, ZDSecMgrEntry_t*  entry )
   \                     ZDSecMgrCtrlAdd:
   1001          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V0,R2
   \   000007   8B..         MOV       ?V1,R3
   \   000009   EC           MOV       A,R4
   \   00000A   FE           MOV       R6,A
   \   00000B   ED           MOV       A,R5
   \   00000C   FF           MOV       R7,A
   1002            ZStatus_t status;
   1003            uint16    index;
   1004          
   1005          
   1006            // initialize results
   1007            status = ZNwkUnknownDevice;
   \   00000D   7CC8         MOV       R4,#-0x38
   1008          
   1009            // verify data is available
   1010            if ( ZDSecMgrCtrlData != NULL )
   \   00000F   90....       MOV       DPTR,#ZDSecMgrCtrlData
   \   000012   12....       LCALL     ??Subroutine94_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_169:
   \   000015   6044         JZ        ??ZDSecMgrCtrlAdd_0
   1011            {
   1012              // look for an empty slot
   1013              for ( index = 0; index < ZDSECMGR_CTRL_MAX; index++ )
   \   000017   7800         MOV       R0,#0x0
   \   000019   7900         MOV       R1,#0x0
   1014              {
   1015                if ( ZDSecMgrCtrlData[index].state == ZDSECMGR_CTRL_NONE )
   \                     ??ZDSecMgrCtrlAdd_1:
   \   00001B   E8           MOV       A,R0
   \   00001C   FA           MOV       R2,A
   \   00001D   E9           MOV       A,R1
   \   00001E   FB           MOV       R3,A
   \   00001F   EA           MOV       A,R2
   \   000020   75F007       MOV       B,#0x7
   \   000023   A4           MUL       AB
   \   000024   FA           MOV       R2,A
   \   000025   ADF0         MOV       R5,B
   \   000027   75F007       MOV       B,#0x7
   \   00002A   EB           MOV       A,R3
   \   00002B   A4           MUL       AB
   \   00002C   2D           ADD       A,R5
   \   00002D   12....       LCALL     ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_42:
   \   000030   701F         JNZ       ??ZDSecMgrCtrlAdd_2
   1016                {
   1017                  // return successful results
   1018                  ZDSecMgrCtrlSet( device, entry, &ZDSecMgrCtrlData[index] );
   \   000032                ; Setup parameters for call to function ZDSecMgrCtrlSet
   \   000032   8A..         MOV       ?V2,R2
   \   000034   8B..         MOV       ?V3,R3
   \   000036   78..         MOV       R0,#?V2
   \   000038   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00003B   EE           MOV       A,R6
   \   00003C   FC           MOV       R4,A
   \   00003D   EF           MOV       A,R7
   \   00003E   FD           MOV       R5,A
   \   00003F   AA..         MOV       R2,?V0
   \   000041   AB..         MOV       R3,?V1
   \   000043   12....       LCALL     `??ZDSecMgrCtrlSet::?relay`; Banked call to: ZDSecMgrCtrlSet
   \   000046   7402         MOV       A,#0x2
   \   000048   12....       LCALL     ?DEALLOC_XSTACK8
   1019          
   1020                  status = ZSuccess;
   \   00004B   7C00         MOV       R4,#0x0
   1021          
   1022                  // break from loop
   1023                  index = ZDSECMGR_CTRL_MAX;
   \   00004D   7803         MOV       R0,#0x3
   \   00004F   7900         MOV       R1,#0x0
   1024                }
   1025              }
   \                     ??ZDSecMgrCtrlAdd_2:
   \   000051   08           INC       R0
   \   000052   E8           MOV       A,R0
   \   000053   7001         JNZ       ??ZDSecMgrCtrlAdd_3
   \   000055   09           INC       R1
   \                     ??ZDSecMgrCtrlAdd_3:
   \   000056   12....       LCALL     ?Subroutine57 & 0xFFFF
   1026            }
   \                     ??CrossCallReturnLabel_79:
   \   000059   40C0         JC        ??ZDSecMgrCtrlAdd_1
   1027          
   1028            return status;
   \                     ??ZDSecMgrCtrlAdd_0:
   \   00005B   EC           MOV       A,R4
   \   00005C   F9           MOV       R1,A
   \   00005D   02....       LJMP      ??Subroutine83_0 & 0xFFFF
   1029          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine83_0:
   \   000000   7F04         MOV       R7,#0x4
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA
   1030          
   1031          /******************************************************************************
   1032           * @fn          ZDSecMgrCtrlTerm
   1033           *
   1034           * @brief       Terminate device control.
   1035           *
   1036           * @param       entry - [in] valid entry data
   1037           *
   1038           * @return      none
   1039           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1040          void ZDSecMgrCtrlTerm( ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrCtrlTerm:
   1041          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 2
   \   000004   74FE         MOV       A,#-0x2
   \   000006   12....       LCALL     ?ALLOC_XSTACK8
   1042            ZDSecMgrCtrl_t* ctrl;
   1043          
   1044            // remove device from control data
   1045            ZDSecMgrCtrlLookup ( entry, &ctrl );
   \   000009                ; Setup parameters for call to function ZDSecMgrCtrlLookup
   \   000009   AC..         MOV       R4,?XSP + 0
   \   00000B   AD..         MOV       R5,?XSP + 1
   \   00000D   12....       LCALL     ??Subroutine92_0 & 0xFFFF
   1046          
   1047            if ( ctrl != NULL )
   \                     ??CrossCallReturnLabel_165:
   \   000010   6013         JZ        ??ZDSecMgrCtrlTerm_0
   1048            {
   1049              ZDSecMgrCtrlRelease ( ctrl );
   \   000012   85..82       MOV       DPL,?XSP + 0
   \   000015   85..83       MOV       DPH,?XSP + 1
   \   000018   A3           INC       DPTR
   \   000019   E0           MOVX      A,@DPTR
   \   00001A   F583         MOV       DPH,A
   \   00001C   8882         MOV       DPL,R0
   \   00001E   A3           INC       DPTR
   \   00001F   A3           INC       DPTR
   \   000020   A3           INC       DPTR
   \   000021   A3           INC       DPTR
   \   000022   A3           INC       DPTR
   \   000023   E4           CLR       A
   \   000024   F0           MOVX      @DPTR,A
   1050            }
   1051          }
   \                     ??ZDSecMgrCtrlTerm_0:
   \   000025   7402         MOV       A,#0x2
   \   000027   80..         SJMP      ??Subroutine79_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine79_0:
   \   000000   12....       LCALL     ?DEALLOC_XSTACK8
   \   000003   02....       LJMP      ??Subroutine86_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine92_0:
   \   000000   12....       LCALL     `??ZDSecMgrCtrlLookup::?relay`; Banked call to: ZDSecMgrCtrlLookup
   \   000003                REQUIRE ??Subroutine93_0
   \   000003                ; // Fall through to label ??Subroutine93_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine93_0:
   \   000000   85..82       MOV       DPL,?XSP + 0
   \   000003   85..83       MOV       DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine94_0
   \   000006                ; // Fall through to label ??Subroutine94_0
   1052          
   1053          /******************************************************************************
   1054           * @fn          ZDSecMgrCtrlReset
   1055           *
   1056           * @brief       Reset control data.
   1057           *
   1058           * @param       device - [in] valid device data
   1059           * @param       entry  - [in] valid entry data
   1060           *
   1061           * @return      ZStatus_t
   1062           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1063          ZStatus_t ZDSecMgrCtrlReset( ZDSecMgrDevice_t* device, ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrCtrlReset:
   1064          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V0,R2
   \   00000C   8B..         MOV       ?V1,R3
   \   00000E   EC           MOV       A,R4
   \   00000F   FE           MOV       R6,A
   \   000010   ED           MOV       A,R5
   \   000011   FF           MOV       R7,A
   1065            ZStatus_t       status;
   1066            ZDSecMgrCtrl_t* ctrl;
   1067          
   1068          
   1069            // initialize results
   1070            status = ZNwkUnknownDevice;
   1071          
   1072            // look for a match for the entry
   1073            ZDSecMgrCtrlLookup( entry, &ctrl );
   \   000012                ; Setup parameters for call to function ZDSecMgrCtrlLookup
   \   000012   AC..         MOV       R4,?XSP + 0
   \   000014   AD..         MOV       R5,?XSP + 1
   \   000016   EE           MOV       A,R6
   \   000017   FA           MOV       R2,A
   \   000018   EF           MOV       A,R7
   \   000019   12....       LCALL     ?Subroutine37 & 0xFFFF
   1074          
   1075            if ( ctrl != NULL )
   \                     ??CrossCallReturnLabel_163:
   \   00001C   601D         JZ        ??ZDSecMgrCtrlReset_0
   1076            {
   1077              ZDSecMgrCtrlSet( device, entry, ctrl );
   \   00001E                ; Setup parameters for call to function ZDSecMgrCtrlSet
   \   00001E   85..82       MOV       DPL,?XSP + 0
   \   000021   85..83       MOV       DPH,?XSP + 1
   \   000024   12....       LCALL     ?PUSH_XSTACK8_X_TWO
   \   000027   EE           MOV       A,R6
   \   000028   FC           MOV       R4,A
   \   000029   EF           MOV       A,R7
   \   00002A   FD           MOV       R5,A
   \   00002B   AA..         MOV       R2,?V0
   \   00002D   AB..         MOV       R3,?V1
   \   00002F   12....       LCALL     `??ZDSecMgrCtrlSet::?relay`; Banked call to: ZDSecMgrCtrlSet
   \   000032   7402         MOV       A,#0x2
   \   000034   12....       LCALL     ?DEALLOC_XSTACK8
   1078          
   1079              status = ZSuccess;
   \   000037   7900         MOV       R1,#0x0
   \   000039   800D         SJMP      ??ZDSecMgrCtrlReset_1
   1080            }
   1081            else
   1082            {
   1083              status = ZDSecMgrCtrlAdd( device, entry );
   \                     ??ZDSecMgrCtrlReset_0:
   \   00003B                ; Setup parameters for call to function ZDSecMgrCtrlAdd
   \   00003B   EE           MOV       A,R6
   \   00003C   FC           MOV       R4,A
   \   00003D   EF           MOV       A,R7
   \   00003E   FD           MOV       R5,A
   \   00003F   AA..         MOV       R2,?V0
   \   000041   AB..         MOV       R3,?V1
   \   000043   12....       LCALL     `??ZDSecMgrCtrlAdd::?relay`; Banked call to: ZDSecMgrCtrlAdd
   \   000046   E9           MOV       A,R1
   \   000047   F9           MOV       R1,A
   1084            }
   1085          
   1086            return status;
   \                     ??ZDSecMgrCtrlReset_1:
   \   000048   02....       LJMP      ??Subroutine100_0 & 0xFFFF
   1087          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine37:
   \   000000   FB           MOV       R3,A
   \   000001                REQUIRE ??Subroutine92_0
   \   000001                ; // Fall through to label ??Subroutine92_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine100_0:
   \   000000   7402         MOV       A,#0x2
   \   000002                REQUIRE ??Subroutine101_0
   \   000002                ; // Fall through to label ??Subroutine101_0
   1088          
   1089          /******************************************************************************
   1090           * @fn          ZDSecMgrMasterKeyLoad
   1091           *
   1092           * @brief       Load the MASTER key for device with specified EXT
   1093           *              address.
   1094           *
   1095           * @param       extAddr - [in] EXT address of device
   1096           * @param       key     - [in] MASTER key shared with device
   1097           *
   1098           * @return      ZStatus_t
   1099           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1100          ZStatus_t ZDSecMgrMasterKeyLoad( uint8* extAddr, uint8* key )
   \                     ZDSecMgrMasterKeyLoad:
   1101          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV       A,#-0xf
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV       A,#-0x4
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EC           MOV       A,R4
   \   00000B   FE           MOV       R6,A
   \   00000C   ED           MOV       A,R5
   \   00000D   FF           MOV       R7,A
   1102            ZStatus_t status;
   1103            uint8*    loaded;
   1104            uint16    ami;
   1105          
   1106          
   1107            // set status based on policy
   1108            status = ZDSecMgrExtAddrLookup( extAddr, &ami );
   \   00000E                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00000E   AC..         MOV       R4,?XSP + 0
   \   000010   AD..         MOV       R5,?XSP + 1
   \   000012   12....       LCALL     `??ZDSecMgrExtAddrLookup::?relay`; Banked call to: ZDSecMgrExtAddrLookup
   \   000015   E9           MOV       A,R1
   \   000016   F5..         MOV       ?V0,A
   1109          
   1110            if ( status == ZSuccess )
   \   000018   7036         JNZ       ??ZDSecMgrMasterKeyLoad_0
   1111            {
   1112              // get the address index
   1113              if ( ZDSecMgrMasterKeyLookup( ami, &loaded ) == ZSuccess )
   \   00001A                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   00001A   7402         MOV       A,#0x2
   \   00001C   12....       LCALL     ?XSTACK_DISP102_8
   \   00001F   12....       LCALL     ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_45:
   \   000022   7022         JNZ       ??ZDSecMgrMasterKeyLoad_1
   1114              {
   1115                // overwrite old key
   1116                osal_memcpy( loaded, key, SEC_KEY_LEN );
   \   000024                ; Setup parameters for call to function osal_memcpy
   \   000024   8E..         MOV       ?V4,R6
   \   000026   8F..         MOV       ?V5,R7
   \   000028   75..00       MOV       ?V6,#0x0
   \   00002B   78..         MOV       R0,#?V4
   \   00002D   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   000030   7C10         MOV       R4,#0x10
   \   000032   7D00         MOV       R5,#0x0
   \   000034   7405         MOV       A,#0x5
   \   000036   12....       LCALL     ?XSTACK_DISP0_8
   \   000039   12....       LCALL     ??Subroutine85_0 & 0xFFFF
   1117              }
   \                     ??CrossCallReturnLabel_125:
   \   00003C   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   00003F   7403         MOV       A,#0x3
   \   000041   12....       LCALL     ?DEALLOC_XSTACK8
   \   000044   800A         SJMP      ??ZDSecMgrMasterKeyLoad_0
   1118              else
   1119              {
   1120                // store new key -- NULL will zero key
   1121                status = ZDSecMgrMasterKeyStore( ami, key );
   \                     ??ZDSecMgrMasterKeyLoad_1:
   \   000046                ; Setup parameters for call to function ZDSecMgrMasterKeyStore
   \   000046   EE           MOV       A,R6
   \   000047   FC           MOV       R4,A
   \   000048   EF           MOV       A,R7
   \   000049   FD           MOV       R5,A
   \   00004A   12....       LCALL     ?Subroutine53 & 0xFFFF
   1122              }
   1123            }
   \                     ??CrossCallReturnLabel_65:
   \   00004D   E9           MOV       A,R1
   \   00004E   F5..         MOV       ?V0,A
   1124          
   1125            return status;
   \                     ??ZDSecMgrMasterKeyLoad_0:
   \   000050   A9..         MOV       R1,?V0
   \   000052   7404         MOV       A,#0x4
   \   000054                REQUIRE ?Subroutine5
   \   000054                ; // Fall through to label ?Subroutine5
   1126          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   12....       LCALL     ?DEALLOC_XSTACK8
   \   000003   7F07         MOV       R7,#0x7
   \   000005   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine42:
   \   000000   12....       LCALL     ?Subroutine68 & 0xFFFF
   \                     ??CrossCallReturnLabel_228:
   \   000003   12....       LCALL     `??ZDSecMgrMasterKeyLookup::?relay`; Banked call to: ZDSecMgrMasterKeyLookup
   \   000006   E9           MOV       A,R1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine85_0:
   \   000000   12....       LCALL     ??Subroutine105_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_230:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine53:
   \   000000   12....       LCALL     ?Subroutine68 & 0xFFFF
   \                     ??CrossCallReturnLabel_229:
   \   000003   12....       LCALL     `??ZDSecMgrMasterKeyStore::?relay`; Banked call to: ZDSecMgrMasterKeyStore
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine68:
   \   000000   85..82       MOV       DPL,?XSP + 0
   \   000003   85..83       MOV       DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine105_0
   \   000006                ; // Fall through to label ??Subroutine105_0
   1127          
   1128          /******************************************************************************
   1129           * @fn          ZDSecMgrAppKeyGet
   1130           *
   1131           * @brief       get an APP key - option APP(MASTER or LINK) key
   1132           *
   1133           * @param       initNwkAddr - [in] NWK address of initiator device
   1134           * @param       initExtAddr - [in] EXT address of initiator device
   1135           * @param       partNwkAddr - [in] NWK address of partner device
   1136           * @param       partExtAddr - [in] EXT address of partner device
   1137           * @param       key         - [out] APP(MASTER or LINK) key
   1138           * @param       keyType     - [out] APP(MASTER or LINK) key type
   1139           *
   1140           * @return      ZStatus_t
   1141           */

   \                                 In  segment XDATA_I, align 1, keep-with-next
   1142          uint8 ZDSecMgrAppKeyType = KEY_TYPE_APP_LINK;    // Set the default key type
   \                     ZDSecMgrAppKeyType:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for ZDSecMgrAppKeyType>`
   \   000001                REQUIRE __INIT_XDATA_I
   1143                                                           // to KEY_TYPE_APP_LINK since
   1144                                                           // only specific requirement
   1145                                                           // right now comes from SE profile
   1146          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1147          ZStatus_t ZDSecMgrAppKeyGet( uint16  initNwkAddr,
   \                     ZDSecMgrAppKeyGet:
   1148                                       uint8*  initExtAddr,
   1149                                       uint16  partNwkAddr,
   1150                                       uint8*  partExtAddr,
   1151                                       uint8** key,
   1152                                       uint8*  keyType )
   1153          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1154            // Intentionally unreferenced parameters
   1155            (void)initNwkAddr;
   1156            (void)initExtAddr;
   1157            (void)partNwkAddr;
   1158            (void)partExtAddr;
   1159            
   1160            //---------------------------------------------------------------------------
   1161            // note:
   1162            // should use a robust mechanism to generate keys, for example
   1163            // combine EXT addresses and call a hash function
   1164            //---------------------------------------------------------------------------
   1165            SSP_GetTrueRand( SEC_KEY_LEN, *key );
   \   000004                ; Setup parameters for call to function SSP_GetTrueRand
   \   000004   7404         MOV       A,#0x4
   \   000006   12....       LCALL     ?XSTACK_DISP0_8
   \   000009   12....       LCALL     ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_52:
   \   00000C   7910         MOV       R1,#0x10
   \   00000E   12....       LCALL     `??SSP_GetTrueRand::?relay`; Banked call to: SSP_GetTrueRand
   1166          
   1167            *keyType = ZDSecMgrAppKeyType;
   \   000011   90....       MOV       DPTR,#ZDSecMgrAppKeyType
   \   000014   E0           MOVX      A,@DPTR
   \   000015   C0E0         PUSH      A
   \   000017   7406         MOV       A,#0x6
   \   000019   12....       LCALL     ?XSTACK_DISP0_8
   \   00001C   12....       LCALL     ??Subroutine81_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_115:
   \   00001F   D0E0         POP       A
   \   000021                REQUIRE ?Subroutine7
   \   000021                ; // Fall through to label ?Subroutine7
   1168          
   1169            return ZSuccess;
   1170          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   7900         MOV       R1,#0x0
   \   000003   02....       LJMP      ??Subroutine86_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine81_0:
   \   000000   12....       LCALL     ?Subroutine67 & 0xFFFF
   \                     ??CrossCallReturnLabel_123:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine67:
   \   000000   12....       LCALL     ??Subroutine104_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_224:
   \   000003   F583         MOV       DPH,A
   \   000005   8882         MOV       DPL,R0
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine45:
   \   000000   12....       LCALL     ?Subroutine67 & 0xFFFF
   \                     ??CrossCallReturnLabel_122:
   \   000003   12....       LCALL     ??Subroutine105_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_225:
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine104_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F8           MOV       R0,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   22           RET
   1171          
   1172          /******************************************************************************
   1173           * @fn          ZDSecMgrAppKeyReq
   1174           *
   1175           * @brief       Process request for APP key between two devices.
   1176           *
   1177           * @param       device - [in] ZDO_RequestKeyInd_t, request info
   1178           *
   1179           * @return      none
   1180           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1181          void ZDSecMgrAppKeyReq( ZDO_RequestKeyInd_t* ind )
   \                     ZDSecMgrAppKeyReq:
   1182          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 39
   \   000005   74D9         MOV       A,#-0x27
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   1183            APSME_TransportKeyReq_t req;
   1184            uint8                   initExtAddr[Z_EXTADDR_LEN];
   1185            uint16                  partNwkAddr;
   1186            uint8                   key[SEC_KEY_LEN];
   1187          
   1188          
   1189            // validate initiator and partner
   1190            if ( ( APSME_LookupNwkAddr( ind->partExtAddr, &partNwkAddr ) == TRUE ) &&
   1191                 ( APSME_LookupExtAddr( ind->srcAddr, initExtAddr ) == TRUE      )   )
   \   00000E   EA           MOV       A,R2
   \   00000F   12....       LCALL     ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_80:
   \   000012                ; Setup parameters for call to function APSME_LookupNwkAddr
   \   000012   AC..         MOV       R4,?XSP + 0
   \   000014   AD..         MOV       R5,?XSP + 1
   \   000016   AA..         MOV       R2,?V0
   \   000018   FB           MOV       R3,A
   \   000019   12....       LCALL     `??APSME_LookupNwkAddr::?relay`; Banked call to: APSME_LookupNwkAddr
   \   00001C   E9           MOV       A,R1
   \   00001D   6401         XRL       A,#0x1
   \   00001F   6003         JZ        $+5
   \   000021   02....       LJMP      ??ZDSecMgrAppKeyReq_0 & 0xFFFF
   \   000024   EE           MOV       A,R6
   \   000025   2402         ADD       A,#0x2
   \   000027   FE           MOV       R6,A
   \   000028   5001         JNC       ??ZDSecMgrAppKeyReq_1
   \   00002A   0F           INC       R7
   \                     ??ZDSecMgrAppKeyReq_1:
   \   00002B                ; Setup parameters for call to function APSME_LookupExtAddr
   \   00002B   740F         MOV       A,#0xf
   \   00002D   12....       LCALL     ?XSTACK_DISP102_8
   \   000030   12....       LCALL     ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_135:
   \   000033   12....       LCALL     `??APSME_LookupExtAddr::?relay`; Banked call to: APSME_LookupExtAddr
   \   000036   E9           MOV       A,R1
   \   000037   6401         XRL       A,#0x1
   \   000039   6003         JZ        $+5
   \   00003B   02....       LJMP      ??ZDSecMgrAppKeyReq_0 & 0xFFFF
   1192            {
   1193              // point the key to some memory
   1194              req.key = key;
   \   00003E   7417         MOV       A,#0x17
   \   000040   12....       LCALL     ?XSTACK_DISP100_8
   \   000043   7406         MOV       A,#0x6
   \   000045   12....       LCALL     ?XSTACK_DISP0_8
   \   000048   12....       LCALL     ??Subroutine91_0 & 0xFFFF
   1195          
   1196              // get an APP key - option APP (MASTER or LINK) key
   1197              if ( ZDSecMgrAppKeyGet( ind->srcAddr,
   1198                                      initExtAddr,
   1199                                      partNwkAddr,
   1200                                      ind->partExtAddr,
   1201                                      &req.key,
   1202                                      &req.keyType ) == ZSuccess )
   \                     ??CrossCallReturnLabel_150:
   \   00004B                ; Setup parameters for call to function ZDSecMgrAppKeyGet
   \   00004B   7404         MOV       A,#0x4
   \   00004D   12....       LCALL     ?XSTACK_DISP0_8
   \   000050   8582..       MOV       ?V2,DPL
   \   000053   8583..       MOV       ?V3,DPH
   \   000056   78..         MOV       R0,#?V2
   \   000058   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00005B   7408         MOV       A,#0x8
   \   00005D   12....       LCALL     ?XSTACK_DISP0_8
   \   000060   8582..       MOV       ?V2,DPL
   \   000063   8583..       MOV       ?V3,DPH
   \   000066   78..         MOV       R0,#?V2
   \   000068   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00006B   78..         MOV       R0,#?V0
   \   00006D   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000070   7406         MOV       A,#0x6
   \   000072   12....       LCALL     ?XSTACK_DISP0_8
   \   000075   12....       LCALL     ?PUSH_XSTACK8_X_TWO
   \   000078   7417         MOV       A,#0x17
   \   00007A   12....       LCALL     ?XSTACK_DISP102_8
   \   00007D   12....       LCALL     ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_136:
   \   000080   12....       LCALL     `??ZDSecMgrAppKeyGet::?relay`; Banked call to: ZDSecMgrAppKeyGet
   \   000083   7408         MOV       A,#0x8
   \   000085   12....       LCALL     ?DEALLOC_XSTACK8
   \   000088   E9           MOV       A,R1
   \   000089   7068         JNZ       ??ZDSecMgrAppKeyReq_0
   1203              {
   1204                // always secure
   1205                req.nwkSecure = TRUE;
   \   00008B   740C         MOV       A,#0xc
   \   00008D   12....       LCALL     ?XSTACK_DISP0_8
   \   000090   7401         MOV       A,#0x1
   \   000092   F0           MOVX      @DPTR,A
   1206                req.apsSecure = TRUE;
   \   000093   740B         MOV       A,#0xb
   \   000095   12....       LCALL     ?XSTACK_DISP0_8
   \   000098   7401         MOV       A,#0x1
   \   00009A   F0           MOVX      @DPTR,A
   1207                req.tunnel    = NULL;
   \   00009B   740D         MOV       A,#0xd
   \   00009D   12....       LCALL     ?XSTACK_DISP0_8
   \   0000A0   E4           CLR       A
   \   0000A1   F0           MOVX      @DPTR,A
   \   0000A2   A3           INC       DPTR
   \   0000A3   12....       LCALL     ?Subroutine36 & 0xFFFF
   1208          
   1209                // send key to initiator device
   1210                req.dstAddr   = ind->srcAddr;
   \                     ??CrossCallReturnLabel_37:
   \   0000A6   F9           MOV       R1,A
   \   0000A7   7402         MOV       A,#0x2
   \   0000A9   12....       LCALL     ?XSTACK_DISP0_8
   \   0000AC   12....       LCALL     ??Subroutine91_0 & 0xFFFF
   1211                req.extAddr   = ind->partExtAddr;
   \                     ??CrossCallReturnLabel_151:
   \   0000AF   7408         MOV       A,#0x8
   \   0000B1   12....       LCALL     ?XSTACK_DISP0_8
   \   0000B4   E5..         MOV       A,?V0
   \   0000B6   F0           MOVX      @DPTR,A
   \   0000B7   A3           INC       DPTR
   \   0000B8   E5..         MOV       A,?V1
   \   0000BA   F0           MOVX      @DPTR,A
   1212                req.initiator = TRUE;
   \   0000BB   740A         MOV       A,#0xa
   \   0000BD   12....       LCALL     ?XSTACK_DISP0_8
   \   0000C0   7401         MOV       A,#0x1
   \   0000C2   F0           MOVX      @DPTR,A
   1213                APSME_TransportKeyReq( &req );
   \   0000C3                ; Setup parameters for call to function APSME_TransportKeyReq
   \   0000C3   04           INC       A
   \   0000C4   12....       LCALL     ?XSTACK_DISP101_8
   \   0000C7   12....       LCALL     `??APSME_TransportKeyReq::?relay`; Banked call to: APSME_TransportKeyReq
   1214          
   1215                // send key to partner device
   1216                req.dstAddr   = partNwkAddr;
   \   0000CA   85..82       MOV       DPL,?XSP + 0
   \   0000CD   85..83       MOV       DPH,?XSP + 1
   \   0000D0   12....       LCALL     ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_56:
   \   0000D3   12....       LCALL     ?XSTACK_DISP0_8
   \   0000D6   12....       LCALL     ??Subroutine91_0 & 0xFFFF
   1217                req.extAddr   = initExtAddr;
   \                     ??CrossCallReturnLabel_152:
   \   0000D9   740F         MOV       A,#0xf
   \   0000DB   12....       LCALL     ?XSTACK_DISP100_8
   \   0000DE   7408         MOV       A,#0x8
   \   0000E0   12....       LCALL     ?XSTACK_DISP0_8
   \   0000E3   12....       LCALL     ??Subroutine95_0 & 0xFFFF
   1218                req.initiator = FALSE;
   \                     ??CrossCallReturnLabel_179:
   \   0000E6   12....       LCALL     ?XSTACK_DISP0_8
   \   0000E9   E4           CLR       A
   \   0000EA   F0           MOVX      @DPTR,A
   1219          
   1220                APSME_TransportKeyReq( &req );
   \   0000EB                ; Setup parameters for call to function APSME_TransportKeyReq
   \   0000EB   7402         MOV       A,#0x2
   \   0000ED   12....       LCALL     ?XSTACK_DISP101_8
   \   0000F0   12....       LCALL     `??APSME_TransportKeyReq::?relay`; Banked call to: APSME_TransportKeyReq
   1221              }
   1222            }
   1223          }
   \                     ??ZDSecMgrAppKeyReq_0:
   \   0000F3   7427         MOV       A,#0x27
   \   0000F5   02....       LJMP      ??Subroutine82_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine48:
   \   000000   12....       LCALL     ?Subroutine71 & 0xFFFF
   \                     ??CrossCallReturnLabel_207:
   \   000003   7402         MOV       A,#0x2
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine82_0:
   \   000000   12....       LCALL     ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine83_0
   \   000003                ; // Fall through to label ??Subroutine83_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine36:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   8E82         MOV       DPL,R6
   \   000003   8F83         MOV       DPH,R7
   \   000005   12....       LCALL     ??Subroutine104_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_220:
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine55:
   \   000000   8E82         MOV       DPL,R6
   \   000002   8F83         MOV       DPH,R7
   \   000004                REQUIRE ??Subroutine85_0
   \   000004                ; // Fall through to label ??Subroutine85_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine95_0:
   \   000000   12....       LCALL     ??Subroutine97_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_191:
   \   000003                ; Setup parameters for call to function AddrMgrEntryGet
   \   000003                ; Setup parameters for call to function AddrMgrEntryGet
   \   000003   740A         MOV       A,#0xa
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine58:
   \   000000   2405         ADD       A,#0x5
   \   000002   F5..         MOV       ?V0,A
   \   000004   E4           CLR       A
   \   000005   3F           ADDC      A,R7
   \   000006   F5..         MOV       ?V1,A
   \   000008   22           RET
   1224          
   1225          /******************************************************************************
   1226           * @fn          ZDSecMgrEstablishKey
   1227           *
   1228           * @brief       Start SKKE with device joining network.
   1229           *
   1230           * @param       device - [in] ZDSecMgrDevice_t, device info
   1231           *
   1232           * @return      ZStatus_t
   1233           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1234          ZStatus_t ZDSecMgrEstablishKey( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrEstablishKey:
   1235          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 7
   \   000005   74F9         MOV       A,#-0x7
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   1236            ZStatus_t               status;
   1237            APSME_EstablishKeyReq_t req;
   1238          
   1239          
   1240            req.respExtAddr = device->extAddr;
   \   00000E   8A82         MOV       DPL,R2
   \   000010   F583         MOV       DPH,A
   \   000012   A3           INC       DPTR
   \   000013   A3           INC       DPTR
   \   000014   12....       LCALL     ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_57:
   \   000017   12....       LCALL     ?XSTACK_DISP0_8
   \   00001A   12....       LCALL     ??Subroutine91_0 & 0xFFFF
   1241            req.method      = APSME_SKKE_METHOD;
   \                     ??CrossCallReturnLabel_153:
   \   00001D   7404         MOV       A,#0x4
   \   00001F   12....       LCALL     ?XSTACK_DISP0_8
   \   000022   E4           CLR       A
   \   000023   F0           MOVX      @DPTR,A
   1242          
   1243            if ( device->parentAddr == NLME_GetShortAddr() )
   \   000024                ; Setup parameters for call to function NLME_GetShortAddr
   \   000024   12....       LCALL     ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_193:
   \   000027   EA           MOV       A,R2
   \   000028   68           XRL       A,R0
   \   000029   7002         JNZ       ??ZDSecMgrEstablishKey_0
   \   00002B   EB           MOV       A,R3
   \   00002C   69           XRL       A,R1
   \                     ??ZDSecMgrEstablishKey_0:
   \   00002D   7017         JNZ       ??ZDSecMgrEstablishKey_1
   1244            {
   1245              req.dstAddr   = device->nwkAddr;
   \   00002F   8E82         MOV       DPL,R6
   \   000031   8F83         MOV       DPH,R7
   \   000033   12....       LCALL     ??Subroutine99_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_196:
   \   000036   12....       LCALL     ?Subroutine29 & 0xFFFF
   1246              //devtag.0604.todo - remove obsolete
   1247              req.apsSecure = FALSE;
   \                     ??CrossCallReturnLabel_112:
   \   000039   12....       LCALL     ?XSTACK_DISP0_8
   \   00003C   E4           CLR       A
   \   00003D   F0           MOVX      @DPTR,A
   1248              req.nwkSecure = FALSE;
   \   00003E   7406         MOV       A,#0x6
   \   000040   12....       LCALL     ?XSTACK_DISP0_8
   \   000043   E4           CLR       A
   \   000044   8010         SJMP      ??ZDSecMgrEstablishKey_2
   1249            }
   1250            else
   1251            {
   1252              req.dstAddr   = device->parentAddr;
   \                     ??ZDSecMgrEstablishKey_1:
   \   000046   12....       LCALL     ?Subroutine29 & 0xFFFF
   1253              //devtag.0604.todo - remove obsolete
   1254              req.apsSecure = TRUE;
   \                     ??CrossCallReturnLabel_113:
   \   000049   12....       LCALL     ?XSTACK_DISP0_8
   \   00004C   7401         MOV       A,#0x1
   \   00004E   F0           MOVX      @DPTR,A
   1255              req.nwkSecure = TRUE;
   \   00004F   7406         MOV       A,#0x6
   \   000051   12....       LCALL     ?XSTACK_DISP0_8
   \   000054   7401         MOV       A,#0x1
   1256            }
   \                     ??ZDSecMgrEstablishKey_2:
   \   000056   12....       LCALL     ??Subroutine90_0 & 0xFFFF
   1257          
   1258            status = APSME_EstablishKeyReq( &req );
   1259          
   1260            return status;
   \                     ??CrossCallReturnLabel_140:
   \   000059   12....       LCALL     `??APSME_EstablishKeyReq::?relay`; Banked call to: APSME_EstablishKeyReq
   \   00005C   7407         MOV       A,#0x7
   \   00005E   02....       LJMP      ??Subroutine101_0 & 0xFFFF
   1261          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine29:
   \   000000   85..82       MOV       DPL,?XSP + 0
   \   000003   85..83       MOV       DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine80_0
   \   000006                ; // Fall through to label ??Subroutine80_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine80_0:
   \   000000   12....       LCALL     ??Subroutine97_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_189:
   \   000003                ; Setup parameters for call to function APSME_RemoveDeviceReq
   \   000003   7405         MOV       A,#0x5
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine50:
   \   000000   12....       LCALL     `??NLME_GetShortAddr::?relay`; Banked call to: NLME_GetShortAddr
   \   000003   8E82         MOV       DPL,R6
   \   000005   8F83         MOV       DPH,R7
   \   000007   A3           INC       DPTR
   \   000008   A3           INC       DPTR
   \   000009                REQUIRE ??Subroutine98_0
   \   000009                ; // Fall through to label ??Subroutine98_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine98_0:
   \   000000   A3           INC       DPTR
   \   000001   A3           INC       DPTR
   \   000002                REQUIRE ??Subroutine99_0
   \   000002                ; // Fall through to label ??Subroutine99_0
   1262          
   1263          /******************************************************************************
   1264           * @fn          ZDSecMgrSendMasterKey
   1265           *
   1266           * @brief       Send MASTER key to device joining network.
   1267           *
   1268           * @param       device - [in] ZDSecMgrDevice_t, device info
   1269           *
   1270           * @return      ZStatus_t
   1271           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1272          ZStatus_t ZDSecMgrSendMasterKey( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrSendMasterKey:
   1273          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV       A,#-0xd
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   1274            ZStatus_t               status;
   1275            APSME_TransportKeyReq_t req;
   1276          
   1277          
   1278            req.keyType = KEY_TYPE_TC_MASTER;
   \   00000E   7402         MOV       A,#0x2
   \   000010   12....       LCALL     ?XSTACK_DISP0_8
   \   000013   E4           CLR       A
   \   000014   12....       LCALL     ?Subroutine19 & 0xFFFF
   1279            req.extAddr = device->extAddr;
   \                     ??CrossCallReturnLabel_6:
   \   000017   12....       LCALL     ?XSTACK_DISP0_8
   \   00001A   12....       LCALL     ??Subroutine91_0 & 0xFFFF
   1280            req.tunnel  = NULL;
   \                     ??CrossCallReturnLabel_154:
   \   00001D   740B         MOV       A,#0xb
   \   00001F   12....       LCALL     ?XSTACK_DISP0_8
   \   000022   E4           CLR       A
   \   000023   F0           MOVX      @DPTR,A
   \   000024   A3           INC       DPTR
   \   000025   F0           MOVX      @DPTR,A
   1281          
   1282            ZDSecMgrMasterKeyLookup( device->ctrl->entry->ami, &req.key );
   \   000026                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   000026   7404         MOV       A,#0x4
   \   000028   12....       LCALL     ?XSTACK_DISP0_8
   \   00002B   AC82         MOV       R4,DPL
   \   00002D   AD83         MOV       R5,DPH
   \   00002F   8A82         MOV       DPL,R2
   \   000031   8B83         MOV       DPH,R3
   \   000033   A3           INC       DPTR
   \   000034   A3           INC       DPTR
   \   000035   A3           INC       DPTR
   \   000036   A3           INC       DPTR
   \   000037   A3           INC       DPTR
   \   000038   A3           INC       DPTR
   \   000039   A3           INC       DPTR
   \   00003A   A3           INC       DPTR
   \   00003B   12....       LCALL     ??Subroutine81_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_116:
   \   00003E   12....       LCALL     ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_53:
   \   000041   12....       LCALL     `??ZDSecMgrMasterKeyLookup::?relay`; Banked call to: ZDSecMgrMasterKeyLookup
   1283          
   1284            //check if using secure hop to to parent
   1285            if ( device->parentAddr != NLME_GetShortAddr() )
   \   000044                ; Setup parameters for call to function NLME_GetShortAddr
   \   000044   12....       LCALL     ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_194:
   \   000047   EA           MOV       A,R2
   \   000048   68           XRL       A,R0
   \   000049   7002         JNZ       ??ZDSecMgrSendMasterKey_0
   \   00004B   EB           MOV       A,R3
   \   00004C   69           XRL       A,R1
   \                     ??ZDSecMgrSendMasterKey_0:
   \   00004D   6012         JZ        ??ZDSecMgrSendMasterKey_1
   1286            {
   1287              //send to parent with security
   1288              req.dstAddr   = device->parentAddr;
   \   00004F   12....       LCALL     ?Subroutine16 & 0xFFFF
   1289              req.nwkSecure = TRUE;
   \                     ??CrossCallReturnLabel_177:
   \   000052   12....       LCALL     ?XSTACK_DISP0_8
   \   000055   7401         MOV       A,#0x1
   \   000057   F0           MOVX      @DPTR,A
   1290              req.apsSecure = TRUE;
   \   000058   7409         MOV       A,#0x9
   \   00005A   12....       LCALL     ?XSTACK_DISP0_8
   \   00005D   7401         MOV       A,#0x1
   \   00005F   8015         SJMP      ??ZDSecMgrSendMasterKey_2
   1291            }
   1292            else
   1293            {
   1294              //direct with no security
   1295              req.dstAddr   = device->nwkAddr;
   \                     ??ZDSecMgrSendMasterKey_1:
   \   000061   8E82         MOV       DPL,R6
   \   000063   8F83         MOV       DPH,R7
   \   000065   12....       LCALL     ??Subroutine99_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_197:
   \   000068   12....       LCALL     ?Subroutine16 & 0xFFFF
   1296              req.nwkSecure = FALSE;
   \                     ??CrossCallReturnLabel_178:
   \   00006B   12....       LCALL     ?XSTACK_DISP0_8
   \   00006E   E4           CLR       A
   \   00006F   F0           MOVX      @DPTR,A
   1297              req.apsSecure = FALSE;
   \   000070   7409         MOV       A,#0x9
   \   000072   12....       LCALL     ?XSTACK_DISP0_8
   \   000075   E4           CLR       A
   1298            }
   \                     ??ZDSecMgrSendMasterKey_2:
   \   000076   12....       LCALL     ?Subroutine32 & 0xFFFF
   1299          
   1300            status = APSME_TransportKeyReq( &req );
   1301          
   1302            return status;
   \                     ??CrossCallReturnLabel_25:
   \   000079   02....       LJMP      ??Subroutine76_0 & 0xFFFF
   1303          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   12....       LCALL     ?Subroutine62 & 0xFFFF
   \                     ??CrossCallReturnLabel_88:
   \   000003   7406         MOV       A,#0x6
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   85..82       MOV       DPL,?XSP + 0
   \   000003   85..83       MOV       DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine95_0
   \   000006                ; // Fall through to label ??Subroutine95_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine62:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   8A82         MOV       DPL,R2
   \   000003   8B83         MOV       DPH,R3
   \   000005   A3           INC       DPTR
   \   000006   A3           INC       DPTR
   \   000007   12....       LCALL     ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_211:
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine32:
   \   000000   F0           MOVX      @DPTR,A
   \   000001                ; Setup parameters for call to function APSME_TransportKeyReq
   \   000001                ; Setup parameters for call to function APSME_TransportKeyReq
   \   000001   AA..         MOV       R2,?XSP + 0
   \   000003   AB..         MOV       R3,?XSP + 1
   \   000005   12....       LCALL     `??APSME_TransportKeyReq::?relay`; Banked call to: APSME_TransportKeyReq
   \   000008   22           RET
   1304          
   1305          /******************************************************************************
   1306           * @fn          ZDSecMgrSendNwkKey
   1307           *
   1308           * @brief       Send NWK key to device joining network.
   1309           *
   1310           * @param       device - [in] ZDSecMgrDevice_t, device info
   1311           *
   1312           * @return      ZStatus_t
   1313           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1314          ZStatus_t ZDSecMgrSendNwkKey( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrSendNwkKey:
   1315          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV       A,#-0xd
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   1316            ZStatus_t               status;
   1317            APSME_TransportKeyReq_t req;
   1318            APSDE_FrameTunnel_t     tunnel;
   1319          
   1320            req.dstAddr   = device->nwkAddr;
   \   00000E   8A82         MOV       DPL,R2
   \   000010   F583         MOV       DPH,A
   \   000012   12....       LCALL     ?Subroutine49 & 0xFFFF
   \                     ??CrossCallReturnLabel_59:
   \   000015   E8           MOV       A,R0
   \   000016   F0           MOVX      @DPTR,A
   \   000017   A3           INC       DPTR
   \   000018   E9           MOV       A,R1
   \   000019   12....       LCALL     ?Subroutine19 & 0xFFFF
   1321            req.extAddr   = device->extAddr;
   \                     ??CrossCallReturnLabel_7:
   \   00001C   12....       LCALL     ?XSTACK_DISP0_8
   \   00001F   12....       LCALL     ??Subroutine96_0 & 0xFFFF
   1322          
   1323            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   1324              req.keyType   = KEY_TYPE_NWK_HIGH;
   1325            else
   1326              req.keyType   = KEY_TYPE_NWK;
   \                     ??CrossCallReturnLabel_185:
   \   000022   12....       LCALL     ?XSTACK_DISP0_8
   \   000025   7401         MOV       A,#0x1
   \   000027   F0           MOVX      @DPTR,A
   1327          
   1328            if ( (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH)
   1329                || (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD) )
   1330            {
   1331              // set values
   1332              req.keySeqNum = _NIB.nwkActiveKey.keySeqNum;
   1333              req.key       = _NIB.nwkActiveKey.key;
   1334              //devtag.pro.security.todo - make sure that if there is no link key the NWK
   1335              //key isn't used to secure the frame at the APS layer -- since the receiving
   1336              //device may not have a NWK key yet
   1337              req.apsSecure = TRUE;
   1338          
   1339              // check if using secure hop to to parent
   1340              if ( device->parentAddr == NLME_GetShortAddr() )
   1341              {
   1342                req.nwkSecure = FALSE;
   1343                req.tunnel    = NULL;
   1344              }
   1345              else
   1346              {
   1347                req.nwkSecure   = TRUE;
   1348                req.tunnel      = &tunnel;
   1349                req.tunnel->tna = device->parentAddr;
   1350                req.tunnel->dea = device->extAddr;
   1351              }
   1352            }
   1353            else
   1354            {
   1355              // default values
   1356              //devtag.0604.verify
   1357              req.nwkSecure = TRUE;
   \   000028   740A         MOV       A,#0xa
   \   00002A   12....       LCALL     ?XSTACK_DISP0_8
   \   00002D   7401         MOV       A,#0x1
   \   00002F   F0           MOVX      @DPTR,A
   1358              req.apsSecure = FALSE;
   \   000030   7409         MOV       A,#0x9
   \   000032   12....       LCALL     ?XSTACK_DISP0_8
   \   000035   E4           CLR       A
   \   000036   F0           MOVX      @DPTR,A
   1359              req.tunnel    = NULL;
   \   000037   740B         MOV       A,#0xb
   \   000039   12....       LCALL     ?XSTACK_DISP0_8
   \   00003C   E4           CLR       A
   \   00003D   F0           MOVX      @DPTR,A
   \   00003E   A3           INC       DPTR
   \   00003F   F0           MOVX      @DPTR,A
   1360          
   1361              if ( device->parentAddr != NLME_GetShortAddr() )
   \   000040                ; Setup parameters for call to function NLME_GetShortAddr
   \   000040   12....       LCALL     `??NLME_GetShortAddr::?relay`; Banked call to: NLME_GetShortAddr
   \   000043   8A..         MOV       ?V0,R2
   \   000045   8B..         MOV       ?V1,R3
   \   000047   A8..         MOV       R0,?V0
   \   000049   A9..         MOV       R1,?V1
   \   00004B   EE           MOV       A,R6
   \   00004C   12....       LCALL     ?Subroutine61 & 0xFFFF
   \                     ??CrossCallReturnLabel_86:
   \   00004F   85..82       MOV       DPL,?V0
   \   000052   F583         MOV       DPH,A
   \   000054   12....       LCALL     ??Subroutine85_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_126:
   \   000057   E8           MOV       A,R0
   \   000058   6A           XRL       A,R2
   \   000059   7002         JNZ       ??ZDSecMgrSendNwkKey_0
   \   00005B   E9           MOV       A,R1
   \   00005C   6B           XRL       A,R3
   \                     ??ZDSecMgrSendNwkKey_0:
   \   00005D   6009         JZ        ??CrossCallReturnLabel_32
   1362              {
   1363                req.dstAddr = device->parentAddr;
   \   00005F   85..82       MOV       DPL,?XSP + 0
   \   000062   85..83       MOV       DPH,?XSP + 1
   \   000065   12....       LCALL     ?Subroutine35 & 0xFFFF
   1364              }
   1365          
   1366              // special cases
   1367              //devtag.0604.todo - modify to preconfig flag
   1368              if ( device->secure == FALSE )
   \                     ??CrossCallReturnLabel_32:
   \   000068   8E82         MOV       DPL,R6
   \   00006A   8F83         MOV       DPH,R7
   \   00006C   A3           INC       DPTR
   \   00006D   A3           INC       DPTR
   \   00006E   A3           INC       DPTR
   \   00006F   A3           INC       DPTR
   \   000070   A3           INC       DPTR
   \   000071   A3           INC       DPTR
   \   000072   E0           MOVX      A,@DPTR
   \   000073   7038         JNZ       ??ZDSecMgrSendNwkKey_1
   1369              {
   1370                req.keySeqNum = _NIB.nwkActiveKey.keySeqNum;
   \   000075   90....       MOV       DPTR,#_NIB + 62
   \   000078   E0           MOVX      A,@DPTR
   \   000079   C0E0         PUSH      A
   \   00007B   7403         MOV       A,#0x3
   \   00007D   12....       LCALL     ?XSTACK_DISP0_8
   \   000080   D0E0         POP       A
   \   000082   F0           MOVX      @DPTR,A
   1371                req.key       = _NIB.nwkActiveKey.key;
   \   000083   7404         MOV       A,#0x4
   \   000085   12....       LCALL     ?XSTACK_DISP0_8
   \   000088   74..         MOV       A,#(_NIB + 63) & 0xff
   \   00008A   F0           MOVX      @DPTR,A
   \   00008B   A3           INC       DPTR
   \   00008C   74..         MOV       A,#((_NIB + 63) >> 8) & 0xff
   \   00008E   F0           MOVX      @DPTR,A
   1372          
   1373                // check if using secure hop to to parent
   1374                if ( device->parentAddr == NLME_GetShortAddr() )
   \   00008F                ; Setup parameters for call to function NLME_GetShortAddr
   \   00008F   12....       LCALL     `??NLME_GetShortAddr::?relay`; Banked call to: NLME_GetShortAddr
   \   000092   8A..         MOV       ?V2,R2
   \   000094   8B..         MOV       ?V3,R3
   \   000096   A8..         MOV       R0,?V2
   \   000098   A9..         MOV       R1,?V3
   \   00009A   85..82       MOV       DPL,?V0
   \   00009D   85..83       MOV       DPH,?V1
   \   0000A0   E0           MOVX      A,@DPTR
   \   0000A1   68           XRL       A,R0
   \   0000A2   7003         JNZ       ??ZDSecMgrSendNwkKey_2
   \   0000A4   A3           INC       DPTR
   \   0000A5   E0           MOVX      A,@DPTR
   \   0000A6   69           XRL       A,R1
   \                     ??ZDSecMgrSendNwkKey_2:
   \   0000A7   7014         JNZ       ??ZDSecMgrSendNwkKey_3
   1375                {
   1376                  req.nwkSecure = FALSE;
   \   0000A9   740A         MOV       A,#0xa
   \   0000AB   800B         SJMP      ??ZDSecMgrSendNwkKey_4
   1377                }
   1378              }
   1379              else
   1380              {
   1381                req.key       = NULL;
   \                     ??ZDSecMgrSendNwkKey_1:
   \   0000AD   7404         MOV       A,#0x4
   \   0000AF   12....       LCALL     ?XSTACK_DISP0_8
   \   0000B2   E4           CLR       A
   \   0000B3   F0           MOVX      @DPTR,A
   \   0000B4   A3           INC       DPTR
   \   0000B5   F0           MOVX      @DPTR,A
   1382                req.keySeqNum = 0;
   \   0000B6   7403         MOV       A,#0x3
   \                     ??ZDSecMgrSendNwkKey_4:
   \   0000B8   12....       LCALL     ?XSTACK_DISP0_8
   \   0000BB   E4           CLR       A
   \   0000BC   F0           MOVX      @DPTR,A
   1383              }
   1384            }
   1385          
   1386            status = APSME_TransportKeyReq( &req );
   1387          
   1388            return status;
   \                     ??ZDSecMgrSendNwkKey_3:
   \   0000BD                ; Setup parameters for call to function APSME_TransportKeyReq
   \   0000BD   AA..         MOV       R2,?XSP + 0
   \   0000BF   AB..         MOV       R3,?XSP + 1
   \   0000C1   12....       LCALL     `??APSME_TransportKeyReq::?relay`; Banked call to: APSME_TransportKeyReq
   \   0000C4   740D         MOV       A,#0xd
   \   0000C6   80..         SJMP      ??Subroutine82_0
   1389          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine96_0:
   \   000000   12....       LCALL     ??Subroutine97_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_192:
   \   000003   7402         MOV       A,#0x2
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine61:
   \   000000   2404         ADD       A,#0x4
   \   000002   F5..         MOV       ?V0,A
   \   000004   E4           CLR       A
   \   000005   3F           ADDC      A,R7
   \   000006   F5..         MOV       ?V1,A
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine49:
   \   000000   12....       LCALL     ?Subroutine70 & 0xFFFF
   \                     ??CrossCallReturnLabel_100:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine70:
   \   000000   12....       LCALL     ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_213:
   \   000003   85..82       MOV       DPL,?XSP + 0
   \   000006   85..83       MOV       DPH,?XSP + 1
   \   000009   22           RET
   1390          
   1391          /******************************************************************************
   1392           * @fn          ZDSecMgrDeviceEntryRemove
   1393           *
   1394           * @brief       Remove device entry.
   1395           *
   1396           * @param       entry - [in] valid entry
   1397           *
   1398           * @return      none
   1399           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1400          void ZDSecMgrDeviceEntryRemove( ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrDeviceEntryRemove:
   1401          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
   1402            // terminate device control
   1403            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1404            {
   1405              ZDSecMgrCtrlTerm( entry );
   \   000009                ; Setup parameters for call to function ZDSecMgrCtrlTerm
   \   000009   12....       LCALL     `??ZDSecMgrCtrlTerm::?relay`; Banked call to: ZDSecMgrCtrlTerm
   1406            }
   1407          
   1408            // remove device from entry data
   1409            ZDSecMgrEntryFree( entry );
   \   00000C   8E82         MOV       DPL,R6
   \   00000E   8F83         MOV       DPH,R7
   \   000010   74FE         MOV       A,#-0x2
   \   000012   F0           MOVX      @DPTR,A
   \   000013   A3           INC       DPTR
   \   000014   04           INC       A
   \   000015   F0           MOVX      @DPTR,A
   1410          
   1411            // remove EXT address
   1412            //ZDSecMgrExtAddrRelease( aiOld );
   1413          }
   \   000016   02....       LJMP      ??Subroutine89_0 & 0xFFFF
   1414          
   1415          /******************************************************************************
   1416           * @fn          ZDSecMgrDeviceEntryAdd
   1417           *
   1418           * @brief       Add entry.
   1419           *
   1420           * @param       device - [in] ZDSecMgrDevice_t, device info
   1421           * @param       ami    - [in] Address Manager index
   1422           *
   1423           * @return      ZStatus_t
   1424           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1425          void ZDSecMgrAddrMgrUpdate( uint16 ami, uint16 nwkAddr )
   \                     ZDSecMgrAddrMgrUpdate:
   1426          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV       A,#-0xd
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EC           MOV       A,R4
   \   00000B   FE           MOV       R6,A
   \   00000C   ED           MOV       A,R5
   \   00000D   FF           MOV       R7,A
   1427            AddrMgrEntry_t entry;
   1428          
   1429            // get the ami data
   1430            entry.user  = ADDRMGR_USER_SECURITY;
   \   00000E   85..82       MOV       DPL,?XSP + 0
   \   000011   85..83       MOV       DPH,?XSP + 1
   \   000014   7402         MOV       A,#0x2
   \   000016   F0           MOVX      @DPTR,A
   1431            entry.index = ami;
   \   000017   740B         MOV       A,#0xb
   \   000019   12....       LCALL     ?XSTACK_DISP0_8
   \   00001C   12....       LCALL     ?Subroutine33 & 0xFFFF
   1432          
   1433            AddrMgrEntryGet( &entry );
   \                     ??CrossCallReturnLabel_139:
   \   00001F   12....       LCALL     `??AddrMgrEntryGet::?relay`; Banked call to: AddrMgrEntryGet
   1434          
   1435            // check if NWK address is same
   1436            if ( entry.nwkAddr != nwkAddr )
   \   000022   7401         MOV       A,#0x1
   \   000024   12....       LCALL     ?XSTACK_DISP0_8
   \   000027   E0           MOVX      A,@DPTR
   \   000028   6E           XRL       A,R6
   \   000029   7003         JNZ       ??ZDSecMgrAddrMgrUpdate_0
   \   00002B   A3           INC       DPTR
   \   00002C   E0           MOVX      A,@DPTR
   \   00002D   6F           XRL       A,R7
   \                     ??ZDSecMgrAddrMgrUpdate_0:
   \   00002E   600F         JZ        ??ZDSecMgrAddrMgrUpdate_1
   1437            {
   1438              // update NWK address
   1439              entry.nwkAddr = nwkAddr;
   \   000030   7401         MOV       A,#0x1
   \   000032   12....       LCALL     ?XSTACK_DISP0_8
   \   000035   EE           MOV       A,R6
   \   000036   F0           MOVX      @DPTR,A
   \   000037   A3           INC       DPTR
   \   000038   EF           MOV       A,R7
   \   000039   12....       LCALL     ??Subroutine90_0 & 0xFFFF
   1440          
   1441              AddrMgrEntryUpdate( &entry );
   1442            }
   \                     ??CrossCallReturnLabel_141:
   \   00003C   12....       LCALL     `??AddrMgrEntryUpdate::?relay`; Banked call to: AddrMgrEntryUpdate
   1443          }
   \                     ??ZDSecMgrAddrMgrUpdate_1:
   \   00003F   02....       LJMP      ?Subroutine8 & 0xFFFF
   1444          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine46:
   \   000000   85..82       MOV       DPL,?XSP + 0
   \   000003   85..83       MOV       DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine81_0
   \   000006                ; // Fall through to label ??Subroutine81_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   7402         MOV       A,#0x2
   \   000002                REQUIRE ??Subroutine82_0
   \   000002                ; // Fall through to label ??Subroutine82_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1445          ZStatus_t ZDSecMgrDeviceEntryAdd( ZDSecMgrDevice_t* device, uint16 ami )
   \                     ZDSecMgrDeviceEntryAdd:
   1446          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V2,R2
   \   00000C   8B..         MOV       ?V3,R3
   \   00000E   EC           MOV       A,R4
   \   00000F   FE           MOV       R6,A
   \   000010   ED           MOV       A,R5
   \   000011   FF           MOV       R7,A
   1447            ZStatus_t        status;
   1448            ZDSecMgrEntry_t* entry;
   1449          
   1450          
   1451            // initialize as unknown until completion
   1452            status = ZNwkUnknownDevice;
   \   000012   75..C8       MOV       ?V0,#-0x38
   1453          
   1454            device->ctrl = NULL;
   \   000015   8A82         MOV       DPL,R2
   \   000017   8B83         MOV       DPH,R3
   \   000019   A3           INC       DPTR
   \   00001A   A3           INC       DPTR
   \   00001B   A3           INC       DPTR
   \   00001C   A3           INC       DPTR
   \   00001D   A3           INC       DPTR
   \   00001E   A3           INC       DPTR
   \   00001F   A3           INC       DPTR
   \   000020   A3           INC       DPTR
   \   000021   E4           CLR       A
   \   000022   F0           MOVX      @DPTR,A
   \   000023   A3           INC       DPTR
   \   000024   F0           MOVX      @DPTR,A
   1455          
   1456            // make sure not already registered
   1457            if ( ZDSecMgrEntryLookup( device->nwkAddr, &entry ) == ZSuccess )
   \   000025                ; Setup parameters for call to function ZDSecMgrEntryLookup
   \   000025   AC..         MOV       R4,?XSP + 0
   \   000027   AD..         MOV       R5,?XSP + 1
   \   000029   8A82         MOV       DPL,R2
   \   00002B   8B83         MOV       DPH,R3
   \   00002D   12....       LCALL     ??Subroutine85_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_127:
   \   000030   12....       LCALL     `??ZDSecMgrEntryLookup::?relay`; Banked call to: ZDSecMgrEntryLookup
   \   000033   E9           MOV       A,R1
   \   000034   7028         JNZ       ??ZDSecMgrDeviceEntryAdd_0
   1458            {
   1459              // verify that address index is same
   1460              if ( entry->ami != ami )
   \   000036   12....       LCALL     ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_117:
   \   000039   E0           MOVX      A,@DPTR
   \   00003A   6E           XRL       A,R6
   \   00003B   7003         JNZ       ??ZDSecMgrDeviceEntryAdd_1
   \   00003D   A3           INC       DPTR
   \   00003E   E0           MOVX      A,@DPTR
   \   00003F   6F           XRL       A,R7
   \                     ??ZDSecMgrDeviceEntryAdd_1:
   \   000040   602D         JZ        ??CrossCallReturnLabel_48
   1461              {
   1462                // remove conflicting entry
   1463                ZDSecMgrDeviceEntryRemove( entry );
   \   000042                ; Setup parameters for call to function ZDSecMgrDeviceEntryRemove
   \   000042   85..82       MOV       DPL,?XSP + 0
   \   000045   85..83       MOV       DPH,?XSP + 1
   \   000048   12....       LCALL     ??Subroutine85_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_128:
   \   00004B   12....       LCALL     `??ZDSecMgrDeviceEntryRemove::?relay`; Banked call to: ZDSecMgrDeviceEntryRemove
   1464          
   1465                if ( ZDSecMgrEntryLookupAMI( ami, &entry ) == ZSuccess )
   \   00004E                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   00004E   AC..         MOV       R4,?XSP + 0
   \   000050   AD..         MOV       R5,?XSP + 1
   \   000052   EE           MOV       A,R6
   \   000053   FA           MOV       R2,A
   \   000054   EF           MOV       A,R7
   \   000055   FB           MOV       R3,A
   \   000056   12....       LCALL     `??ZDSecMgrEntryLookupAMI::?relay`; Banked call to: ZDSecMgrEntryLookupAMI
   \   000059   E9           MOV       A,R1
   \   00005A   7013         JNZ       ??CrossCallReturnLabel_48
   \   00005C   800E         SJMP      ??ZDSecMgrDeviceEntryAdd_2
   1466                {
   1467                  // update NWK address
   1468                  ZDSecMgrAddrMgrUpdate( ami, device->nwkAddr );
   1469                }
   1470              }
   1471            }
   1472            else if ( ZDSecMgrEntryLookupAMI( ami, &entry ) == ZSuccess )
   \                     ??ZDSecMgrDeviceEntryAdd_0:
   \   00005E                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   00005E   AC..         MOV       R4,?XSP + 0
   \   000060   AD..         MOV       R5,?XSP + 1
   \   000062   EE           MOV       A,R6
   \   000063   FA           MOV       R2,A
   \   000064   EF           MOV       A,R7
   \   000065   FB           MOV       R3,A
   \   000066   12....       LCALL     `??ZDSecMgrEntryLookupAMI::?relay`; Banked call to: ZDSecMgrEntryLookupAMI
   \   000069   E9           MOV       A,R1
   \   00006A   7003         JNZ       ??CrossCallReturnLabel_48
   1473            {
   1474              // update NWK address
   1475              ZDSecMgrAddrMgrUpdate( ami, device->nwkAddr );
   \                     ??ZDSecMgrDeviceEntryAdd_2:
   \   00006C                ; Setup parameters for call to function ZDSecMgrAddrMgrUpdate
   \   00006C   12....       LCALL     ?Subroutine43 & 0xFFFF
   1476            }
   1477          
   1478            // check if a new entry needs to be created
   1479            if ( entry == NULL )
   \                     ??CrossCallReturnLabel_48:
   \   00006F   12....       LCALL     ??Subroutine93_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_175:
   \   000072   701D         JNZ       ??ZDSecMgrDeviceEntryAdd_3
   1480            {
   1481              // get new entry
   1482              if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   \   000074                ; Setup parameters for call to function ZDSecMgrEntryNew
   \   000074   AA..         MOV       R2,?XSP + 0
   \   000076   AB..         MOV       R3,?XSP + 1
   \   000078   12....       LCALL     `??ZDSecMgrEntryNew::?relay`; Banked call to: ZDSecMgrEntryNew
   \   00007B   E9           MOV       A,R1
   \   00007C   701C         JNZ       ??ZDSecMgrDeviceEntryAdd_4
   1483              {
   1484                // reset entry lkd
   1485          
   1486                // finish setting up entry
   1487                entry->ami = ami;
   \   00007E   12....       LCALL     ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_118:
   \   000081   EE           MOV       A,R6
   \   000082   F0           MOVX      @DPTR,A
   \   000083   A3           INC       DPTR
   \   000084   EF           MOV       A,R7
   \   000085   F0           MOVX      @DPTR,A
   1488          
   1489                // update NWK address
   1490                ZDSecMgrAddrMgrUpdate( ami, device->nwkAddr );
   \   000086                ; Setup parameters for call to function ZDSecMgrAddrMgrUpdate
   \   000086   12....       LCALL     ?Subroutine43 & 0xFFFF
   1491          
   1492                // enter new device into device control
   1493                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1494                {
   1495                  status = ZDSecMgrCtrlAdd( device, entry );
   \                     ??CrossCallReturnLabel_49:
   \   000089                ; Setup parameters for call to function ZDSecMgrCtrlAdd
   \   000089   12....       LCALL     ?Subroutine56 & 0xFFFF
   1496                }
   1497                else
   1498                {
   1499                  status = ZSuccess;
   1500                }
   1501              }
   1502            }
   \                     ??CrossCallReturnLabel_69:
   \   00008C   12....       LCALL     `??ZDSecMgrCtrlAdd::?relay`; Banked call to: ZDSecMgrCtrlAdd
   \   00008F   8006         SJMP      ??ZDSecMgrDeviceEntryAdd_5
   1503            else
   1504            {
   1505              // reset entry lkd
   1506          
   1507              // reset entry in entry control
   1508              if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1509              {
   1510                status = ZDSecMgrCtrlReset( device, entry );
   \                     ??ZDSecMgrDeviceEntryAdd_3:
   \   000091                ; Setup parameters for call to function ZDSecMgrCtrlReset
   \   000091   12....       LCALL     ?Subroutine56 & 0xFFFF
   1511              }
   1512              else
   1513              {
   1514                status = ZSuccess;
   1515              }
   1516            }
   \                     ??CrossCallReturnLabel_70:
   \   000094   12....       LCALL     `??ZDSecMgrCtrlReset::?relay`; Banked call to: ZDSecMgrCtrlReset
   \                     ??ZDSecMgrDeviceEntryAdd_5:
   \   000097   E9           MOV       A,R1
   \   000098   F5..         MOV       ?V0,A
   1517          
   1518            return status;
   \                     ??ZDSecMgrDeviceEntryAdd_4:
   \   00009A   A9..         MOV       R1,?V0
   \   00009C   02....       LJMP      ?Subroutine4 & 0xFFFF
   1519          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine56:
   \   000000   85..82       MOV       DPL,?XSP + 0
   \   000003   85..83       MOV       DPH,?XSP + 1
   \   000006   E0           MOVX      A,@DPTR
   \   000007   FC           MOV       R4,A
   \   000008   A3           INC       DPTR
   \   000009   E0           MOVX      A,@DPTR
   \   00000A   FD           MOV       R5,A
   \   00000B   AA..         MOV       R2,?V2
   \   00000D   AB..         MOV       R3,?V3
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine43:
   \   000000   85..82       MOV       DPL,?V2
   \   000003   85..83       MOV       DPH,?V3
   \   000006   12....       LCALL     ?Subroutine66 & 0xFFFF
   \                     ??CrossCallReturnLabel_95:
   \   000009   12....       LCALL     `??ZDSecMgrAddrMgrUpdate::?relay`; Banked call to: ZDSecMgrAddrMgrUpdate
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine66:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FC           MOV       R4,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   FD           MOV       R5,A
   \   000005   EE           MOV       A,R6
   \   000006   FA           MOV       R2,A
   \   000007   EF           MOV       A,R7
   \   000008   FB           MOV       R3,A
   \   000009   22           RET
   1520          
   1521          /******************************************************************************
   1522           * @fn          ZDSecMgrDeviceCtrlHandler
   1523           *
   1524           * @brief       Device control handler.
   1525           *
   1526           * @param       device - [in] ZDSecMgrDevice_t, device info
   1527           *
   1528           * @return      none
   1529           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1530          void ZDSecMgrDeviceCtrlHandler( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceCtrlHandler:
   1531          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   1532            uint8 state;
   1533            uint8 cntr;
   1534          
   1535          
   1536            state = device->ctrl->state;
   \   000005   EA           MOV       A,R2
   \   000006   2408         ADD       A,#0x8
   \   000008   FE           MOV       R6,A
   \   000009   E4           CLR       A
   \   00000A   3B           ADDC      A,R3
   \   00000B   FF           MOV       R7,A
   \   00000C   8E82         MOV       DPL,R6
   \   00000E   F583         MOV       DPH,A
   \   000010   12....       LCALL     ??Subroutine84_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_119:
   \   000013   E0           MOVX      A,@DPTR
   \   000014   F5..         MOV       ?V0,A
   1537            cntr  = ZDSECMGR_CTRL_BASE_CNTR;
   1538          
   1539            switch ( state )
   \   000016   24FE         ADD       A,#-0x2
   \   000018   600C         JZ        ??ZDSecMgrDeviceCtrlHandler_0
   \   00001A   14           DEC       A
   \   00001B   6014         JZ        ??ZDSecMgrDeviceCtrlHandler_1
   \   00001D   14           DEC       A
   \   00001E   6022         JZ        ??ZDSecMgrDeviceCtrlHandler_2
   \   000020   24FD         ADD       A,#-0x3
   \   000022   6018         JZ        ??ZDSecMgrDeviceCtrlHandler_3
   \   000024   8039         SJMP      ??ZDSecMgrDeviceCtrlHandler_4
   1540            {
   1541              case ZDSECMGR_CTRL_TK_MASTER:
   1542                if ( ZDSecMgrSendMasterKey( device ) == ZSuccess )
   \                     ??ZDSecMgrDeviceCtrlHandler_0:
   \   000026                ; Setup parameters for call to function ZDSecMgrSendMasterKey
   \   000026   12....       LCALL     `??ZDSecMgrSendMasterKey::?relay`; Banked call to: ZDSecMgrSendMasterKey
   \   000029   E9           MOV       A,R1
   \   00002A   7016         JNZ       ??ZDSecMgrDeviceCtrlHandler_2
   1543                {
   1544                  state = ZDSECMGR_CTRL_SKKE_INIT;
   \   00002C   75..03       MOV       ?V0,#0x3
   1545                  cntr  = ZDSECMGR_CTRL_SKKE_INIT_CNTR;
   \   00002F   8011         SJMP      ??ZDSecMgrDeviceCtrlHandler_2
   1546                }
   1547                break;
   1548          
   1549              case ZDSECMGR_CTRL_SKKE_INIT:
   1550                if ( ZDSecMgrEstablishKey( device ) == ZSuccess )
   \                     ??ZDSecMgrDeviceCtrlHandler_1:
   \   000031                ; Setup parameters for call to function ZDSecMgrEstablishKey
   \   000031   12....       LCALL     `??ZDSecMgrEstablishKey::?relay`; Banked call to: ZDSecMgrEstablishKey
   \   000034   E9           MOV       A,R1
   \   000035   700B         JNZ       ??ZDSecMgrDeviceCtrlHandler_2
   1551                {
   1552                  state = ZDSECMGR_CTRL_SKKE_WAIT;
   \   000037   75..04       MOV       ?V0,#0x4
   \   00003A   8006         SJMP      ??ZDSecMgrDeviceCtrlHandler_2
   1553                }
   1554                break;
   1555          
   1556              case ZDSECMGR_CTRL_SKKE_WAIT:
   1557                // continue to wait for SKA control timeout
   1558                break;
   1559          
   1560              case ZDSECMGR_CTRL_TK_NWK:
   1561                if ( ZDSecMgrSendNwkKey( device ) == ZSuccess )
   \                     ??ZDSecMgrDeviceCtrlHandler_3:
   \   00003C                ; Setup parameters for call to function ZDSecMgrSendNwkKey
   \   00003C   12....       LCALL     `??ZDSecMgrSendNwkKey::?relay`; Banked call to: ZDSecMgrSendNwkKey
   \   00003F   E9           MOV       A,R1
   \   000040   601D         JZ        ??ZDSecMgrDeviceCtrlHandler_4
   1562                {
   1563                  state = ZDSECMGR_CTRL_NONE;
   1564                }
   1565                break;
   1566          
   1567              default:
   1568                state = ZDSECMGR_CTRL_NONE;
   1569                break;
   1570            }
   1571          
   1572            if ( state != ZDSECMGR_CTRL_NONE )
   1573            {
   1574              device->ctrl->state = state;
   \                     ??ZDSecMgrDeviceCtrlHandler_2:
   \   000042   12....       LCALL     ?Subroutine38 & 0xFFFF
   \                     ??CrossCallReturnLabel_120:
   \   000045   E5..         MOV       A,?V0
   \   000047   12....       LCALL     ?Subroutine36 & 0xFFFF
   1575              device->ctrl->cntr  = cntr;
   \                     ??CrossCallReturnLabel_38:
   \   00004A   C8           XCH       A,R0
   \   00004B   12....       LCALL     ?Subroutine59 & 0xFFFF
   1576          
   1577              osal_start_timerEx(ZDAppTaskID, ZDO_SECMGR_EVENT, 100 );
   \                     ??CrossCallReturnLabel_82:
   \   00004E                ; Setup parameters for call to function osal_start_timerEx
   \   00004E   7C64         MOV       R4,#0x64
   \   000050   7D00         MOV       R5,#0x0
   \   000052   7A00         MOV       R2,#0x0
   \   000054   FB           MOV       R3,A
   \   000055   90....       MOV       DPTR,#ZDAppTaskID
   \   000058   E0           MOVX      A,@DPTR
   \   000059   F9           MOV       R1,A
   \   00005A   12....       LCALL     `??osal_start_timerEx::?relay`; Banked call to: osal_start_timerEx
   \   00005D   8005         SJMP      ??ZDSecMgrDeviceCtrlHandler_5
   1578            }
   1579            else
   1580            {
   1581              ZDSecMgrCtrlRelease( device->ctrl );
   \                     ??ZDSecMgrDeviceCtrlHandler_4:
   \   00005F   12....       LCALL     ?Subroutine38 & 0xFFFF
   \                     ??CrossCallReturnLabel_121:
   \   000062   E4           CLR       A
   \   000063   F0           MOVX      @DPTR,A
   1582            }
   1583          }
   \                     ??ZDSecMgrDeviceCtrlHandler_5:
   \   000064   02....       LJMP      ??Subroutine89_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine38:
   \   000000   8E82         MOV       DPL,R6
   \   000002   8F83         MOV       DPH,R7
   \   000004                REQUIRE ??Subroutine84_0
   \   000004                ; // Fall through to label ??Subroutine84_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine84_0:
   \   000000   12....       LCALL     ?Subroutine67 & 0xFFFF
   \                     ??CrossCallReturnLabel_124:
   \   000003   A3           INC       DPTR
   \   000004   A3           INC       DPTR
   \   000005   A3           INC       DPTR
   \   000006   A3           INC       DPTR
   \   000007   A3           INC       DPTR
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine59:
   \   000000   2406         ADD       A,#0x6
   \   000002   F582         MOV       DPL,A
   \   000004   E4           CLR       A
   \   000005   38           ADDC      A,R0
   \   000006   F583         MOV       DPH,A
   \   000008   7401         MOV       A,#0x1
   \   00000A   F0           MOVX      @DPTR,A
   \   00000B   22           RET
   1584          
   1585          /******************************************************************************
   1586           * @fn          ZDSecMgrDeviceCtrlSetup
   1587           *
   1588           * @brief       Setup device control.
   1589           *
   1590           * @param       device - [in] ZDSecMgrDevice_t, device info
   1591           *
   1592           * @return      ZStatus_t
   1593           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1594          void ZDSecMgrDeviceCtrlSetup( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceCtrlSetup:
   1595          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1596            if ( device->ctrl != NULL )
   \   000004   8A82         MOV       DPL,R2
   \   000006   8B83         MOV       DPH,R3
   \   000008   A3           INC       DPTR
   \   000009   A3           INC       DPTR
   \   00000A   A3           INC       DPTR
   \   00000B   A3           INC       DPTR
   \   00000C   A3           INC       DPTR
   \   00000D   A3           INC       DPTR
   \   00000E   A3           INC       DPTR
   \   00000F   A3           INC       DPTR
   \   000010   12....       LCALL     ??Subroutine94_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_170:
   \   000013   6022         JZ        ??ZDSecMgrDeviceCtrlSetup_0
   1597            {
   1598              if ( device->secure == FALSE )
   \   000015   E8           MOV       A,R0
   \   000016   2405         ADD       A,#0x5
   \   000018   F8           MOV       R0,A
   \   000019   5001         JNC       ??ZDSecMgrDeviceCtrlSetup_1
   \   00001B   09           INC       R1
   \                     ??ZDSecMgrDeviceCtrlSetup_1:
   \   00001C   8A82         MOV       DPL,R2
   \   00001E   8B83         MOV       DPH,R3
   \   000020   A3           INC       DPTR
   \   000021   A3           INC       DPTR
   \   000022   A3           INC       DPTR
   \   000023   A3           INC       DPTR
   \   000024   A3           INC       DPTR
   \   000025   A3           INC       DPTR
   \   000026   E0           MOVX      A,@DPTR
   \   000027   8882         MOV       DPL,R0
   \   000029   8983         MOV       DPH,R1
   \   00002B   7004         JNZ       ??ZDSecMgrDeviceCtrlSetup_2
   1599              {
   1600                // send the master key data to the joining device
   1601                device->ctrl->state = ZDSECMGR_CTRL_TK_MASTER;
   \   00002D   7402         MOV       A,#0x2
   \   00002F   8002         SJMP      ??ZDSecMgrDeviceCtrlSetup_3
   1602              }
   1603              else
   1604              {
   1605                // start SKKE
   1606                device->ctrl->state = ZDSECMGR_CTRL_SKKE_INIT;
   \                     ??ZDSecMgrDeviceCtrlSetup_2:
   \   000031   7403         MOV       A,#0x3
   \                     ??ZDSecMgrDeviceCtrlSetup_3:
   \   000033   F0           MOVX      @DPTR,A
   1607              }
   1608          
   1609              ZDSecMgrDeviceCtrlHandler( device );
   \   000034                ; Setup parameters for call to function ZDSecMgrDeviceCtrlHandler
   \   000034   12....       LCALL     `??ZDSecMgrDeviceCtrlHandler::?relay`; Banked call to: ZDSecMgrDeviceCtrlHandler
   1610            }
   1611          }
   \                     ??ZDSecMgrDeviceCtrlSetup_0:
   \   000037   02....       LJMP      ??Subroutine86_0 & 0xFFFF
   1612          
   1613          /******************************************************************************
   1614           * @fn          ZDSecMgrDeviceCtrlUpdate
   1615           *
   1616           * @brief       Update control data.
   1617           *
   1618           * @param       extAddr - [in] EXT address
   1619           * @param       state   - [in] new control state
   1620           *
   1621           * @return      none
   1622           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1623          void ZDSecMgrDeviceCtrlUpdate( uint8* extAddr, uint8 state )
   \                     ZDSecMgrDeviceCtrlUpdate:
   1624          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV       A,#-0x4
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   E9           MOV       A,R1
   \   00000B   FE           MOV       R6,A
   1625            ZDSecMgrEntry_t* entry;
   1626            ZDSecMgrCtrl_t*  ctrl;
   1627          
   1628          
   1629            // lookup device entry data
   1630            ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   00000C                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000C   7402         MOV       A,#0x2
   \   00000E   12....       LCALL     ?XSTACK_DISP102_8
   \   000011   12....       LCALL     `??ZDSecMgrEntryLookupExt::?relay`; Banked call to: ZDSecMgrEntryLookupExt
   1631          
   1632            if ( entry != NULL )
   \   000014   7402         MOV       A,#0x2
   \   000016   12....       LCALL     ?XSTACK_DISP0_8
   \   000019   12....       LCALL     ??Subroutine94_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_171:
   \   00001C   603F         JZ        ??CrossCallReturnLabel_83
   1633            {
   1634              // lookup device control data
   1635              ZDSecMgrCtrlLookup( entry, &ctrl );
   \   00001E                ; Setup parameters for call to function ZDSecMgrCtrlLookup
   \   00001E   AC..         MOV       R4,?XSP + 0
   \   000020   AD..         MOV       R5,?XSP + 1
   \   000022   7402         MOV       A,#0x2
   \   000024   12....       LCALL     ?XSTACK_DISP0_8
   \   000027   E0           MOVX      A,@DPTR
   \   000028   FA           MOV       R2,A
   \   000029   A3           INC       DPTR
   \   00002A   E0           MOVX      A,@DPTR
   \   00002B   12....       LCALL     ?Subroutine37 & 0xFFFF
   1636          
   1637              // make sure control data is valid
   1638              if ( ctrl != NULL )
   \                     ??CrossCallReturnLabel_164:
   \   00002E   602D         JZ        ??CrossCallReturnLabel_83
   1639              {
   1640                // possible state transitions
   1641                if ( ctrl->state == ZDSECMGR_CTRL_SKKE_WAIT )
   \   000030   85..82       MOV       DPL,?XSP + 0
   \   000033   85..83       MOV       DPH,?XSP + 1
   \   000036   E0           MOVX      A,@DPTR
   \   000037   2405         ADD       A,#0x5
   \   000039   F8           MOV       R0,A
   \   00003A   A3           INC       DPTR
   \   00003B   E0           MOVX      A,@DPTR
   \   00003C   3400         ADDC      A,#0x0
   \   00003E   8882         MOV       DPL,R0
   \   000040   F583         MOV       DPH,A
   \   000042   E0           MOVX      A,@DPTR
   \   000043   6404         XRL       A,#0x4
   \   000045   7016         JNZ       ??CrossCallReturnLabel_83
   1642                {
   1643                  if ( state == ZDSECMGR_CTRL_SKKE_DONE )
   \   000047   7405         MOV       A,#0x5
   \   000049   6E           XRL       A,R6
   \   00004A   7004         JNZ       ??ZDSecMgrDeviceCtrlUpdate_0
   1644                  {
   1645                    // send the network key
   1646                    ctrl->state = ZDSECMGR_CTRL_TK_NWK;
   \   00004C   7407         MOV       A,#0x7
   \   00004E   8007         SJMP      ??ZDSecMgrDeviceCtrlUpdate_1
   1647                    ctrl->cntr  = ZDSECMGR_CTRL_TK_NWK_CNTR;
   1648                  }
   1649                  else if ( state == ZDSECMGR_CTRL_SKKE_FAIL )
   \                     ??ZDSecMgrDeviceCtrlUpdate_0:
   \   000050   7406         MOV       A,#0x6
   \   000052   6E           XRL       A,R6
   \   000053   7008         JNZ       ??CrossCallReturnLabel_83
   1650                  {
   1651                    // force default timeout in order to cleanup control logic
   1652                    ctrl->state = ZDSECMGR_CTRL_SKKE_FAIL;
   \   000055   7406         MOV       A,#0x6
   1653                    ctrl->cntr  = ZDSECMGR_CTRL_BASE_CNTR;
   1654                  }
   1655                }
   1656                // timer should be active
   1657              }
   1658            }
   \                     ??ZDSecMgrDeviceCtrlUpdate_1:
   \   000057   12....       LCALL     ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_10:
   \   00005A   12....       LCALL     ?Subroutine59 & 0xFFFF
   1659          }
   \                     ??CrossCallReturnLabel_83:
   \   00005D                REQUIRE ?Subroutine9
   \   00005D                ; // Fall through to label ?Subroutine9

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   7404         MOV       A,#0x4
   \   000002   02....       LJMP      ??Subroutine88_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine74:
   \   000000   85..82       MOV       DPL,?XSP + 0
   \   000003   85..83       MOV       DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine104_0
   \   000006                ; // Fall through to label ??Subroutine104_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   12....       LCALL     ?Subroutine74 & 0xFFFF
   \                     ??CrossCallReturnLabel_223:
   \   000004   C8           XCH       A,R0
   \   000005   22           RET
   1660          
   1661          void APSME_SKA_TimerExpired( uint8 initiator, uint8* partExtAddr );

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1662          void APSME_SKA_TimerExpired( uint8 initiator, uint8* partExtAddr )
   \                     APSME_SKA_TimerExpired:
   1663          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV       A,R1
   \   000006   FE           MOV       R6,A
   1664            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1665            {
   1666              if ( initiator == TRUE )
   \   000007   7401         MOV       A,#0x1
   \   000009   6E           XRL       A,R6
   \   00000A   7005         JNZ       ??APSME_SKA_TimerExpired_0
   1667              {
   1668                ZDSecMgrDeviceCtrlUpdate( partExtAddr, ZDSECMGR_CTRL_SKKE_FAIL );
   \   00000C                ; Setup parameters for call to function ZDSecMgrDeviceCtrlUpdate
   \   00000C   7906         MOV       R1,#0x6
   \   00000E   12....       LCALL     `??ZDSecMgrDeviceCtrlUpdate::?relay`; Banked call to: ZDSecMgrDeviceCtrlUpdate
   1669              }
   1670            }
   1671          }
   \                     ??APSME_SKA_TimerExpired_0:
   \   000011   02....       LJMP      ??Subroutine89_0 & 0xFFFF
   1672          
   1673          /******************************************************************************
   1674           * @fn          ZDSecMgrDeviceRemove
   1675           *
   1676           * @brief       Remove device from network.
   1677           *
   1678           * @param       device - [in] ZDSecMgrDevice_t, device info
   1679           *
   1680           * @return      none
   1681           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1682          void ZDSecMgrDeviceRemove( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceRemove:
   1683          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 9
   \   000005   74F7         MOV       A,#-0x9
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   1684            APSME_RemoveDeviceReq_t remDevReq;
   1685            NLME_LeaveReq_t         leaveReq;
   1686            associated_devices_t*   assoc;
   1687          
   1688          
   1689            // check if parent, remove the device
   1690            if ( device->parentAddr == NLME_GetShortAddr() )
   \   00000E                ; Setup parameters for call to function NLME_GetShortAddr
   \   00000E   12....       LCALL     `??NLME_GetShortAddr::?relay`; Banked call to: NLME_GetShortAddr
   \   000011   8A..         MOV       ?V0,R2
   \   000013   8B..         MOV       ?V1,R3
   \   000015   8E82         MOV       DPL,R6
   \   000017   8F83         MOV       DPH,R7
   \   000019   A3           INC       DPTR
   \   00001A   A3           INC       DPTR
   \   00001B   A3           INC       DPTR
   \   00001C   A3           INC       DPTR
   \   00001D   12....       LCALL     ??Subroutine85_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_129:
   \   000020   EE           MOV       A,R6
   \   000021   2402         ADD       A,#0x2
   \   000023   F8           MOV       R0,A
   \   000024   E4           CLR       A
   \   000025   3F           ADDC      A,R7
   \   000026   F9           MOV       R1,A
   \   000027   E5..         MOV       A,?V0
   \   000029   6A           XRL       A,R2
   \   00002A   7003         JNZ       ??ZDSecMgrDeviceRemove_0
   \   00002C   E5..         MOV       A,?V1
   \   00002E   6B           XRL       A,R3
   \                     ??ZDSecMgrDeviceRemove_0:
   \   00002F   7056         JNZ       ??ZDSecMgrDeviceRemove_1
   1691            {
   1692              // this is the parent of the device
   1693              leaveReq.extAddr        = device->extAddr;
   \   000031   8882         MOV       DPL,R0
   \   000033   8983         MOV       DPH,R1
   \   000035   12....       LCALL     ??Subroutine85_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_130:
   \   000038   12....       LCALL     ?Subroutine21 & 0xFFFF
   1694              leaveReq.removeChildren = FALSE;
   \                     ??CrossCallReturnLabel_215:
   \   00003B   12....       LCALL     ?XSTACK_DISP0_8
   \   00003E   E4           CLR       A
   \   00003F   F0           MOVX      @DPTR,A
   1695              leaveReq.rejoin         = FALSE;
   \   000040   7403         MOV       A,#0x3
   \   000042   12....       LCALL     ?XSTACK_DISP0_8
   \   000045   E4           CLR       A
   \   000046   12....       LCALL     ?Subroutine65 & 0xFFFF
   1696          
   1697              // find child association
   1698              assoc = AssocGetWithExt( device->extAddr );
   \                     ??CrossCallReturnLabel_92:
   \   000049   12....       LCALL     ?Subroutine54 & 0xFFFF
   \                     ??CrossCallReturnLabel_67:
   \   00004C   8B..         MOV       ?V1,R3
   \   00004E   A9..         MOV       R1,?V1
   1699          
   1700              if ( ( assoc != NULL                            ) &&
   1701                   ( assoc->nodeRelation >= CHILD_RFD         ) &&
   1702                   ( assoc->nodeRelation <= CHILD_FFD_RX_IDLE )    )
   \   000050   EA           MOV       A,R2
   \   000051   49           ORL       A,R1
   \   000052   604E         JZ        ??ZDSecMgrDeviceRemove_2
   \   000054   8A82         MOV       DPL,R2
   \   000056   8B83         MOV       DPH,R3
   \   000058   A3           INC       DPTR
   \   000059   A3           INC       DPTR
   \   00005A   A3           INC       DPTR
   \   00005B   A3           INC       DPTR
   \   00005C   E0           MOVX      A,@DPTR
   \   00005D   6043         JZ        ??ZDSecMgrDeviceRemove_2
   \   00005F   C3           CLR       C
   \   000060   9405         SUBB      A,#0x5
   \   000062   503E         JNC       ??ZDSecMgrDeviceRemove_2
   1703              {
   1704                // check if associated device is authenticated
   1705                if ( assoc->devStatus & DEV_SEC_AUTH_STATUS )
   \   000064   8A82         MOV       DPL,R2
   \   000066   8B83         MOV       DPH,R3
   \   000068   A3           INC       DPTR
   \   000069   A3           INC       DPTR
   \   00006A   A3           INC       DPTR
   \   00006B   A3           INC       DPTR
   \   00006C   A3           INC       DPTR
   \   00006D   E0           MOVX      A,@DPTR
   \   00006E   A2E3         MOV       C,0xE0 /* A   */.3
   \   000070   7404         MOV       A,#0x4
   \   000072   5006         JNC       ??ZDSecMgrDeviceRemove_3
   1706                {
   1707                  leaveReq.silent = FALSE;
   \   000074   12....       LCALL     ?XSTACK_DISP0_8
   \   000077   E4           CLR       A
   \   000078   8005         SJMP      ??ZDSecMgrDeviceRemove_4
   1708                }
   1709                else
   1710                {
   1711                  leaveReq.silent = TRUE;
   \                     ??ZDSecMgrDeviceRemove_3:
   \   00007A   12....       LCALL     ?XSTACK_DISP0_8
   \   00007D   7401         MOV       A,#0x1
   1712                }
   1713          
   1714                NLME_LeaveReq( &leaveReq );
   1715              }
   1716            }
   \                     ??ZDSecMgrDeviceRemove_4:
   \   00007F   12....       LCALL     ??Subroutine90_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_142:
   \   000082   12....       LCALL     `??NLME_LeaveReq::?relay`; Banked call to: NLME_LeaveReq
   \   000085   801B         SJMP      ??ZDSecMgrDeviceRemove_2
   1717            else
   1718            {
   1719              // this is not the parent of the device
   1720              remDevReq.parentAddr   = device->parentAddr;
   \                     ??ZDSecMgrDeviceRemove_1:
   \   000087   7405         MOV       A,#0x5
   \   000089   12....       LCALL     ?XSTACK_DISP0_8
   \   00008C   EA           MOV       A,R2
   \   00008D   F0           MOVX      @DPTR,A
   \   00008E   A3           INC       DPTR
   \   00008F   EB           MOV       A,R3
   \   000090   12....       LCALL     ?Subroutine34 & 0xFFFF
   1721              remDevReq.childExtAddr = device->extAddr;
   1722          
   1723              APSME_RemoveDeviceReq( &remDevReq );
   1724            }
   \                     ??CrossCallReturnLabel_27:
   \   000093   F9           MOV       R1,A
   \   000094   7407         MOV       A,#0x7
   \   000096   12....       LCALL     ?XSTACK_DISP0_8
   \   000099   12....       LCALL     ??Subroutine80_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_114:
   \   00009C   12....       LCALL     ?XSTACK_DISP101_8
   \   00009F   12....       LCALL     `??APSME_RemoveDeviceReq::?relay`; Banked call to: APSME_RemoveDeviceReq
   1725          }
   \                     ??ZDSecMgrDeviceRemove_2:
   \   0000A2   7409         MOV       A,#0x9
   \   0000A4   02....       LJMP      ??Subroutine101_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine34:
   \   000000   12....       LCALL     ?Subroutine65 & 0xFFFF
   \                     ??CrossCallReturnLabel_93:
   \   000003   12....       LCALL     ??Subroutine104_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_219:
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   85..82       MOV       DPL,?XSP + 0
   \   000003   85..83       MOV       DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine103_0
   \   000006                ; // Fall through to label ??Subroutine103_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine103_0:
   \   000000   EA           MOV       A,R2
   \   000001   F0           MOVX      @DPTR,A
   \   000002   A3           INC       DPTR
   \   000003   EB           MOV       A,R3
   \   000004   F0           MOVX      @DPTR,A
   \   000005   7402         MOV       A,#0x2
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine54:
   \   000000   12....       LCALL     ??Subroutine105_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_227:
   \   000003   12....       LCALL     `??AssocGetWithExt::?relay`; Banked call to: AssocGetWithExt
   \   000006   22           RET
   1726          
   1727          /******************************************************************************
   1728           * @fn          ZDSecMgrDeviceValidateSKKE
   1729           *
   1730           * @brief       Decide whether device is allowed for SKKE.
   1731           *
   1732           * @param       device - [in] ZDSecMgrDevice_t, device info
   1733           *
   1734           * @return      ZStatus_t
   1735           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1736          ZStatus_t ZDSecMgrDeviceValidateSKKE( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidateSKKE:
   1737          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV       A,#-0x4
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   1738            ZStatus_t status;
   1739            uint16    ami;
   1740            uint8*    key;
   1741          
   1742          
   1743            // get EXT address
   1744            status = ZDSecMgrExtAddrLookup( device->extAddr, &ami );
   \   00000E                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00000E   AC..         MOV       R4,?XSP + 0
   \   000010   AD..         MOV       R5,?XSP + 1
   \   000012   8A82         MOV       DPL,R2
   \   000014   F583         MOV       DPH,A
   \   000016   A3           INC       DPTR
   \   000017   A3           INC       DPTR
   \   000018   12....       LCALL     ??Subroutine85_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_131:
   \   00001B   12....       LCALL     `??ZDSecMgrExtAddrLookup::?relay`; Banked call to: ZDSecMgrExtAddrLookup
   \   00001E   E9           MOV       A,R1
   \   00001F   F9           MOV       R1,A
   1745          
   1746            if ( status == ZSuccess )
   \   000020   700F         JNZ       ??ZDSecMgrDeviceValidateSKKE_0
   1747            {
   1748              // get MASTER key
   1749              status = ZDSecMgrMasterKeyLookup( ami, &key );
   \   000022                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   000022   7402         MOV       A,#0x2
   \   000024   12....       LCALL     ?XSTACK_DISP102_8
   \   000027   12....       LCALL     ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_46:
   \   00002A   F9           MOV       R1,A
   1750          
   1751              if ( status == ZSuccess )
   \   00002B   7004         JNZ       ??ZDSecMgrDeviceValidateSKKE_0
   1752              {
   1753              //  // check if initiator is Trust Center
   1754              //  if ( device->nwkAddr == APSME_TRUSTCENTER_NWKADDR )
   1755              //  {
   1756              //    // verify NWK key not sent
   1757              //    // devtag.todo
   1758              //    // temporary - add device to internal data
   1759              //    status = ZDSecMgrDeviceEntryAdd( device, ami );
   1760              //  }
   1761              //  else
   1762              //  {
   1763              //    // initiator not Trust Center - End to End SKKE - set policy
   1764              //    // for accepting an SKKE initiation
   1765              //    // temporary - add device to internal data
   1766              //    status = ZDSecMgrDeviceEntryAdd( device, ami );
   1767              //  }
   1768                  status = ZDSecMgrDeviceEntryAdd( device, ami );
   \   00002D                ; Setup parameters for call to function ZDSecMgrDeviceEntryAdd
   \   00002D   12....       LCALL     ?Subroutine44 & 0xFFFF
   1769              }
   1770            }
   \                     ??CrossCallReturnLabel_50:
   \   000030   F9           MOV       R1,A
   1771          
   1772            return status;
   \                     ??ZDSecMgrDeviceValidateSKKE_0:
   \   000031   02....       LJMP      ?Subroutine9 & 0xFFFF
   1773          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine44:
   \   000000   85..82       MOV       DPL,?XSP + 0
   \   000003   85..83       MOV       DPH,?XSP + 1
   \   000006   12....       LCALL     ?Subroutine66 & 0xFFFF
   \                     ??CrossCallReturnLabel_96:
   \   000009   12....       LCALL     `??ZDSecMgrDeviceEntryAdd::?relay`; Banked call to: ZDSecMgrDeviceEntryAdd
   \   00000C   E9           MOV       A,R1
   \   00000D   22           RET
   1774          
   1775          /******************************************************************************
   1776           * @fn          ZDSecMgrDeviceValidateRM (RESIDENTIAL MODE)
   1777           *
   1778           * @brief       Decide whether device is allowed.
   1779           *
   1780           * @param       device - [in] ZDSecMgrDevice_t, device info
   1781           *
   1782           * @return      ZStatus_t
   1783           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1784          ZStatus_t ZDSecMgrDeviceValidateRM( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidateRM:
   1785          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1786          
   1787            ZStatus_t status;
   1788            status = ZSuccess;
   \   000004   7900         MOV       R1,#0x0
   1789          
   1790            (void)device;  // Intentionally unreferenced parameter
   1791            
   1792            // For test purpose, turning off the zgSecurePermitJoin flag will force
   1793            // the trust center to reject any newly joining devices by sending
   1794            // Remove-device to the parents.
   1795            if ( zgSecurePermitJoin == false )
   \   000006   90....       MOV       DPTR,#zgSecurePermitJoin
   \   000009   E0           MOVX      A,@DPTR
   \   00000A   7002         JNZ       ??ZDSecMgrDeviceValidateRM_0
   1796            {
   1797              status = ZNwkUnknownDevice;
   \   00000C   79C8         MOV       R1,#-0x38
   1798            }
   1799          
   1800          
   1801          
   1802          #if 0  // Taken out because the following functionality is only used for test
   1803                 // purpose. A more efficient (above) way is used. It can be put
   1804                 // back in if customers request for a white/black list feature.
   1805                 // ZDSecMgrStoredDeviceList[] is defined in ZDSecMgr.c
   1806          
   1807            // The following code processes the device black list (stored device list)
   1808            // If the joining device is not part of the forbidden device list
   1809            // Return ZSuccess. Otherwise, return ZNwkUnknownDevice. The trust center
   1810            // will send Remove-device and ban the device from joining.
   1811          
   1812            uint8     index;
   1813            uint8*    restricted;
   1814          
   1815            // Look through the stored device list - used for restricted devices
   1816            for ( index = 0; index < ZDSECMGR_STORED_DEVICES; index++ )
   1817            {
   1818              restricted = ZDSecMgrStoredDeviceList[index];
   1819          
   1820              if ( AddrMgrExtAddrEqual( restricted, device->extAddr )  == TRUE )
   1821              {
   1822                // return as unknown device in regards to validation
   1823                status = ZNwkUnknownDevice;
   1824          
   1825                // break from loop
   1826                index = ZDSECMGR_STORED_DEVICES;
   1827              }
   1828            }
   1829          
   1830          #endif
   1831          
   1832            return status;
   \                     ??ZDSecMgrDeviceValidateRM_0:
   \   00000E   02....       LJMP      ??Subroutine86_0 & 0xFFFF
   1833          }
   1834          
   1835          /******************************************************************************
   1836           * @fn          ZDSecMgrDeviceValidateCM (COMMERCIAL MODE)
   1837           *
   1838           * @brief       Decide whether device is allowed.
   1839           *
   1840           * @param       device - [in] ZDSecMgrDevice_t, device info
   1841           *
   1842           * @return      ZStatus_t
   1843           */
   1844          //devtag.pro.security

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1845          ZStatus_t ZDSecMgrDeviceValidateCM( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidateCM:
   1846          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   1847            ZStatus_t status;
   1848            uint16    ami;
   1849            uint8*    key;
   1850          
   1851          
   1852          //  // check for pre configured setting
   1853          //  if ( device->secure == TRUE )
   1854          //  {
   1855          //    // get EXT address and MASTER key
   1856          //    status = ZDSecMgrExtAddrLookup( device->extAddr, &ami );
   1857          //
   1858          //    if ( status == ZSuccess )
   1859          //    {
   1860          //      status = ZDSecMgrMasterKeyLookup( ami, &key );
   1861          //    }
   1862          //  }
   1863          //  else
   1864          //  {
   1865              // implement EXT address and MASTER key policy here -- the total number of
   1866              // Security Manager entries should never exceed the number of EXT addresses
   1867              // and MASTER keys available
   1868          
   1869              // set status based on policy
   1870              //status = ZNwkUnknownDevice;
   1871          
   1872              // set status based on policy
   1873              status = ZSuccess; // ZNwkUnknownDevice;
   1874          
   1875              // get key based on policy
   1876              key = ZDSecMgrTCMasterKey;
   1877          
   1878              // if policy, store new EXT address
   1879              status = ZDSecMgrAddrStore( device->nwkAddr, device->extAddr, &ami );
   \   00000E   EA           MOV       A,R2
   \   00000F   2402         ADD       A,#0x2
   \   000011   F5..         MOV       ?V0,A
   \   000013   E4           CLR       A
   \   000014   3F           ADDC      A,R7
   \   000015   F5..         MOV       ?V1,A
   \   000017                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   000017   A8..         MOV       R0,?XSP + 0
   \   000019   A9..         MOV       R1,?XSP + 1
   \   00001B   88..         MOV       ?V2,R0
   \   00001D   89..         MOV       ?V3,R1
   \   00001F   78..         MOV       R0,#?V2
   \   000021   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000024   85..82       MOV       DPL,?V0
   \   000027   85..83       MOV       DPH,?V1
   \   00002A   12....       LCALL     ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_62:
   \   00002D   FA           MOV       R2,A
   \   00002E   A3           INC       DPTR
   \   00002F   E0           MOVX      A,@DPTR
   \   000030   FB           MOV       R3,A
   \   000031   12....       LCALL     `??ZDSecMgrAddrStore::?relay`; Banked call to: ZDSecMgrAddrStore
   \   000034   7402         MOV       A,#0x2
   \   000036   12....       LCALL     ?DEALLOC_XSTACK8
   \   000039   E9           MOV       A,R1
   \   00003A   F5..         MOV       ?V2,A
   1880          
   1881              // set the key
   1882              ZDSecMgrMasterKeyLoad( device->extAddr, key );
   \   00003C                ; Setup parameters for call to function ZDSecMgrMasterKeyLoad
   \   00003C   7C..         MOV       R4,#ZDSecMgrTCMasterKey & 0xff
   \   00003E   7D..         MOV       R5,#(ZDSecMgrTCMasterKey >> 8) & 0xff
   \   000040   85..82       MOV       DPL,?V0
   \   000043   85..83       MOV       DPH,?V1
   \   000046   12....       LCALL     ??Subroutine85_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_132:
   \   000049   12....       LCALL     `??ZDSecMgrMasterKeyLoad::?relay`; Banked call to: ZDSecMgrMasterKeyLoad
   1883          //  }
   1884          
   1885            // if EXT address and MASTER key available -- add device
   1886            if ( status == ZSuccess )
   \   00004C   E5..         MOV       A,?V2
   \   00004E   7005         JNZ       ??ZDSecMgrDeviceValidateCM_0
   1887            {
   1888              // add device to internal data - with control
   1889              status = ZDSecMgrDeviceEntryAdd( device, ami );
   \   000050                ; Setup parameters for call to function ZDSecMgrDeviceEntryAdd
   \   000050   12....       LCALL     ?Subroutine44 & 0xFFFF
   1890            }
   \                     ??CrossCallReturnLabel_51:
   \   000053   F5..         MOV       ?V2,A
   1891          
   1892            return status;
   \                     ??ZDSecMgrDeviceValidateCM_0:
   \   000055   A9..         MOV       R1,?V2
   \   000057   02....       LJMP      ?Subroutine4 & 0xFFFF
   1893          }
   1894          //devtag.pro.security
   1895          #if 0
   1896          ZStatus_t ZDSecMgrDeviceValidateCM( ZDSecMgrDevice_t* device )
   1897          {
   1898            ZStatus_t status;
   1899            uint16    ami;
   1900            uint8*    key;
   1901          
   1902          
   1903            // check for pre configured setting
   1904            if ( device->secure == TRUE )
   1905            {
   1906              // get EXT address and MASTER key
   1907              status = ZDSecMgrExtAddrLookup( device->extAddr, &ami );
   1908          
   1909              if ( status == ZSuccess )
   1910              {
   1911                status = ZDSecMgrMasterKeyLookup( ami, &key );
   1912              }
   1913            }
   1914            else
   1915            {
   1916              // implement EXT address and MASTER key policy here -- the total number of
   1917              // Security Manager entries should never exceed the number of EXT addresses
   1918              // and MASTER keys available
   1919          
   1920              // set status based on policy
   1921              status = ZSuccess; // ZNwkUnknownDevice;
   1922          
   1923              // get the address index
   1924              if ( ZDSecMgrExtAddrLookup( device->extAddr, &ami ) != ZSuccess )
   1925              {
   1926                // if policy, store new EXT address
   1927                status = ZDSecMgrAddrStore( device->nwkAddr, device->extAddr, &ami );
   1928              }
   1929          
   1930              // get the address index
   1931              if ( ZDSecMgrMasterKeyLookup( ami, &key ) != ZSuccess )
   1932              {
   1933                // if policy, store new key -- NULL will zero key
   1934                status = ZDSecMgrMasterKeyStore( ami, NULL );
   1935              }
   1936            }
   1937          
   1938            // if EXT address and MASTER key available -- add device
   1939            if ( status == ZSuccess )
   1940            {
   1941              // add device to internal data - with control
   1942              status = ZDSecMgrDeviceEntryAdd( device, ami );
   1943            }
   1944          
   1945            return status;
   1946          }
   1947          #endif
   1948          
   1949          /******************************************************************************
   1950           * @fn          ZDSecMgrDeviceValidate
   1951           *
   1952           * @brief       Decide whether device is allowed.
   1953           *
   1954           * @param       device - [in] ZDSecMgrDevice_t, device info
   1955           *
   1956           * @return      ZStatus_t
   1957           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1958          ZStatus_t ZDSecMgrDeviceValidate( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidate:
   1959          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1960            ZStatus_t status;
   1961          
   1962          
   1963            if ( ZDSecMgrPermitJoiningEnabled == TRUE )
   \   000004   90....       MOV       DPTR,#ZDSecMgrPermitJoiningEnabled
   \   000007   E0           MOVX      A,@DPTR
   \   000008   6401         XRL       A,#0x1
   \   00000A   7020         JNZ       ??ZDSecMgrDeviceValidate_0
   1964            {
   1965              // device may be joining with a secure flag but it is ultimately the Trust
   1966              // Center that decides -- check if expected pre configured device --
   1967              // override settings
   1968              if ( zgPreConfigKeys == TRUE )
   \   00000C   EA           MOV       A,R2
   \   00000D   2406         ADD       A,#0x6
   \   00000F   F8           MOV       R0,A
   \   000010   E4           CLR       A
   \   000011   3B           ADDC      A,R3
   \   000012   F9           MOV       R1,A
   \   000013   90....       MOV       DPTR,#zgPreConfigKeys
   \   000016   E0           MOVX      A,@DPTR
   \   000017   6401         XRL       A,#0x1
   \   000019   8882         MOV       DPL,R0
   \   00001B   8983         MOV       DPH,R1
   \   00001D   7004         JNZ       ??ZDSecMgrDeviceValidate_1
   1969              {
   1970                device->secure = TRUE;
   \   00001F   7401         MOV       A,#0x1
   \   000021   8001         SJMP      ??ZDSecMgrDeviceValidate_2
   1971              }
   1972              else
   1973              {
   1974                device->secure = FALSE;
   \                     ??ZDSecMgrDeviceValidate_1:
   \   000023   E4           CLR       A
   \                     ??ZDSecMgrDeviceValidate_2:
   \   000024   F0           MOVX      @DPTR,A
   1975              }
   1976          
   1977              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   1978              {
   1979                status = ZDSecMgrDeviceValidateCM( device );
   1980              }
   1981              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   1982              {
   1983                status = ZDSecMgrDeviceValidateRM( device );
   \   000025                ; Setup parameters for call to function ZDSecMgrDeviceValidateRM
   \   000025   12....       LCALL     `??ZDSecMgrDeviceValidateRM::?relay`; Banked call to: ZDSecMgrDeviceValidateRM
   \   000028   E9           MOV       A,R1
   \   000029   F9           MOV       R1,A
   \   00002A   8002         SJMP      ??ZDSecMgrDeviceValidate_3
   1984              }
   1985            }
   1986            else
   1987            {
   1988              status = ZNwkUnknownDevice;
   \                     ??ZDSecMgrDeviceValidate_0:
   \   00002C   79C8         MOV       R1,#-0x38
   1989            }
   1990          
   1991            return status;
   \                     ??ZDSecMgrDeviceValidate_3:
   \   00002E   02....       LJMP      ??Subroutine86_0 & 0xFFFF
   1992          }
   1993          
   1994          /******************************************************************************
   1995           * @fn          ZDSecMgrDeviceJoin
   1996           *
   1997           * @brief       Try to join this device.
   1998           *
   1999           * @param       device - [in] ZDSecMgrDevice_t, device info
   2000           *
   2001           * @return      ZStatus_t
   2002           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2003          ZStatus_t ZDSecMgrDeviceJoin( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoin:
   2004          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
   2005            ZStatus_t status;
   2006          
   2007            // attempt to validate device
   2008            status = ZDSecMgrDeviceValidate( device );
   \   000009                ; Setup parameters for call to function ZDSecMgrDeviceValidate
   \   000009   12....       LCALL     `??ZDSecMgrDeviceValidate::?relay`; Banked call to: ZDSecMgrDeviceValidate
   \   00000C   E9           MOV       A,R1
   \   00000D   F5..         MOV       ?V0,A
   2009          
   2010            if ( status == ZSuccess )
   \   00000F   700C         JNZ       ??ZDSecMgrDeviceJoin_0
   2011            {
   2012              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2013              {
   2014                ZDSecMgrDeviceCtrlSetup( device );
   2015              }
   2016              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   2017              {
   2018                //send the nwk key data to the joining device
   2019                status = ZDSecMgrSendNwkKey( device );
   \   000011                ; Setup parameters for call to function ZDSecMgrSendNwkKey
   \   000011   EE           MOV       A,R6
   \   000012   FA           MOV       R2,A
   \   000013   EF           MOV       A,R7
   \   000014   FB           MOV       R3,A
   \   000015   12....       LCALL     `??ZDSecMgrSendNwkKey::?relay`; Banked call to: ZDSecMgrSendNwkKey
   \   000018   E9           MOV       A,R1
   \   000019   F5..         MOV       ?V0,A
   \   00001B   8007         SJMP      ??ZDSecMgrDeviceJoin_1
   2020              }
   2021            }
   2022            else
   2023            {
   2024              // not allowed, remove the device
   2025              ZDSecMgrDeviceRemove( device );
   \                     ??ZDSecMgrDeviceJoin_0:
   \   00001D                ; Setup parameters for call to function ZDSecMgrDeviceRemove
   \   00001D   EE           MOV       A,R6
   \   00001E   FA           MOV       R2,A
   \   00001F   EF           MOV       A,R7
   \   000020   FB           MOV       R3,A
   \   000021   12....       LCALL     `??ZDSecMgrDeviceRemove::?relay`; Banked call to: ZDSecMgrDeviceRemove
   2026            }
   2027          
   2028            return status;
   \                     ??ZDSecMgrDeviceJoin_1:
   \   000024                REQUIRE ?Subroutine14
   \   000024                ; // Fall through to label ?Subroutine14
   2029          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   A9..         MOV       R1,?V0
   \   000002   02....       LJMP      ??Subroutine89_0 & 0xFFFF
   2030          
   2031          /******************************************************************************
   2032           * @fn          ZDSecMgrDeviceJoinDirect
   2033           *
   2034           * @brief       Try to join this device as a direct child.
   2035           *
   2036           * @param       device - [in] ZDSecMgrDevice_t, device info
   2037           *
   2038           * @return      ZStatus_t
   2039           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2040          ZStatus_t ZDSecMgrDeviceJoinDirect( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoinDirect:
   2041          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
   2042            ZStatus_t status;
   2043          
   2044            status = ZDSecMgrDeviceJoin( device );
   \   000009                ; Setup parameters for call to function ZDSecMgrDeviceJoin
   \   000009   12....       LCALL     `??ZDSecMgrDeviceJoin::?relay`; Banked call to: ZDSecMgrDeviceJoin
   \   00000C   E9           MOV       A,R1
   \   00000D   F5..         MOV       ?V0,A
   2045          
   2046            if ( status == ZSuccess )
   \   00000F   7009         JNZ       ??ZDSecMgrDeviceJoinDirect_0
   2047            {
   2048              // set association status to authenticated
   2049              ZDSecMgrAssocDeviceAuth( AssocGetWithShort( device->nwkAddr ) );
   \   000011                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   000011                ; Setup parameters for call to function AssocGetWithShort
   \   000011   12....       LCALL     ?Subroutine55 & 0xFFFF
   2050            }
   \                     ??CrossCallReturnLabel_137:
   \   000014   12....       LCALL     `??AssocGetWithShort::?relay`; Banked call to: AssocGetWithShort
   \   000017   12....       LCALL     `??ZDSecMgrAssocDeviceAuth::?relay`; Banked call to: ZDSecMgrAssocDeviceAuth
   2051          
   2052            return status;
   \                     ??ZDSecMgrDeviceJoinDirect_0:
   \   00001A   80..         SJMP      ?Subroutine14
   2053          }
   2054          
   2055          /******************************************************************************
   2056           * @fn          ZDSecMgrDeviceJoinFwd
   2057           *
   2058           * @brief       Forward join to Trust Center.
   2059           *
   2060           * @param       device - [in] ZDSecMgrDevice_t, device info
   2061           *
   2062           * @return      ZStatus_t
   2063           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2064          ZStatus_t ZDSecMgrDeviceJoinFwd( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoinFwd:
   2065          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 8
   \   000004   74F8         MOV       A,#-0x8
   \   000006   12....       LCALL     ?ALLOC_XSTACK8
   2066            ZStatus_t               status;
   2067            APSME_UpdateDeviceReq_t req;
   2068          
   2069          
   2070            // forward any joining device to the Trust Center -- the Trust Center will
   2071            // decide if the device is allowed to join
   2072            status = ZSuccess;
   2073          
   2074            // forward authorization to the Trust Center
   2075            req.dstAddr    = APSME_TRUSTCENTER_NWKADDR;
   \   000009   85..82       MOV       DPL,?XSP + 0
   \   00000C   85..83       MOV       DPH,?XSP + 1
   \   00000F   E4           CLR       A
   \   000010   F0           MOVX      @DPTR,A
   \   000011   A3           INC       DPTR
   \   000012   F0           MOVX      @DPTR,A
   2076            req.devAddr    = device->nwkAddr;
   \   000013   8A82         MOV       DPL,R2
   \   000015   8B83         MOV       DPH,R3
   \   000017   12....       LCALL     ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_58:
   \   00001A   12....       LCALL     ?XSTACK_DISP0_8
   \   00001D   12....       LCALL     ?Subroutine18 & 0xFFFF
   2077            req.devExtAddr = device->extAddr;
   \                     ??CrossCallReturnLabel_4:
   \   000020   12....       LCALL     ?XSTACK_DISP0_8
   \   000023   12....       LCALL     ??Subroutine91_0 & 0xFFFF
   2078          
   2079            // set security status, option for router to reject if policy set
   2080            if ( (device->devStatus & DEV_HIGH_SEC_STATUS) )
   \                     ??CrossCallReturnLabel_155:
   \   000026   EA           MOV       A,R2
   \   000027   2407         ADD       A,#0x7
   \   000029   F582         MOV       DPL,A
   \   00002B   E4           CLR       A
   \   00002C   3B           ADDC      A,R3
   \   00002D   F583         MOV       DPH,A
   \   00002F   E0           MOVX      A,@DPTR
   \   000030   A2E7         MOV       C,0xE0 /* A   */.7
   \   000032   502E         JNC       ??ZDSecMgrDeviceJoinFwd_0
   2081            {
   2082              if ( device->devStatus & DEV_REJOIN_STATUS )
   \   000034   A2E6         MOV       C,0xE0 /* A   */.6
   \   000036   5021         JNC       ??ZDSecMgrDeviceJoinFwd_1
   2083              {
   2084                if ( device->secure == TRUE )
   \   000038   8A82         MOV       DPL,R2
   \   00003A   8B83         MOV       DPH,R3
   \   00003C   A3           INC       DPTR
   \   00003D   A3           INC       DPTR
   \   00003E   A3           INC       DPTR
   \   00003F   A3           INC       DPTR
   \   000040   A3           INC       DPTR
   \   000041   A3           INC       DPTR
   \   000042   E0           MOVX      A,@DPTR
   \   000043   6401         XRL       A,#0x1
   \   000045   7009         JNZ       ??ZDSecMgrDeviceJoinFwd_2
   2085                  req.status = APSME_UD_HIGH_SECURED_REJOIN;
   \   000047   7406         MOV       A,#0x6
   \   000049   12....       LCALL     ?XSTACK_DISP0_8
   \   00004C   7404         MOV       A,#0x4
   \   00004E   803D         SJMP      ??ZDSecMgrDeviceJoinFwd_3
   2086                else
   2087                  req.status = APSME_UD_HIGH_UNSECURED_REJOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_2:
   \   000050   7406         MOV       A,#0x6
   \   000052   12....       LCALL     ?XSTACK_DISP0_8
   \   000055   7407         MOV       A,#0x7
   \   000057   8034         SJMP      ??ZDSecMgrDeviceJoinFwd_3
   2088              }
   2089              else
   2090                req.status = APSME_UD_HIGH_UNSECURED_JOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_1:
   \   000059   7406         MOV       A,#0x6
   \   00005B   12....       LCALL     ?XSTACK_DISP0_8
   \   00005E   7405         MOV       A,#0x5
   \   000060   802B         SJMP      ??ZDSecMgrDeviceJoinFwd_3
   2091            }
   2092            else
   2093            {
   2094              if ( device->devStatus & DEV_REJOIN_STATUS )
   \                     ??ZDSecMgrDeviceJoinFwd_0:
   \   000062   A2E6         MOV       C,0xE0 /* A   */.6
   \   000064   5020         JNC       ??ZDSecMgrDeviceJoinFwd_4
   2095              {
   2096                if ( device->secure == TRUE )
   \   000066   8A82         MOV       DPL,R2
   \   000068   8B83         MOV       DPH,R3
   \   00006A   A3           INC       DPTR
   \   00006B   A3           INC       DPTR
   \   00006C   A3           INC       DPTR
   \   00006D   A3           INC       DPTR
   \   00006E   A3           INC       DPTR
   \   00006F   A3           INC       DPTR
   \   000070   E0           MOVX      A,@DPTR
   \   000071   6401         XRL       A,#0x1
   \   000073   7008         JNZ       ??ZDSecMgrDeviceJoinFwd_5
   2097                  req.status = APSME_UD_STANDARD_SECURED_REJOIN;
   \   000075   7406         MOV       A,#0x6
   \   000077   12....       LCALL     ?XSTACK_DISP0_8
   \   00007A   E4           CLR       A
   \   00007B   8010         SJMP      ??ZDSecMgrDeviceJoinFwd_3
   2098                else
   2099                  req.status = APSME_UD_STANDARD_UNSECURED_REJOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_5:
   \   00007D   7406         MOV       A,#0x6
   \   00007F   12....       LCALL     ?XSTACK_DISP0_8
   \   000082   7403         MOV       A,#0x3
   \   000084   8007         SJMP      ??ZDSecMgrDeviceJoinFwd_3
   2100              }
   2101              else
   2102                req.status = APSME_UD_STANDARD_UNSECURED_JOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_4:
   \   000086   7406         MOV       A,#0x6
   \   000088   12....       LCALL     ?XSTACK_DISP0_8
   \   00008B   7401         MOV       A,#0x1
   \                     ??ZDSecMgrDeviceJoinFwd_3:
   \   00008D   F0           MOVX      @DPTR,A
   2103            }
   2104          
   2105            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2106              req.apsSecure = TRUE;
   2107            else
   2108              req.apsSecure = FALSE;
   \   00008E   7407         MOV       A,#0x7
   \   000090   12....       LCALL     ?XSTACK_DISP0_8
   \   000093   E4           CLR       A
   \   000094   12....       LCALL     ??Subroutine90_0 & 0xFFFF
   2109          
   2110            // send and APSME_UPDATE_DEVICE request to the trust center
   2111            status = APSME_UpdateDeviceReq( &req );
   2112          
   2113            return status;
   \                     ??CrossCallReturnLabel_143:
   \   000097   12....       LCALL     `??APSME_UpdateDeviceReq::?relay`; Banked call to: APSME_UpdateDeviceReq
   \   00009A   7408         MOV       A,#0x8
   \   00009C   02....       LJMP      ??Subroutine79_0 & 0xFFFF
   2114          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   E8           MOV       A,R0
   \   000001   F0           MOVX      @DPTR,A
   \   000002   A3           INC       DPTR
   \   000003   E9           MOV       A,R1
   \   000004   12....       LCALL     ?Subroutine62 & 0xFFFF
   \                     ??CrossCallReturnLabel_89:
   \   000007   7404         MOV       A,#0x4
   \   000009   22           RET
   2115          
   2116          /******************************************************************************
   2117           * @fn          ZDSecMgrDeviceNew
   2118           *
   2119           * @brief       Process a new device.
   2120           *
   2121           * @param       device - [in] ZDSecMgrDevice_t, device info
   2122           *
   2123           * @return      ZStatus_t
   2124           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2125          ZStatus_t ZDSecMgrDeviceNew( ZDSecMgrDevice_t* joiner )
   \                     ZDSecMgrDeviceNew:
   2126          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2127            ZStatus_t status;
   2128          
   2129            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2130            {
   2131              // try to join this device
   2132              status = ZDSecMgrDeviceJoinDirect( joiner );
   2133            }
   2134            else
   2135            {
   2136              status = ZDSecMgrDeviceJoinFwd( joiner );
   2137            }
   2138          
   2139            return status;
   \   000004                ; Setup parameters for call to function ZDSecMgrDeviceJoinDirect
   \   000004   12....       LCALL     `??ZDSecMgrDeviceJoinDirect::?relay`; Banked call to: ZDSecMgrDeviceJoinDirect
   \   000007   80..         SJMP      ??Subroutine86_0
   2140          }
   2141          
   2142          /******************************************************************************
   2143           * @fn          ZDSecMgrAssocDeviceAuth
   2144           *
   2145           * @brief       Set associated device status to authenticated
   2146           *
   2147           * @param       assoc - [in, out] associated_devices_t
   2148           *
   2149           * @return      none
   2150           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2151          void ZDSecMgrAssocDeviceAuth( associated_devices_t* assoc )
   \                     ZDSecMgrAssocDeviceAuth:
   2152          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2153            if ( assoc != NULL )
   \   000004   EA           MOV       A,R2
   \   000005   4B           ORL       A,R3
   \   000006   600D         JZ        ??ZDSecMgrAssocDeviceAuth_0
   2154            {
   2155              assoc->devStatus |= DEV_SEC_AUTH_STATUS;
   \   000008   8A82         MOV       DPL,R2
   \   00000A   8B83         MOV       DPH,R3
   \   00000C   A3           INC       DPTR
   \   00000D   A3           INC       DPTR
   \   00000E   A3           INC       DPTR
   \   00000F   A3           INC       DPTR
   \   000010   A3           INC       DPTR
   \   000011   E0           MOVX      A,@DPTR
   \   000012   D2E3         SETB      0xE0 /* A   */.3
   \   000014   F0           MOVX      @DPTR,A
   2156            }
   2157          }
   \                     ??ZDSecMgrAssocDeviceAuth_0:
   \   000015   80..         SJMP      ??Subroutine86_0
   2158          
   2159          /******************************************************************************
   2160           * @fn          ZDSecMgrAuthInitiate
   2161           *
   2162           * @brief       Initiate entity authentication
   2163           *
   2164           * @param       responder - [in] responder EXT address
   2165           *
   2166           * @return      none
   2167           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2168          void ZDSecMgrAuthInitiate( uint8* responder )
   \                     ZDSecMgrAuthInitiate:
   2169          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 7
   \   000005   74F9         MOV       A,#-0x7
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   2170            APSME_AuthenticateReq_t req;
   2171          
   2172          
   2173            // make sure NWK address is available
   2174            if ( APSME_LookupNwkAddr( responder, &req.nwkAddr ) )
   \   00000E                ; Setup parameters for call to function APSME_LookupNwkAddr
   \   00000E   AC..         MOV       R4,?XSP + 0
   \   000010   AD..         MOV       R5,?XSP + 1
   \   000012   12....       LCALL     `??APSME_LookupNwkAddr::?relay`; Banked call to: APSME_LookupNwkAddr
   \   000015   E9           MOV       A,R1
   \   000016   601F         JZ        ??ZDSecMgrAuthInitiate_0
   2175            {
   2176              // set request fields
   2177              req.extAddr   = responder;
   \   000018   7402         MOV       A,#0x2
   \   00001A   12....       LCALL     ?XSTACK_DISP0_8
   \   00001D   EE           MOV       A,R6
   \   00001E   F0           MOVX      @DPTR,A
   \   00001F   A3           INC       DPTR
   \   000020   EF           MOV       A,R7
   \   000021   F0           MOVX      @DPTR,A
   2178              req.action    = APSME_EA_INITIATE;
   \   000022   7406         MOV       A,#0x6
   \   000024   12....       LCALL     ?XSTACK_DISP0_8
   \   000027   E4           CLR       A
   \   000028   F0           MOVX      @DPTR,A
   2179              req.challenge = NULL;
   \   000029   7404         MOV       A,#0x4
   \   00002B   12....       LCALL     ?XSTACK_DISP0_8
   \   00002E   E4           CLR       A
   \   00002F   F0           MOVX      @DPTR,A
   \   000030   A3           INC       DPTR
   \   000031   12....       LCALL     ??Subroutine90_0 & 0xFFFF
   2180          
   2181              // start EA processing
   2182              APSME_AuthenticateReq( &req );
   2183            }
   \                     ??CrossCallReturnLabel_144:
   \   000034   12....       LCALL     `??APSME_AuthenticateReq::?relay`; Banked call to: APSME_AuthenticateReq
   2184          }
   \                     ??ZDSecMgrAuthInitiate_0:
   \   000037   7407         MOV       A,#0x7
   \   000039   80..         SJMP      ??Subroutine88_0
   2185          
   2186          /******************************************************************************
   2187           * @fn          ZDSecMgrAuthNwkKey
   2188           *
   2189           * @brief       Handle next step in authentication process
   2190           *
   2191           * @param       none
   2192           *
   2193           * @return      none
   2194           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2195          void ZDSecMgrAuthNwkKey()
   \                     ZDSecMgrAuthNwkKey:
   2196          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2197            if ( devState == DEV_END_DEVICE_UNAUTH )
   \   000004   90....       MOV       DPTR,#devState
   \   000007   E0           MOVX      A,@DPTR
   \   000008   6405         XRL       A,#0x5
   \   00000A   700C         JNZ       ??ZDSecMgrAuthNwkKey_0
   2198            {
   2199              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2200              {
   2201                uint8 parent[Z_EXTADDR_LEN];
   2202          
   2203                // get parent's EXT address
   2204                NLME_GetCoordExtAddr( parent );
   2205          
   2206                // begin entity authentication with parent
   2207                ZDSecMgrAuthInitiate( parent );
   2208              }
   2209              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   2210              {
   2211                // inform ZDO that device has been authenticated
   2212                osal_set_event ( ZDAppTaskID, ZDO_DEVICE_AUTH );
   \   00000C                ; Setup parameters for call to function osal_set_event
   \   00000C   7A80         MOV       R2,#-0x80
   \   00000E   7B00         MOV       R3,#0x0
   \   000010   90....       MOV       DPTR,#ZDAppTaskID
   \   000013   E0           MOVX      A,@DPTR
   \   000014   F9           MOV       R1,A
   \   000015   12....       LCALL     `??osal_set_event::?relay`; Banked call to: osal_set_event
   2213              }
   2214            }
   2215          }
   \                     ??ZDSecMgrAuthNwkKey_0:
   \   000018   02....       LJMP      ??Subroutine86_0 & 0xFFFF
   2216          
   2217          /******************************************************************************
   2218           * PUBLIC FUNCTIONS
   2219           */
   2220          /******************************************************************************
   2221           * @fn          ZDSecMgrInit
   2222           *
   2223           * @brief       Initialize ZigBee Device Security Manager.
   2224           *
   2225           * @param       none
   2226           *
   2227           * @return      none
   2228           */
   2229          #if ( ADDRMGR_CALLBACK_ENABLED == 1 )
   2230          void ZDSecMgrAddrMgrCB( uint8 update, AddrMgrEntry_t* newEntry, AddrMgrEntry_t* oldEntry );
   2231          void ZDSecMgrAddrMgrCB( uint8           update,
   2232                                  AddrMgrEntry_t* newEntry,
   2233                                  AddrMgrEntry_t* oldEntry )
   2234          {
   2235            (void)update;
   2236            (void)newEntry;
   2237            (void)oldEntry;
   2238          }
   2239          #endif // ( ADDRMGR_CALLBACK_ENABLED == 1 )
   2240          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004                ; Setup parameters for call to function APSME_SecurityNM
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004                ; Setup parameters for call to function APSME_SecurityNM
   \   000004   12....       LCALL     `??APSME_SecurityNM::?relay`; Banked call to: APSME_SecurityNM
   \   000007                REQUIRE ??Subroutine86_0
   \   000007                ; // Fall through to label ??Subroutine86_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2241          void ZDSecMgrInit( void )
   \                     ZDSecMgrInit:
   \   000000   02....       LJMP      ?Subroutine0 & 0xFFFF
   2242          {
   2243            if ( (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH)
   2244                || (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD) )
   2245            {
   2246              // initialize sub modules
   2247              ZDSecMgrMasterKeyInit();
   2248              ZDSecMgrEntryInit();
   2249          
   2250              if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2251              {
   2252                ZDSecMgrCtrlInit();
   2253              }
   2254          
   2255              // register with Address Manager
   2256              #if ( ADDRMGR_CALLBACK_ENABLED == 1 )
   2257              AddrMgrRegister( ADDRMGR_REG_SECURITY, ZDSecMgrAddrMgrCB );
   2258              #endif
   2259            }
   2260          
   2261            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2262            {
   2263              // configure SKA slot data
   2264              APSME_SKA_SlotInit( ZDSECMGR_SKA_SLOT_MAX );
   2265            }
   2266            else if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD )
   2267            {
   2268              // Setup the preconfig Trust Center Link Key
   2269              TrustCenterLinkKey.key = zgPreConfigTCLinkKey;
   2270              TrustCenterLinkKey.txFrmCntr = 0;
   2271              TrustCenterLinkKey.rxFrmCntr = 0;
   2272          #if defined ( NV_RESTORE )
   2273              if ( osal_nv_item_init( ZCD_NV_SECURE_TCLINKKEY_TXFRAME, sizeof(uint32), &(TrustCenterLinkKey.txFrmCntr) ) == ZSUCCESS )
   2274              {
   2275                osal_nv_read( ZCD_NV_SECURE_TCLINKKEY_TXFRAME, 0, sizeof(uint32), &(TrustCenterLinkKey.txFrmCntr) );
   2276              }
   2277              if ( osal_nv_item_init( ZCD_NV_SECURE_TCLINKKEY_RXFRAME, sizeof(uint32), &(TrustCenterLinkKey.rxFrmCntr) ) == ZSUCCESS )
   2278              {
   2279                osal_nv_read( ZCD_NV_SECURE_TCLINKKEY_RXFRAME, 0, sizeof(uint32), &(TrustCenterLinkKey.rxFrmCntr) );
   2280              }
   2281          #endif
   2282              APSME_TCLinkKeySetup( 0x0000, &TrustCenterLinkKey );
   2283            }
   2284          
   2285            if ( ZG_SECURE_ENABLED )
   2286            {
   2287              if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2288              {
   2289                // setup joining permissions
   2290                ZDSecMgrPermitJoiningEnabled = TRUE;
   2291                ZDSecMgrPermitJoiningTimed   = FALSE;
   2292              }
   2293            }
   2294          
   2295            // configure security based on security mode and type of device
   2296            ZDSecMgrConfig();
   2297          }
   2298          
   2299          /******************************************************************************
   2300           * @fn          ZDSecMgrConfig
   2301           *
   2302           * @brief       Configure ZigBee Device Security Manager.
   2303           *
   2304           * @param       none
   2305           *
   2306           * @return      none
   2307           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2308          void ZDSecMgrConfig( void )
   \                     ZDSecMgrConfig:
   \   000000   02....       LJMP      ?Subroutine0 & 0xFFFF
   2309          {
   2310            if ( ZG_SECURE_ENABLED )
   2311            {
   2312              SSP_Init();
   2313          
   2314              if ( (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH)
   2315                  || (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD) )
   2316              {
   2317                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2318                {
   2319                  // COMMERCIAL MODE - COORDINATOR DEVICE
   2320                  APSME_SecurityCM_CD();
   2321                }
   2322                else if ( ZSTACK_ROUTER_BUILD )
   2323                {
   2324                  // COMMERCIAL MODE - ROUTER DEVICE
   2325                  APSME_SecurityCM_RD();
   2326                }
   2327                else
   2328                {
   2329                  // COMMERCIAL MODE - END DEVICE
   2330                  APSME_SecurityCM_ED();
   2331                }
   2332              }
   2333              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   2334              {
   2335                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2336                {
   2337                  // RESIDENTIAL MODE - COORDINATOR DEVICE
   2338                  APSME_SecurityRM_CD();
   2339                }
   2340                else if ( ZSTACK_ROUTER_BUILD )
   2341                {
   2342                  // RESIDENTIAL MODE - ROUTER DEVICE
   2343                  APSME_SecurityRM_RD();
   2344                }
   2345                else
   2346                {
   2347                  // RESIDENTIAL MODE - END DEVICE
   2348                  APSME_SecurityRM_ED();
   2349                }
   2350              }
   2351            }
   2352            else
   2353            {
   2354              // NO SECURITY
   2355              APSME_SecurityNM();
   2356            }
   2357          }
   2358          
   2359          /******************************************************************************
   2360           * @fn          ZDSecMgrPermitJoining
   2361           *
   2362           * @brief       Process request to change joining permissions.
   2363           *
   2364           * @param       duration - [in] timed duration for join in seconds
   2365           *                         - 0x00 not allowed
   2366           *                         - 0xFF allowed without timeout
   2367           *
   2368           * @return      uint8 - success(TRUE:FALSE)
   2369           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2370          uint8 ZDSecMgrPermitJoining( uint8 duration )
   \                     ZDSecMgrPermitJoining:
   2371          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV       A,R1
   \   000005   F8           MOV       R0,A
   2372            uint8 accept;
   2373          
   2374          
   2375            ZDSecMgrPermitJoiningTimed = FALSE;
   \   000006   90....       MOV       DPTR,#ZDSecMgrPermitJoiningTimed
   \   000009   E4           CLR       A
   \   00000A   F0           MOVX      @DPTR,A
   2376          
   2377            if ( duration > 0 )
   \   00000B   E9           MOV       A,R1
   \   00000C   90....       MOV       DPTR,#ZDSecMgrPermitJoiningEnabled
   \   00000F   600F         JZ        ??ZDSecMgrPermitJoining_0
   2378            {
   2379              ZDSecMgrPermitJoiningEnabled = TRUE;
   \   000011   7401         MOV       A,#0x1
   \   000013   F0           MOVX      @DPTR,A
   2380          
   2381              if ( duration != 0xFF )
   \   000014   74FF         MOV       A,#-0x1
   \   000016   68           XRL       A,R0
   \   000017   6009         JZ        ??ZDSecMgrPermitJoining_1
   2382              {
   2383                ZDSecMgrPermitJoiningTimed = TRUE;
   \   000019   90....       MOV       DPTR,#ZDSecMgrPermitJoiningTimed
   \   00001C   7401         MOV       A,#0x1
   \   00001E   8001         SJMP      ??ZDSecMgrPermitJoining_2
   2384              }
   2385            }
   2386            else
   2387            {
   2388              ZDSecMgrPermitJoiningEnabled = FALSE;
   \                     ??ZDSecMgrPermitJoining_0:
   \   000020   E4           CLR       A
   \                     ??ZDSecMgrPermitJoining_2:
   \   000021   F0           MOVX      @DPTR,A
   2389            }
   2390          
   2391            accept = TRUE;
   2392          
   2393            return accept;
   \                     ??ZDSecMgrPermitJoining_1:
   \   000022   7901         MOV       R1,#0x1
   \   000024   02....       LJMP      ??Subroutine86_0 & 0xFFFF
   2394          }
   2395          
   2396          /******************************************************************************
   2397           * @fn          ZDSecMgrPermitJoiningTimeout
   2398           *
   2399           * @brief       Process permit joining timeout
   2400           *
   2401           * @param       none
   2402           *
   2403           * @return      none
   2404           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2405          void ZDSecMgrPermitJoiningTimeout( void )
   \                     ZDSecMgrPermitJoiningTimeout:
   2406          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2407            if ( ZDSecMgrPermitJoiningTimed == TRUE )
   \   000004   90....       MOV       DPTR,#ZDSecMgrPermitJoiningTimed
   \   000007   E0           MOVX      A,@DPTR
   \   000008   6401         XRL       A,#0x1
   \   00000A   7009         JNZ       ??ZDSecMgrPermitJoiningTimeout_0
   2408            {
   2409              ZDSecMgrPermitJoiningEnabled = FALSE;
   \   00000C   90....       MOV       DPTR,#ZDSecMgrPermitJoiningEnabled
   \   00000F   E4           CLR       A
   \   000010   F0           MOVX      @DPTR,A
   2410              ZDSecMgrPermitJoiningTimed   = FALSE;
   \   000011   90....       MOV       DPTR,#ZDSecMgrPermitJoiningTimed
   \   000014   F0           MOVX      @DPTR,A
   2411            }
   2412          }
   \                     ??ZDSecMgrPermitJoiningTimeout_0:
   \   000015   02....       LJMP      ??Subroutine86_0 & 0xFFFF
   2413          
   2414          /******************************************************************************
   2415           * @fn          ZDSecMgrNewDeviceEvent
   2416           *
   2417           * @brief       Process a the new device event, if found reset new device
   2418           *              event/timer.
   2419           *
   2420           * @param       none
   2421           *
   2422           * @return      uint8 - found(TRUE:FALSE)
   2423           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2424          uint8 ZDSecMgrNewDeviceEvent( void )
   \                     ZDSecMgrNewDeviceEvent:
   2425          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 23
   \   000005   74E9         MOV       A,#-0x17
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   2426            uint8                 found;
   2427            ZDSecMgrDevice_t      device;
   2428            AddrMgrEntry_t        addrEntry;
   2429            associated_devices_t* assoc;
   2430            ZStatus_t             status;
   2431          
   2432            // initialize return results
   2433            found = FALSE;
   \   00000A   75..00       MOV       ?V0,#0x0
   2434          
   2435            // look for device in the security init state
   2436            assoc = AssocMatchDeviceStatus( DEV_SEC_INIT_STATUS );
   \   00000D                ; Setup parameters for call to function AssocMatchDeviceStatus
   \   00000D   7904         MOV       R1,#0x4
   \   00000F   12....       LCALL     `??AssocMatchDeviceStatus::?relay`; Banked call to: AssocMatchDeviceStatus
   \   000012   8A..         MOV       ?V2,R2
   \   000014   8B..         MOV       ?V3,R3
   \   000016   AE..         MOV       R6,?V2
   \   000018   AF..         MOV       R7,?V3
   2437          
   2438            if ( assoc != NULL )
   \   00001A   EA           MOV       A,R2
   \   00001B   4F           ORL       A,R7
   \   00001C   7003         JNZ       $+5
   \   00001E   02....       LJMP      ??ZDSecMgrNewDeviceEvent_0 & 0xFFFF
   2439            {
   2440              // device found
   2441              found = TRUE;
   \   000021   75..01       MOV       ?V0,#0x1
   2442          
   2443              // check for preconfigured security
   2444              if ( zgPreConfigKeys == TRUE )
   \   000024   90....       MOV       DPTR,#zgPreConfigKeys
   \   000027   E0           MOVX      A,@DPTR
   \   000028   6401         XRL       A,#0x1
   \   00002A   7003         JNZ       ??ZDSecMgrNewDeviceEvent_1
   2445              {
   2446                // set association status to authenticated
   2447                ZDSecMgrAssocDeviceAuth( assoc );
   \   00002C                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   00002C   12....       LCALL     `??ZDSecMgrAssocDeviceAuth::?relay`; Banked call to: ZDSecMgrAssocDeviceAuth
   2448              }
   2449          
   2450              // set up device info
   2451              addrEntry.user  = ADDRMGR_USER_DEFAULT;
   \                     ??ZDSecMgrNewDeviceEvent_1:
   \   00002F   740A         MOV       A,#0xa
   \   000031   12....       LCALL     ?XSTACK_DISP0_8
   \   000034   E4           CLR       A
   \   000035   F0           MOVX      @DPTR,A
   2452              addrEntry.index = assoc->addrIdx;
   \   000036   8E82         MOV       DPL,R6
   \   000038   8F83         MOV       DPH,R7
   \   00003A   12....       LCALL     ??Subroutine98_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_205:
   \   00003D   7415         MOV       A,#0x15
   \   00003F   12....       LCALL     ?XSTACK_DISP0_8
   \   000042   12....       LCALL     ??Subroutine95_0 & 0xFFFF
   2453              AddrMgrEntryGet( &addrEntry );
   \                     ??CrossCallReturnLabel_180:
   \   000045   12....       LCALL     ?XSTACK_DISP101_8
   \   000048   12....       LCALL     `??AddrMgrEntryGet::?relay`; Banked call to: AddrMgrEntryGet
   2454          
   2455              device.nwkAddr    = assoc->shortAddr;
   \   00004B   8E82         MOV       DPL,R6
   \   00004D   8F83         MOV       DPH,R7
   \   00004F   12....       LCALL     ?Subroutine31 & 0xFFFF
   2456              device.extAddr    = addrEntry.extAddr;
   \                     ??CrossCallReturnLabel_160:
   \   000052   740D         MOV       A,#0xd
   \   000054   12....       LCALL     ?XSTACK_DISP0_8
   \   000057   A882         MOV       R0,DPL
   \   000059   A983         MOV       R1,DPH
   \   00005B   7402         MOV       A,#0x2
   \   00005D   12....       LCALL     ?XSTACK_DISP0_8
   \   000060   12....       LCALL     ??Subroutine91_0 & 0xFFFF
   2457              device.parentAddr = NLME_GetShortAddr();
   \                     ??CrossCallReturnLabel_156:
   \   000063                ; Setup parameters for call to function NLME_GetShortAddr
   \   000063   12....       LCALL     `??NLME_GetShortAddr::?relay`; Banked call to: NLME_GetShortAddr
   \   000066   7404         MOV       A,#0x4
   \   000068   12....       LCALL     ?XSTACK_DISP0_8
   \   00006B   12....       LCALL     ?Subroutine35 & 0xFFFF
   2458              device.secure     = FALSE;
   \                     ??CrossCallReturnLabel_33:
   \   00006E   7406         MOV       A,#0x6
   \   000070   12....       LCALL     ?XSTACK_DISP0_8
   \   000073   E4           CLR       A
   \   000074   F0           MOVX      @DPTR,A
   2459              device.devStatus  = assoc->devStatus;
   \   000075   EE           MOV       A,R6
   \   000076   2405         ADD       A,#0x5
   \   000078   FE           MOV       R6,A
   \   000079   5001         JNC       ??ZDSecMgrNewDeviceEvent_2
   \   00007B   0F           INC       R7
   \                     ??ZDSecMgrNewDeviceEvent_2:
   \   00007C   F582         MOV       DPL,A
   \   00007E   8F83         MOV       DPH,R7
   \   000080   E0           MOVX      A,@DPTR
   \   000081   C0E0         PUSH      A
   \   000083   7407         MOV       A,#0x7
   \   000085   12....       LCALL     ?XSTACK_DISP0_8
   \   000088   D0E0         POP       A
   \   00008A   12....       LCALL     ??Subroutine90_0 & 0xFFFF
   2460          
   2461              // process new device
   2462              status = ZDSecMgrDeviceNew( &device );
   \                     ??CrossCallReturnLabel_145:
   \   00008D   12....       LCALL     `??ZDSecMgrDeviceNew::?relay`; Banked call to: ZDSecMgrDeviceNew
   \   000090   E9           MOV       A,R1
   \   000091   F8           MOV       R0,A
   2463          
   2464              if ( status == ZSuccess )
   \   000092   700A         JNZ       ??ZDSecMgrNewDeviceEvent_3
   2465              {
   2466                assoc->devStatus &= ~DEV_SEC_INIT_STATUS;
   \   000094   8E82         MOV       DPL,R6
   \   000096   8F83         MOV       DPH,R7
   \   000098   E0           MOVX      A,@DPTR
   \   000099   C2E2         CLR       0xE0 /* A   */.2
   \   00009B   F0           MOVX      @DPTR,A
   \   00009C   8011         SJMP      ??ZDSecMgrNewDeviceEvent_0
   2467              }
   2468              else if ( status == ZNwkUnknownDevice )
   \                     ??ZDSecMgrNewDeviceEvent_3:
   \   00009E   74C8         MOV       A,#-0x38
   \   0000A0   68           XRL       A,R0
   \   0000A1   700C         JNZ       ??ZDSecMgrNewDeviceEvent_0
   2469              {
   2470                AssocRemove( addrEntry.extAddr );
   \   0000A3                ; Setup parameters for call to function AssocRemove
   \   0000A3   740D         MOV       A,#0xd
   \   0000A5   12....       LCALL     ?XSTACK_DISP0_8
   \   0000A8   AA82         MOV       R2,DPL
   \   0000AA   AB83         MOV       R3,DPH
   \   0000AC   12....       LCALL     `??AssocRemove::?relay`; Banked call to: AssocRemove
   2471              }
   2472            }
   2473          
   2474            return found;
   \                     ??ZDSecMgrNewDeviceEvent_0:
   \   0000AF   A9..         MOV       R1,?V0
   \   0000B1   7417         MOV       A,#0x17
   \   0000B3   02....       LJMP      ??Subroutine82_0 & 0xFFFF
   2475          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine31:
   \   000000   12....       LCALL     ?Subroutine70 & 0xFFFF
   \                     ??CrossCallReturnLabel_99:
   \   000003                REQUIRE ??Subroutine91_0
   \   000003                ; // Fall through to label ??Subroutine91_0
   2476          
   2477          /******************************************************************************
   2478           * @fn          ZDSecMgrEvent
   2479           *
   2480           * @brief       Handle ZDO Security Manager event/timer(ZDO_SECMGR_EVENT).
   2481           *
   2482           * @param       none
   2483           *
   2484           * @return      none
   2485           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2486          void ZDSecMgrEvent( void )
   \                     ZDSecMgrEvent:
   2487          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 23
   \   000005   74E9         MOV       A,#-0x17
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   2488            uint8            action;
   2489            uint8            restart;
   2490            uint16           index;
   2491            AddrMgrEntry_t   entry;
   2492            ZDSecMgrDevice_t device;
   2493          
   2494          
   2495            // verify data is available
   2496            if ( ZDSecMgrCtrlData != NULL )
   \   00000A   90....       MOV       DPTR,#ZDSecMgrCtrlData
   \   00000D   12....       LCALL     ??Subroutine94_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_172:
   \   000010   7003         JNZ       $+5
   \   000012   02....       LJMP      ??ZDSecMgrEvent_0 & 0xFFFF
   2497            {
   2498              action  = FALSE;
   \   000015   75..00       MOV       ?V1,#0x0
   2499              restart = FALSE;
   \   000018   75..00       MOV       ?V0,#0x0
   2500          
   2501              // update all the counters
   2502              for ( index = 0; index < ZDSECMGR_ENTRY_MAX; index++ )
   \   00001B   7E00         MOV       R6,#0x0
   \   00001D   7F00         MOV       R7,#0x0
   2503              {
   2504                if ( ZDSecMgrCtrlData[index].state !=  ZDSECMGR_CTRL_NONE )
   \                     ??ZDSecMgrEvent_1:
   \   00001F   EE           MOV       A,R6
   \   000020   F8           MOV       R0,A
   \   000021   EF           MOV       A,R7
   \   000022   F9           MOV       R1,A
   \   000023   E8           MOV       A,R0
   \   000024   75F007       MOV       B,#0x7
   \   000027   A4           MUL       AB
   \   000028   F8           MOV       R0,A
   \   000029   AAF0         MOV       R2,B
   \   00002B   75F007       MOV       B,#0x7
   \   00002E   E9           MOV       A,R1
   \   00002F   A4           MUL       AB
   \   000030   2A           ADD       A,R2
   \   000031   F9           MOV       R1,A
   \   000032   90....       MOV       DPTR,#ZDSecMgrCtrlData
   \   000035   E0           MOVX      A,@DPTR
   \   000036   28           ADD       A,R0
   \   000037   FA           MOV       R2,A
   \   000038   A3           INC       DPTR
   \   000039   E0           MOVX      A,@DPTR
   \   00003A   39           ADDC      A,R1
   \   00003B   FB           MOV       R3,A
   \   00003C   8A82         MOV       DPL,R2
   \   00003E   F583         MOV       DPH,A
   \   000040   A3           INC       DPTR
   \   000041   A3           INC       DPTR
   \   000042   A3           INC       DPTR
   \   000043   A3           INC       DPTR
   \   000044   A3           INC       DPTR
   \   000045   E0           MOVX      A,@DPTR
   \   000046   7003         JNZ       $+5
   \   000048   02....       LJMP      ??ZDSecMgrEvent_2 & 0xFFFF
   2505                {
   2506                  if ( ZDSecMgrCtrlData[index].cntr != 0 )
   \   00004B   EA           MOV       A,R2
   \   00004C   2406         ADD       A,#0x6
   \   00004E   F582         MOV       DPL,A
   \   000050   E4           CLR       A
   \   000051   3B           ADDC      A,R3
   \   000052   F583         MOV       DPH,A
   \   000054   E0           MOVX      A,@DPTR
   \   000055   6002         JZ        ??ZDSecMgrEvent_3
   2507                  {
   2508                    ZDSecMgrCtrlData[index].cntr--;
   \   000057   14           DEC       A
   \   000058   F0           MOVX      @DPTR,A
   2509                  }
   2510          
   2511                  if ( ( action == FALSE ) && ( ZDSecMgrCtrlData[index].cntr == 0 ) )
   \                     ??ZDSecMgrEvent_3:
   \   000059   E5..         MOV       A,?V1
   \   00005B   A2E0         MOV       C,0xE0 /* A   */.0
   \   00005D   5003         JNC       $+5
   \   00005F   02....       LJMP      ??ZDSecMgrEvent_4 & 0xFFFF
   \   000062   90....       MOV       DPTR,#ZDSecMgrCtrlData
   \   000065   E0           MOVX      A,@DPTR
   \   000066   28           ADD       A,R0
   \   000067   F8           MOV       R0,A
   \   000068   A3           INC       DPTR
   \   000069   E0           MOVX      A,@DPTR
   \   00006A   39           ADDC      A,R1
   \   00006B   F9           MOV       R1,A
   \   00006C   8882         MOV       DPL,R0
   \   00006E   F583         MOV       DPH,A
   \   000070   A3           INC       DPTR
   \   000071   A3           INC       DPTR
   \   000072   A3           INC       DPTR
   \   000073   A3           INC       DPTR
   \   000074   A3           INC       DPTR
   \   000075   A3           INC       DPTR
   \   000076   E0           MOVX      A,@DPTR
   \   000077   706A         JNZ       ??ZDSecMgrEvent_4
   2512                  {
   2513                    action = TRUE;
   \   000079   75..01       MOV       ?V1,#0x1
   2514          
   2515                    // update from control data
   2516                    device.parentAddr = ZDSecMgrCtrlData[index].parentAddr;
   \   00007C   8882         MOV       DPL,R0
   \   00007E   8983         MOV       DPH,R1
   \   000080   A3           INC       DPTR
   \   000081   A3           INC       DPTR
   \   000082   12....       LCALL     ??Subroutine85_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_133:
   \   000085   7404         MOV       A,#0x4
   \   000087   12....       LCALL     ?XSTACK_DISP0_8
   \   00008A   12....       LCALL     ?Subroutine35 & 0xFFFF
   2517                    device.secure     = ZDSecMgrCtrlData[index].secure;
   \                     ??CrossCallReturnLabel_34:
   \   00008D   8882         MOV       DPL,R0
   \   00008F   8983         MOV       DPH,R1
   \   000091   A3           INC       DPTR
   \   000092   A3           INC       DPTR
   \   000093   A3           INC       DPTR
   \   000094   A3           INC       DPTR
   \   000095   E0           MOVX      A,@DPTR
   \   000096   C0E0         PUSH      A
   \   000098   7406         MOV       A,#0x6
   \   00009A   12....       LCALL     ?XSTACK_DISP0_8
   \   00009D   D0E0         POP       A
   \   00009F   F0           MOVX      @DPTR,A
   2518                    device.ctrl       = &ZDSecMgrCtrlData[index];
   \   0000A0   7408         MOV       A,#0x8
   \   0000A2   12....       LCALL     ?XSTACK_DISP0_8
   \   0000A5   12....       LCALL     ??Subroutine95_0 & 0xFFFF
   2519          
   2520                    // set the user and address index
   2521                    entry.user  = ADDRMGR_USER_SECURITY;
   \                     ??CrossCallReturnLabel_181:
   \   0000A8   12....       LCALL     ?XSTACK_DISP0_8
   \   0000AB   7402         MOV       A,#0x2
   \   0000AD   12....       LCALL     ?Subroutine34 & 0xFFFF
   2522                    entry.index = ZDSecMgrCtrlData[index].entry->ami;
   \                     ??CrossCallReturnLabel_28:
   \   0000B0   F583         MOV       DPH,A
   \   0000B2   8882         MOV       DPL,R0
   \   0000B4   12....       LCALL     ??Subroutine99_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_198:
   \   0000B7   7415         MOV       A,#0x15
   \   0000B9   12....       LCALL     ?XSTACK_DISP0_8
   \   0000BC   12....       LCALL     ??Subroutine95_0 & 0xFFFF
   2523          
   2524                    // get the address data
   2525                    AddrMgrEntryGet( &entry );
   \                     ??CrossCallReturnLabel_182:
   \   0000BF   12....       LCALL     ?XSTACK_DISP101_8
   \   0000C2   12....       LCALL     `??AddrMgrEntryGet::?relay`; Banked call to: AddrMgrEntryGet
   2526          
   2527                    // set device address data
   2528                    device.nwkAddr = entry.nwkAddr;
   \   0000C5   740B         MOV       A,#0xb
   \   0000C7   12....       LCALL     ?XSTACK_DISP0_8
   \   0000CA   12....       LCALL     ?Subroutine31 & 0xFFFF
   2529                    device.extAddr = entry.extAddr;
   \                     ??CrossCallReturnLabel_161:
   \   0000CD   740D         MOV       A,#0xd
   \   0000CF   12....       LCALL     ?XSTACK_DISP0_8
   \   0000D2   A882         MOV       R0,DPL
   \   0000D4   A983         MOV       R1,DPH
   \   0000D6   7402         MOV       A,#0x2
   \   0000D8   12....       LCALL     ?XSTACK_DISP0_8
   \   0000DB   12....       LCALL     ?Subroutine17 & 0xFFFF
   2530          
   2531                    // update from entry data
   2532                    ZDSecMgrDeviceCtrlHandler( &device );
   2533                  }
   \                     ??CrossCallReturnLabel_0:
   \   0000DE   12....       LCALL     `??ZDSecMgrDeviceCtrlHandler::?relay`; Banked call to: ZDSecMgrDeviceCtrlHandler
   \   0000E1   8003         SJMP      ??ZDSecMgrEvent_2
   2534                  else
   2535                  {
   2536                    restart = TRUE;
   \                     ??ZDSecMgrEvent_4:
   \   0000E3   75..01       MOV       ?V0,#0x1
   2537                  }
   2538                }
   2539              }
   \                     ??ZDSecMgrEvent_2:
   \   0000E6   0E           INC       R6
   \   0000E7   EE           MOV       A,R6
   \   0000E8   7001         JNZ       ??ZDSecMgrEvent_5
   \   0000EA   0F           INC       R7
   \                     ??ZDSecMgrEvent_5:
   \   0000EB   C3           CLR       C
   \   0000EC   9403         SUBB      A,#0x3
   \   0000EE   EF           MOV       A,R7
   \   0000EF   9400         SUBB      A,#0x0
   \   0000F1   5003         JNC       $+5
   \   0000F3   02....       LJMP      ??ZDSecMgrEvent_1 & 0xFFFF
   2540          
   2541              // check for timer restart
   2542              if ( restart == TRUE )
   \   0000F6   E5..         MOV       A,?V0
   \   0000F8   A2E0         MOV       C,0xE0 /* A   */.0
   \   0000FA   5010         JNC       ??ZDSecMgrEvent_0
   2543              {
   2544                osal_start_timerEx(ZDAppTaskID, ZDO_SECMGR_EVENT, 100 );
   \   0000FC                ; Setup parameters for call to function osal_start_timerEx
   \   0000FC   7C64         MOV       R4,#0x64
   \   0000FE   7D00         MOV       R5,#0x0
   \   000100   7A00         MOV       R2,#0x0
   \   000102   7B01         MOV       R3,#0x1
   \   000104   90....       MOV       DPTR,#ZDAppTaskID
   \   000107   E0           MOVX      A,@DPTR
   \   000108   F9           MOV       R1,A
   \   000109   12....       LCALL     `??osal_start_timerEx::?relay`; Banked call to: osal_start_timerEx
   2545              }
   2546            }
   2547          }
   \                     ??ZDSecMgrEvent_0:
   \   00010C   7417         MOV       A,#0x17
   \   00010E   02....       LJMP      ??Subroutine101_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   12....       LCALL     ??Subroutine97_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_186:
   \   000003                ; Setup parameters for call to function ZDSecMgrDeviceCtrlHandler
   \   000003                ; Setup parameters for call to function ZDSecMgrDeviceJoin
   \   000003                ; Setup parameters for call to function APSME_AuthenticateReq
   \   000003                ; Setup parameters for call to function ZDSecMgrDeviceRemove
   \   000003   AA..         MOV       R2,?XSP + 0
   \   000005   AB..         MOV       R3,?XSP + 1
   \   000007   22           RET
   2548          
   2549          /******************************************************************************
   2550           * @fn          ZDSecMgrEstablishKeyCfm
   2551           *
   2552           * @brief       Process the ZDO_EstablishKeyCfm_t message.
   2553           *
   2554           * @param       cfm - [in] ZDO_EstablishKeyCfm_t confirmation
   2555           *
   2556           * @return      none
   2557           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2558          void ZDSecMgrEstablishKeyCfm( ZDO_EstablishKeyCfm_t* cfm )
   \                     ZDSecMgrEstablishKeyCfm:
   2559          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2560            // send the NWK key
   2561            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2562            {
   2563              // update control for specified EXT address
   2564              ZDSecMgrDeviceCtrlUpdate( cfm->partExtAddr, ZDSECMGR_CTRL_SKKE_DONE );
   \   000004                ; Setup parameters for call to function ZDSecMgrDeviceCtrlUpdate
   \   000004   7905         MOV       R1,#0x5
   \   000006   EA           MOV       A,R2
   \   000007   2402         ADD       A,#0x2
   \   000009   FA           MOV       R2,A
   \   00000A   5001         JNC       ??ZDSecMgrEstablishKeyCfm_0
   \   00000C   0B           INC       R3
   \                     ??ZDSecMgrEstablishKeyCfm_0:
   \   00000D   12....       LCALL     `??ZDSecMgrDeviceCtrlUpdate::?relay`; Banked call to: ZDSecMgrDeviceCtrlUpdate
   2565            }
   2566            else
   2567            {
   2568              // this should be done when receiving the NWK key
   2569              // if devState ==
   2570              //if ( devState == DEV_END_DEVICE_UNAUTH )
   2571                  //osal_set_event( ZDAppTaskID, ZDO_DEVICE_AUTH );
   2572          
   2573              // if not in joining state -- this should trigger an event for an
   2574              // end point that requested SKKE
   2575              // if ( devState == DEV_END_DEVICE )
   2576             //       devState == DEV_ROUTER;
   2577          
   2578            }
   2579          }
   \   000010   02....       LJMP      ??Subroutine86_0 & 0xFFFF
   2580          
   2581          uint8 ZDSecMgrTCExtAddrCheck( uint8* extAddr );

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2582          uint8 ZDSecMgrTCExtAddrCheck( uint8* extAddr )
   \                     ZDSecMgrTCExtAddrCheck:
   2583          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV       A,#-0x8
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   2584            uint8  match;
   2585            uint8  lookup[Z_EXTADDR_LEN];
   2586          
   2587            match = FALSE;
   \   00000E   75..00       MOV       ?V0,#0x0
   2588          
   2589            if ( AddrMgrExtAddrLookup( APSME_TRUSTCENTER_NWKADDR, lookup ) )
   \   000011                ; Setup parameters for call to function AddrMgrExtAddrLookup
   \   000011   AC..         MOV       R4,?XSP + 0
   \   000013   AD..         MOV       R5,?XSP + 1
   \   000015   7A00         MOV       R2,#0x0
   \   000017   7B00         MOV       R3,#0x0
   \   000019   12....       LCALL     `??AddrMgrExtAddrLookup::?relay`; Banked call to: AddrMgrExtAddrLookup
   \   00001C   E9           MOV       A,R1
   \   00001D   600E         JZ        ??ZDSecMgrTCExtAddrCheck_0
   2590            {
   2591              match = AddrMgrExtAddrEqual( lookup, extAddr );
   \   00001F                ; Setup parameters for call to function AddrMgrExtAddrEqual
   \   00001F   EE           MOV       A,R6
   \   000020   FC           MOV       R4,A
   \   000021   EF           MOV       A,R7
   \   000022   FD           MOV       R5,A
   \   000023   AA..         MOV       R2,?XSP + 0
   \   000025   AB..         MOV       R3,?XSP + 1
   \   000027   12....       LCALL     `??AddrMgrExtAddrEqual::?relay`; Banked call to: AddrMgrExtAddrEqual
   \   00002A   E9           MOV       A,R1
   \   00002B   F5..         MOV       ?V0,A
   2592            }
   2593          
   2594            return match;
   \                     ??ZDSecMgrTCExtAddrCheck_0:
   \   00002D   A9..         MOV       R1,?V0
   \   00002F   7408         MOV       A,#0x8
   \   000031   02....       LJMP      ??Subroutine88_0 & 0xFFFF
   2595          }
   2596          
   2597          void ZDSecMgrTCDataLoad( uint8* extAddr );

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2598          void ZDSecMgrTCDataLoad( uint8* extAddr )
   \                     ZDSecMgrTCDataLoad:
   2599          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV       A,#-0x4
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   2600            uint16 ami;
   2601            uint8* key;
   2602          
   2603            if ( !ZDSecMgrTCDataLoaded )
   \   00000A   90....       MOV       DPTR,#ZDSecMgrTCDataLoaded
   \   00000D   E0           MOVX      A,@DPTR
   \   00000E   703F         JNZ       ??ZDSecMgrTCDataLoad_0
   2604            {
   2605              if ( ZDSecMgrAddrStore( APSME_TRUSTCENTER_NWKADDR, extAddr, &ami ) == ZSuccess )
   \   000010                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   000010   A8..         MOV       R0,?XSP + 0
   \   000012   A9..         MOV       R1,?XSP + 1
   \   000014   88..         MOV       ?V0,R0
   \   000016   89..         MOV       ?V1,R1
   \   000018   78..         MOV       R0,#?V0
   \   00001A   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00001D   EA           MOV       A,R2
   \   00001E   FC           MOV       R4,A
   \   00001F   EB           MOV       A,R3
   \   000020   FD           MOV       R5,A
   \   000021   7A00         MOV       R2,#0x0
   \   000023   7B00         MOV       R3,#0x0
   \   000025   12....       LCALL     `??ZDSecMgrAddrStore::?relay`; Banked call to: ZDSecMgrAddrStore
   \   000028   7402         MOV       A,#0x2
   \   00002A   12....       LCALL     ?DEALLOC_XSTACK8
   \   00002D   E9           MOV       A,R1
   \   00002E   7019         JNZ       ??CrossCallReturnLabel_66
   2606              {
   2607                // if preconfigured load key
   2608                if ( zgPreConfigKeys == TRUE )
   \   000030   90....       MOV       DPTR,#zgPreConfigKeys
   \   000033   E0           MOVX      A,@DPTR
   \   000034   6401         XRL       A,#0x1
   \   000036   7011         JNZ       ??CrossCallReturnLabel_66
   2609                {
   2610                  if ( ZDSecMgrMasterKeyLookup( ami, &key ) != ZSuccess )
   \   000038                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   000038   7402         MOV       A,#0x2
   \   00003A   12....       LCALL     ?XSTACK_DISP102_8
   \   00003D   12....       LCALL     ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_47:
   \   000040   6007         JZ        ??CrossCallReturnLabel_66
   2611                  {
   2612                    ZDSecMgrMasterKeyStore( ami, ZDSecMgrTCMasterKey );
   \   000042                ; Setup parameters for call to function ZDSecMgrMasterKeyStore
   \   000042   7C..         MOV       R4,#ZDSecMgrTCMasterKey & 0xff
   \   000044   7D..         MOV       R5,#(ZDSecMgrTCMasterKey >> 8) & 0xff
   \   000046   12....       LCALL     ?Subroutine53 & 0xFFFF
   2613                  }
   2614                }
   2615              }
   2616          
   2617              ZDSecMgrTCDataLoaded = TRUE;
   \                     ??CrossCallReturnLabel_66:
   \   000049   90....       MOV       DPTR,#ZDSecMgrTCDataLoaded
   \   00004C   7401         MOV       A,#0x1
   \   00004E   F0           MOVX      @DPTR,A
   2618            }
   2619          }
   \                     ??ZDSecMgrTCDataLoad_0:
   \   00004F                REQUIRE ?Subroutine13
   \   00004F                ; // Fall through to label ?Subroutine13

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   7404         MOV       A,#0x4
   \   000002   02....       LJMP      ??Subroutine101_0 & 0xFFFF
   2620          
   2621          /******************************************************************************
   2622           * @fn          ZDSecMgrEstablishKeyInd
   2623           *
   2624           * @brief       Process the ZDO_EstablishKeyInd_t message.
   2625           *
   2626           * @param       ind - [in] ZDO_EstablishKeyInd_t indication
   2627           *
   2628           * @return      none
   2629           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2630          void ZDSecMgrEstablishKeyInd( ZDO_EstablishKeyInd_t* ind )
   \                     ZDSecMgrEstablishKeyInd:
   2631          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV       A,#-0xe
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 17
   \   000005   74EF         MOV       A,#-0x11
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V0,R2
   \   00000C   8B..         MOV       ?V1,R3
   2632            ZDSecMgrDevice_t        device;
   2633            APSME_EstablishKeyRsp_t rsp;
   2634          
   2635          
   2636            // load Trust Center data if needed
   2637            ZDSecMgrTCDataLoad( ind->initExtAddr );
   \   00000E   EA           MOV       A,R2
   \   00000F   2404         ADD       A,#0x4
   \   000011   FE           MOV       R6,A
   \   000012   E4           CLR       A
   \   000013   35..         ADDC      A,?V1
   \   000015   FF           MOV       R7,A
   \   000016                ; Setup parameters for call to function ZDSecMgrTCDataLoad
   \   000016   EE           MOV       A,R6
   \   000017   FA           MOV       R2,A
   \   000018   EF           MOV       A,R7
   \   000019   FB           MOV       R3,A
   \   00001A   12....       LCALL     `??ZDSecMgrTCDataLoad::?relay`; Banked call to: ZDSecMgrTCDataLoad
   2638          
   2639            if ( ZDSecMgrTCExtAddrCheck( ind->initExtAddr ) )
   \   00001D   E5..         MOV       A,?V0
   \   00001F   2402         ADD       A,#0x2
   \   000021   F5..         MOV       ?V2,A
   \   000023   E4           CLR       A
   \   000024   35..         ADDC      A,?V1
   \   000026   F5..         MOV       ?V3,A
   \   000028                ; Setup parameters for call to function ZDSecMgrTCExtAddrCheck
   \   000028   EE           MOV       A,R6
   \   000029   FA           MOV       R2,A
   \   00002A   EF           MOV       A,R7
   \   00002B   FB           MOV       R3,A
   \   00002C   12....       LCALL     `??ZDSecMgrTCExtAddrCheck::?relay`; Banked call to: ZDSecMgrTCExtAddrCheck
   \   00002F   E9           MOV       A,R1
   \   000030   6016         JZ        ??ZDSecMgrEstablishKeyInd_0
   2640            {
   2641              //IF (ind->srcAddr == APSME_TRUSTCENTER_NWKADDR)
   2642              //OR
   2643              //!ZDSecMgrTCAuthenticated
   2644              //devtag.0604.critical
   2645                  //how is the parentAddr used here
   2646          
   2647              // initial SKKE from Trust Center via parent
   2648              device.nwkAddr    = APSME_TRUSTCENTER_NWKADDR;
   \   000032   7407         MOV       A,#0x7
   \   000034   12....       LCALL     ?XSTACK_DISP0_8
   \   000037   E4           CLR       A
   \   000038   F0           MOVX      @DPTR,A
   \   000039   A3           INC       DPTR
   \   00003A   12....       LCALL     ?Subroutine22 & 0xFFFF
   2649              device.parentAddr = ind->srcAddr;
   2650            }
   \                     ??CrossCallReturnLabel_8:
   \   00003D   740B         MOV       A,#0xb
   \   00003F   12....       LCALL     ?XSTACK_DISP0_8
   \   000042   E8           MOV       A,R0
   \   000043   F0           MOVX      @DPTR,A
   \   000044   A3           INC       DPTR
   \   000045   E9           MOV       A,R1
   \   000046   801B         SJMP      ??ZDSecMgrEstablishKeyInd_1
   2651            else
   2652            {
   2653              // Trust Center direct or E2E SKKE
   2654              device.nwkAddr    = ind->srcAddr;
   \                     ??ZDSecMgrEstablishKeyInd_0:
   \   000048   85..82       MOV       DPL,?V2
   \   00004B   85..83       MOV       DPH,?V3
   \   00004E   12....       LCALL     ??Subroutine99_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_199:
   \   000051   7407         MOV       A,#0x7
   \   000053   12....       LCALL     ?XSTACK_DISP0_8
   \   000056   12....       LCALL     ??Subroutine91_0 & 0xFFFF
   2655              device.parentAddr = INVALID_NODE_ADDR;
   \                     ??CrossCallReturnLabel_157:
   \   000059   740B         MOV       A,#0xb
   \   00005B   12....       LCALL     ?XSTACK_DISP0_8
   \   00005E   74FE         MOV       A,#-0x2
   \   000060   F0           MOVX      @DPTR,A
   \   000061   A3           INC       DPTR
   \   000062   04           INC       A
   \                     ??ZDSecMgrEstablishKeyInd_1:
   \   000063   F0           MOVX      @DPTR,A
   2656            }
   2657          
   2658            device.extAddr = ind->initExtAddr;
   \   000064   7409         MOV       A,#0x9
   \   000066   12....       LCALL     ?XSTACK_DISP0_8
   \   000069   EE           MOV       A,R6
   \   00006A   F0           MOVX      @DPTR,A
   \   00006B   A3           INC       DPTR
   \   00006C   EF           MOV       A,R7
   \   00006D   F0           MOVX      @DPTR,A
   2659            //devtag.pro.security.0724.todo - verify usage
   2660            device.secure  = ind->nwkSecure;
   \   00006E   E5..         MOV       A,?V0
   \   000070   240E         ADD       A,#0xe
   \   000072   F5..         MOV       ?V4,A
   \   000074   E4           CLR       A
   \   000075   35..         ADDC      A,?V1
   \   000077   F5..         MOV       ?V5,A
   \   000079   85..82       MOV       DPL,?V4
   \   00007C   F583         MOV       DPH,A
   \   00007E   E0           MOVX      A,@DPTR
   \   00007F   C0E0         PUSH      A
   \   000081   740D         MOV       A,#0xd
   \   000083   12....       LCALL     ?XSTACK_DISP0_8
   \   000086   D0E0         POP       A
   \   000088   F0           MOVX      @DPTR,A
   2661          
   2662            // validate device for SKKE
   2663            if ( ZDSecMgrDeviceValidateSKKE( &device ) == ZSuccess )
   \   000089                ; Setup parameters for call to function ZDSecMgrDeviceValidateSKKE
   \   000089   7407         MOV       A,#0x7
   \   00008B   12....       LCALL     ?XSTACK_DISP101_8
   \   00008E   12....       LCALL     `??ZDSecMgrDeviceValidateSKKE::?relay`; Banked call to: ZDSecMgrDeviceValidateSKKE
   \   000091   E9           MOV       A,R1
   \   000092   7009         JNZ       ??ZDSecMgrEstablishKeyInd_2
   2664            {
   2665              rsp.accept = TRUE;
   \   000094   7404         MOV       A,#0x4
   \   000096   12....       LCALL     ?XSTACK_DISP0_8
   \   000099   7401         MOV       A,#0x1
   \   00009B   8006         SJMP      ??ZDSecMgrEstablishKeyInd_3
   2666            }
   2667            else
   2668            {
   2669              rsp.accept = FALSE;
   \                     ??ZDSecMgrEstablishKeyInd_2:
   \   00009D   7404         MOV       A,#0x4
   \   00009F   12....       LCALL     ?XSTACK_DISP0_8
   \   0000A2   E4           CLR       A
   2670            }
   \                     ??ZDSecMgrEstablishKeyInd_3:
   \   0000A3   12....       LCALL     ?Subroutine22 & 0xFFFF
   2671          
   2672            rsp.dstAddr     = ind->srcAddr;
   \                     ??CrossCallReturnLabel_9:
   \   0000A6   12....       LCALL     ?Subroutine30 & 0xFFFF
   2673            rsp.initExtAddr = &ind->initExtAddr[0];
   \                     ??CrossCallReturnLabel_183:
   \   0000A9   12....       LCALL     ?XSTACK_DISP0_8
   \   0000AC   EE           MOV       A,R6
   \   0000AD   F0           MOVX      @DPTR,A
   \   0000AE   A3           INC       DPTR
   \   0000AF   EF           MOV       A,R7
   \   0000B0   F0           MOVX      @DPTR,A
   2674            //devtag.0604.todo - remove obsolete
   2675            rsp.apsSecure   = ind->apsSecure;
   \   0000B1   E5..         MOV       A,?V0
   \   0000B3   240D         ADD       A,#0xd
   \   0000B5   F582         MOV       DPL,A
   \   0000B7   E4           CLR       A
   \   0000B8   35..         ADDC      A,?V1
   \   0000BA   F583         MOV       DPH,A
   \   0000BC   E0           MOVX      A,@DPTR
   \   0000BD   C0E0         PUSH      A
   \   0000BF   7405         MOV       A,#0x5
   \   0000C1   12....       LCALL     ?XSTACK_DISP0_8
   \   0000C4   D0E0         POP       A
   \   0000C6   F0           MOVX      @DPTR,A
   2676            rsp.nwkSecure   = ind->nwkSecure;
   \   0000C7   85..82       MOV       DPL,?V4
   \   0000CA   85..83       MOV       DPH,?V5
   \   0000CD   E0           MOVX      A,@DPTR
   \   0000CE   C0E0         PUSH      A
   \   0000D0   7406         MOV       A,#0x6
   \   0000D2   12....       LCALL     ?XSTACK_DISP0_8
   \   0000D5   D0E0         POP       A
   \   0000D7   12....       LCALL     ??Subroutine90_0 & 0xFFFF
   2677          
   2678            APSME_EstablishKeyRsp( &rsp );
   \                     ??CrossCallReturnLabel_146:
   \   0000DA   12....       LCALL     `??APSME_EstablishKeyRsp::?relay`; Banked call to: APSME_EstablishKeyRsp
   2679          }
   \   0000DD   7411         MOV       A,#0x11
   \   0000DF   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000E2   02....       LJMP      ?Subroutine3 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine30:
   \   000000   85..82       MOV       DPL,?XSP + 0
   \   000003   85..83       MOV       DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine96_0
   \   000006                ; // Fall through to label ??Subroutine96_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   85..82       MOV       DPL,?V2
   \   000004   85..83       MOV       DPH,?V3
   \   000007   12....       LCALL     ?Subroutine71 & 0xFFFF
   \                     ??CrossCallReturnLabel_206:
   \   00000A   22           RET
   2680          //devtag.pro.security
   2681          #if 0
   2682          void ZDSecMgrEstablishKeyInd( ZDO_EstablishKeyInd_t* ind )
   2683          {
   2684            ZDSecMgrDevice_t        device;
   2685            APSME_EstablishKeyRsp_t rsp;
   2686          
   2687          
   2688            device.extAddr = ind->initExtAddr;
   2689            device.secure  = ind->secure;
   2690          
   2691            if ( ind->secure == FALSE )
   2692            {
   2693              // SKKE from Trust Center is not secured between child and parent
   2694              device.nwkAddr    = APSME_TRUSTCENTER_NWKADDR;
   2695              device.parentAddr = ind->srcAddr;
   2696            }
   2697            else
   2698            {
   2699              // SKKE from initiator should be secured
   2700              device.nwkAddr    = ind->srcAddr;
   2701              device.parentAddr = INVALID_NODE_ADDR;
   2702            }
   2703          
   2704            rsp.dstAddr     = ind->srcAddr;
   2705            rsp.initExtAddr = &ind->initExtAddr[0];
   2706            rsp.secure      = ind->secure;
   2707          
   2708            // validate device for SKKE
   2709            if ( ZDSecMgrDeviceValidateSKKE( &device ) == ZSuccess )
   2710            {
   2711              rsp.accept = TRUE;
   2712            }
   2713            else
   2714            {
   2715              rsp.accept = FALSE;
   2716            }
   2717          
   2718            APSME_EstablishKeyRsp( &rsp );
   2719          }
   2720          #endif
   2721          
   2722          /******************************************************************************
   2723           * @fn          ZDSecMgrTransportKeyInd
   2724           *
   2725           * @brief       Process the ZDO_TransportKeyInd_t message.
   2726           *
   2727           * @param       ind - [in] ZDO_TransportKeyInd_t indication
   2728           *
   2729           * @return      none
   2730           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2731          void ZDSecMgrTransportKeyInd( ZDO_TransportKeyInd_t* ind )
   \                     ZDSecMgrTransportKeyInd:
   2732          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
   2733            uint8 index;
   2734          
   2735            // load Trust Center data if needed
   2736            ZDSecMgrTCDataLoad( ind->srcExtAddr );
   \   000009                ; Setup parameters for call to function ZDSecMgrTCDataLoad
   \   000009   EA           MOV       A,R2
   \   00000A   2416         ADD       A,#0x16
   \   00000C   FA           MOV       R2,A
   \   00000D   E4           CLR       A
   \   00000E   3F           ADDC      A,R7
   \   00000F   FB           MOV       R3,A
   \   000010   12....       LCALL     `??ZDSecMgrTCDataLoad::?relay`; Banked call to: ZDSecMgrTCDataLoad
   2737          
   2738            if ( ind->keyType == KEY_TYPE_TC_MASTER )
   \   000013   8E82         MOV       DPL,R6
   \   000015   8F83         MOV       DPH,R7
   \   000017   A3           INC       DPTR
   \   000018   A3           INC       DPTR
   \   000019   A3           INC       DPTR
   \   00001A   A3           INC       DPTR
   \   00001B   E0           MOVX      A,@DPTR
   \   00001C   F8           MOV       R0,A
   \   00001D   606C         JZ        ??ZDSecMgrTransportKeyInd_0
   2739            {
   2740              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2741              //ZDSecMgrTCMasterKey( ind );
   2742              {
   2743                if ( zgPreConfigKeys != TRUE )
   2744                {
   2745                  // devtag.pro.security.todo - check if Trust Center address is configured and correct
   2746                  ZDSecMgrMasterKeyLoad( ind->srcExtAddr, ind->key );
   2747                }
   2748                else
   2749                {
   2750                  // error condition - reject key
   2751                }
   2752              }
   2753            }
   2754            else if ( ( ind->keyType == KEY_TYPE_NWK      ) ||
   2755                      ( ind->keyType == 6                 ) ||
   2756                      ( ind->keyType == KEY_TYPE_NWK_HIGH )    )
   \   00001F   7401         MOV       A,#0x1
   \   000021   68           XRL       A,R0
   \   000022   600A         JZ        ??ZDSecMgrTransportKeyInd_1
   \   000024   7406         MOV       A,#0x6
   \   000026   68           XRL       A,R0
   \   000027   6005         JZ        ??ZDSecMgrTransportKeyInd_1
   \   000029   7405         MOV       A,#0x5
   \   00002B   68           XRL       A,R0
   \   00002C   705D         JNZ       ??ZDSecMgrTransportKeyInd_0
   2757            {
   2758              // check for dummy NWK key (all zeros)
   2759              for ( index = 0;
   \                     ??ZDSecMgrTransportKeyInd_1:
   \   00002E   7800         MOV       R0,#0x0
   \                     ??ZDSecMgrTransportKeyInd_2:
   \   000030   E8           MOV       A,R0
   \   000031   FA           MOV       R2,A
   \   000032   EE           MOV       A,R6
   \   000033   2A           ADD       A,R2
   \   000034   F582         MOV       DPL,A
   \   000036   E4           CLR       A
   \   000037   3F           ADDC      A,R7
   \   000038   F583         MOV       DPH,A
   \   00003A   A3           INC       DPTR
   \   00003B   A3           INC       DPTR
   \   00003C   A3           INC       DPTR
   \   00003D   A3           INC       DPTR
   \   00003E   A3           INC       DPTR
   \   00003F   A3           INC       DPTR
   \   000040   E0           MOVX      A,@DPTR
   \   000041   7007         JNZ       ??ZDSecMgrTransportKeyInd_3
   2760                    ( (index < SEC_KEY_LEN) && (ind->key[index] == 0) );
   2761                    index++ );
   \   000043   08           INC       R0
   \   000044   E8           MOV       A,R0
   \   000045   C3           CLR       C
   \   000046   9410         SUBB      A,#0x10
   \   000048   40E6         JC        ??ZDSecMgrTransportKeyInd_2
   2762          
   2763              if ( index == SEC_KEY_LEN )
   \                     ??ZDSecMgrTransportKeyInd_3:
   \   00004A   7410         MOV       A,#0x10
   \   00004C   68           XRL       A,R0
   \   00004D   7013         JNZ       ??ZDSecMgrTransportKeyInd_4
   2764              {
   2765                // load preconfigured key - once!!
   2766                if ( !_NIB.nwkKeyLoaded )
   \   00004F   90....       MOV       DPTR,#_NIB + 61
   \   000052   E0           MOVX      A,@DPTR
   \   000053   7033         JNZ       ??ZDSecMgrTransportKeyInd_5
   2767                {
   2768                  SSP_UpdateNwkKey( (byte*)zgPreConfigKey, 0 );
   \   000055                ; Setup parameters for call to function SSP_UpdateNwkKey
   \   000055   7900         MOV       R1,#0x0
   \   000057   7A..         MOV       R2,#zgPreConfigKey & 0xff
   \   000059   7B..         MOV       R3,#(zgPreConfigKey >> 8) & 0xff
   \   00005B   12....       LCALL     `??SSP_UpdateNwkKey::?relay`; Banked call to: SSP_UpdateNwkKey
   2769                  SSP_SwitchNwkKey( 0 );
   \   00005E                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   00005E   7900         MOV       R1,#0x0
   \   000060   8023         SJMP      ??ZDSecMgrTransportKeyInd_6
   2770                }
   2771              }
   2772              else
   2773              {
   2774                SSP_UpdateNwkKey( ind->key, ind->keySeqNum );
   \                     ??ZDSecMgrTransportKeyInd_4:
   \   000062   EE           MOV       A,R6
   \   000063   12....       LCALL     ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_81:
   \   000066                ; Setup parameters for call to function SSP_UpdateNwkKey
   \   000066   85..82       MOV       DPL,?V0
   \   000069   F583         MOV       DPH,A
   \   00006B   E0           MOVX      A,@DPTR
   \   00006C   F9           MOV       R1,A
   \   00006D   EE           MOV       A,R6
   \   00006E   2406         ADD       A,#0x6
   \   000070   FA           MOV       R2,A
   \   000071   E4           CLR       A
   \   000072   3F           ADDC      A,R7
   \   000073   FB           MOV       R3,A
   \   000074   12....       LCALL     `??SSP_UpdateNwkKey::?relay`; Banked call to: SSP_UpdateNwkKey
   2775                if ( !_NIB.nwkKeyLoaded )
   \   000077   90....       MOV       DPTR,#_NIB + 61
   \   00007A   E0           MOVX      A,@DPTR
   \   00007B   700B         JNZ       ??ZDSecMgrTransportKeyInd_5
   2776                {
   2777                  SSP_SwitchNwkKey( ind->keySeqNum );
   \   00007D                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   00007D   85..82       MOV       DPL,?V0
   \   000080   85..83       MOV       DPH,?V1
   \   000083   E0           MOVX      A,@DPTR
   \   000084   F9           MOV       R1,A
   \                     ??ZDSecMgrTransportKeyInd_6:
   \   000085   12....       LCALL     `??SSP_SwitchNwkKey::?relay`; Banked call to: SSP_SwitchNwkKey
   2778                }
   2779              }
   2780          
   2781              // handle next step in authentication process
   2782              ZDSecMgrAuthNwkKey();
   \                     ??ZDSecMgrTransportKeyInd_5:
   \   000088                ; Setup parameters for call to function ZDSecMgrAuthNwkKey
   \   000088   12....       LCALL     `??ZDSecMgrAuthNwkKey::?relay`; Banked call to: ZDSecMgrAuthNwkKey
   2783            }
   2784            else if ( ind->keyType == KEY_TYPE_TC_LINK )
   2785            {
   2786              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2787              {
   2788                //ZDSecMgrTCLinkKey( ind );
   2789              }
   2790            }
   2791            else if ( ind->keyType == KEY_TYPE_APP_MASTER )
   2792            {
   2793              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2794              {
   2795                uint16           ami;
   2796                AddrMgrEntry_t   entry;
   2797                ZDSecMgrEntry_t* entryZD;
   2798          
   2799                ZDSecMgrExtAddrLookup( ind->srcExtAddr, &ami );
   2800          
   2801                if ( ind->initiator == TRUE )
   2802                {
   2803                  // get the ami data
   2804                  entry.user  = ADDRMGR_USER_SECURITY;
   2805                  entry.index = ami;
   2806                  AddrMgrEntryGet( &entry );
   2807          
   2808                  if ( entry.nwkAddr != INVALID_NODE_ADDR )
   2809                  {
   2810                    APSME_EstablishKeyReq_t req;
   2811                    ZDSecMgrMasterKeyLoad( ind->srcExtAddr, ind->key );
   2812          
   2813                    ZDSecMgrEntryLookupAMI( ami, &entryZD );
   2814          
   2815                    if ( entryZD == NULL )
   2816                    {
   2817                      // get new entry
   2818                      if ( ZDSecMgrEntryNew( &entryZD ) == ZSuccess )
   2819                      {
   2820                        // finish setting up entry
   2821                        entryZD->ami = ami;
   2822                      }
   2823                    }
   2824          
   2825                    req.respExtAddr = ind->srcExtAddr;
   2826                    req.method      = APSME_SKKE_METHOD;
   2827                    req.dstAddr     = entry.nwkAddr;
   2828                    //devtag.0604.todo - remove obsolete
   2829                    req.apsSecure   = FALSE;
   2830                    req.nwkSecure   = TRUE;
   2831                    APSME_EstablishKeyReq( &req );
   2832                  }
   2833                }
   2834                else
   2835                {
   2836                  if ( ami == INVALID_NODE_ADDR )
   2837                  {
   2838                    // store new EXT address
   2839                    ZDSecMgrAddrStore( INVALID_NODE_ADDR, ind->srcExtAddr, &ami );
   2840                  }
   2841          
   2842                  ZDSecMgrMasterKeyLoad( ind->srcExtAddr, ind->key );
   2843                }
   2844          
   2845                //if ( entry.nwkAddr == INVALID_NODE_ADDR )
   2846                //{
   2847                //  ZDP_NwkAddrReq( ind->srcExtAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   2848                //}
   2849              }
   2850            }
   2851            else if ( ind->keyType == KEY_TYPE_APP_LINK )
   2852            {
   2853              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2854              {
   2855                uint16           ami;
   2856                ZDSecMgrEntry_t* entry;
   2857          
   2858                // get the address index
   2859                if ( ZDSecMgrExtAddrLookup( ind->srcExtAddr, &ami ) != ZSuccess )
   2860                {
   2861                  // store new EXT address
   2862                  ZDSecMgrAddrStore( INVALID_NODE_ADDR, ind->srcExtAddr, &ami );
   2863                  ZDP_NwkAddrReq( ind->srcExtAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   2864                }
   2865          
   2866                ZDSecMgrEntryLookupAMI( ami, &entry );
   2867          
   2868                if ( entry == NULL )
   2869                {
   2870                  // get new entry
   2871                  if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   2872                  {
   2873                    // finish setting up entry
   2874                    entry->ami = ami;
   2875                  }
   2876                }
   2877          
   2878                ZDSecMgrLinkKeySet( ind->srcExtAddr, ind->key );
   2879              }
   2880            }
   2881          }
   \                     ??ZDSecMgrTransportKeyInd_0:
   \   00008B   02....       LJMP      ??Subroutine102_0 & 0xFFFF
   2882          
   2883          /******************************************************************************
   2884           * @fn          ZDSecMgrUpdateDeviceInd
   2885           *
   2886           * @brief       Process the ZDO_UpdateDeviceInd_t message.
   2887           *
   2888           * @param       ind - [in] ZDO_UpdateDeviceInd_t indication
   2889           *
   2890           * @return      none
   2891           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   740A         MOV       A,#0xa
   \   000002                REQUIRE ??Subroutine79_0
   \   000002                ; // Fall through to label ??Subroutine79_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2892          void ZDSecMgrUpdateDeviceInd( ZDO_UpdateDeviceInd_t* ind )
   \                     ZDSecMgrUpdateDeviceInd:
   2893          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 10
   \   000004   74F6         MOV       A,#-0xa
   \   000006   12....       LCALL     ?ALLOC_XSTACK8
   2894            ZDSecMgrDevice_t device;
   2895          
   2896          
   2897            device.nwkAddr    = ind->devAddr;
   \   000009   EA           MOV       A,R2
   \   00000A   240C         ADD       A,#0xc
   \   00000C   F582         MOV       DPL,A
   \   00000E   E4           CLR       A
   \   00000F   3B           ADDC      A,R3
   \   000010   F583         MOV       DPH,A
   \   000012   12....       LCALL     ?Subroutine31 & 0xFFFF
   2898            device.extAddr    = ind->devExtAddr;
   \                     ??CrossCallReturnLabel_162:
   \   000015   EA           MOV       A,R2
   \   000016   2404         ADD       A,#0x4
   \   000018   F8           MOV       R0,A
   \   000019   E4           CLR       A
   \   00001A   3B           ADDC      A,R3
   \   00001B   F9           MOV       R1,A
   \   00001C   7402         MOV       A,#0x2
   \   00001E   12....       LCALL     ?XSTACK_DISP0_8
   \   000021   12....       LCALL     ?Subroutine18 & 0xFFFF
   2899            device.parentAddr = ind->srcAddr;
   \                     ??CrossCallReturnLabel_5:
   \   000024   12....       LCALL     ?XSTACK_DISP0_8
   \   000027   12....       LCALL     ?Subroutine17 & 0xFFFF
   2900          
   2901            //if ( ( ind->status == APSME_UD_SECURED_JOIN   ) ||
   2902            //     ( ind->status == APSME_UD_UNSECURED_JOIN )   )
   2903            //{
   2904            //  if ( ind->status == APSME_UD_SECURED_JOIN )
   2905            //  {
   2906            //    device.secure = TRUE;
   2907            //  }
   2908            //  else
   2909            //  {
   2910            //    device.secure = FALSE;
   2911            //  }
   2912          
   2913              // try to join this device
   2914              ZDSecMgrDeviceJoin( &device );
   \                     ??CrossCallReturnLabel_1:
   \   00002A   12....       LCALL     `??ZDSecMgrDeviceJoin::?relay`; Banked call to: ZDSecMgrDeviceJoin
   2915            //}
   2916          }
   \   00002D   02....       LJMP      ?Subroutine6 & 0xFFFF
   2917          
   2918          /******************************************************************************
   2919           * @fn          ZDSecMgrRemoveDeviceInd
   2920           *
   2921           * @brief       Process the ZDO_RemoveDeviceInd_t message.
   2922           *
   2923           * @param       ind - [in] ZDO_RemoveDeviceInd_t indication
   2924           *
   2925           * @return      none
   2926           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2927          void ZDSecMgrRemoveDeviceInd( ZDO_RemoveDeviceInd_t* ind )
   \                     ZDSecMgrRemoveDeviceInd:
   2928          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV       A,#-0xa
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   2929            ZDSecMgrDevice_t device;
   2930          
   2931          
   2932            // only accept from Trust Center
   2933            if ( ind->srcAddr == APSME_TRUSTCENTER_NWKADDR )
   \   00000A   8A82         MOV       DPL,R2
   \   00000C   8B83         MOV       DPH,R3
   \   00000E   A3           INC       DPTR
   \   00000F   A3           INC       DPTR
   \   000010   12....       LCALL     ??Subroutine94_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_173:
   \   000013   702F         JNZ       ??ZDSecMgrRemoveDeviceInd_0
   2934            {
   2935              // look up NWK address
   2936              if ( APSME_LookupNwkAddr( ind->childExtAddr, &device.nwkAddr ) == TRUE )
   \   000015   EA           MOV       A,R2
   \   000016   2404         ADD       A,#0x4
   \   000018   FE           MOV       R6,A
   \   000019   E4           CLR       A
   \   00001A   3B           ADDC      A,R3
   \   00001B   FF           MOV       R7,A
   \   00001C                ; Setup parameters for call to function APSME_LookupNwkAddr
   \   00001C   AC..         MOV       R4,?XSP + 0
   \   00001E   AD..         MOV       R5,?XSP + 1
   \   000020   EE           MOV       A,R6
   \   000021   FA           MOV       R2,A
   \   000022   EF           MOV       A,R7
   \   000023   FB           MOV       R3,A
   \   000024   12....       LCALL     `??APSME_LookupNwkAddr::?relay`; Banked call to: APSME_LookupNwkAddr
   \   000027   E9           MOV       A,R1
   \   000028   6401         XRL       A,#0x1
   \   00002A   7018         JNZ       ??ZDSecMgrRemoveDeviceInd_0
   2937              {
   2938                device.parentAddr = NLME_GetShortAddr();
   \   00002C                ; Setup parameters for call to function NLME_GetShortAddr
   \   00002C   12....       LCALL     `??NLME_GetShortAddr::?relay`; Banked call to: NLME_GetShortAddr
   \   00002F   7404         MOV       A,#0x4
   \   000031   12....       LCALL     ?XSTACK_DISP0_8
   \   000034   12....       LCALL     ??Subroutine103_0 & 0xFFFF
   2939                device.extAddr    = ind->childExtAddr;
   2940          
   2941                // remove device
   2942                ZDSecMgrDeviceRemove( &device );
   2943              }
   2944            }
   \                     ??CrossCallReturnLabel_218:
   \   000037   12....       LCALL     ?XSTACK_DISP0_8
   \   00003A   EE           MOV       A,R6
   \   00003B   F0           MOVX      @DPTR,A
   \   00003C   A3           INC       DPTR
   \   00003D   EF           MOV       A,R7
   \   00003E   12....       LCALL     ??Subroutine90_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_147:
   \   000041   12....       LCALL     `??ZDSecMgrDeviceRemove::?relay`; Banked call to: ZDSecMgrDeviceRemove
   2945          }
   \                     ??ZDSecMgrRemoveDeviceInd_0:
   \   000044   740A         MOV       A,#0xa
   \   000046   02....       LJMP      ??Subroutine88_0 & 0xFFFF
   2946          
   2947          /******************************************************************************
   2948           * @fn          ZDSecMgrRequestKeyInd
   2949           *
   2950           * @brief       Process the ZDO_RequestKeyInd_t message.
   2951           *
   2952           * @param       ind - [in] ZDO_RequestKeyInd_t indication
   2953           *
   2954           * @return      none
   2955           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2956          void ZDSecMgrRequestKeyInd( ZDO_RequestKeyInd_t* ind )
   \                     ZDSecMgrRequestKeyInd:
   2957          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2958            if ( ind->keyType == KEY_TYPE_NWK )
   \   000004   8A82         MOV       DPL,R2
   \   000006   8B83         MOV       DPH,R3
   \   000008   A3           INC       DPTR
   \   000009   A3           INC       DPTR
   \   00000A   A3           INC       DPTR
   \   00000B   A3           INC       DPTR
   \   00000C   E0           MOVX      A,@DPTR
   \   00000D   F8           MOV       R0,A
   \   00000E   7401         MOV       A,#0x1
   \   000010   68           XRL       A,R0
   \   000011   6008         JZ        ??ZDSecMgrRequestKeyInd_0
   2959            {
   2960            }
   2961            else if ( ind->keyType == KEY_TYPE_APP_MASTER )
   \   000013   7402         MOV       A,#0x2
   \   000015   68           XRL       A,R0
   \   000016   7003         JNZ       ??ZDSecMgrRequestKeyInd_0
   2962            {
   2963              ZDSecMgrAppKeyReq( ind );
   \   000018                ; Setup parameters for call to function ZDSecMgrAppKeyReq
   \   000018   12....       LCALL     `??ZDSecMgrAppKeyReq::?relay`; Banked call to: ZDSecMgrAppKeyReq
   2964            }
   2965            else if ( ind->keyType == KEY_TYPE_TC_LINK )
   2966            {
   2967            }
   2968            //else ignore
   2969          }
   \                     ??ZDSecMgrRequestKeyInd_0:
   \   00001B   02....       LJMP      ??Subroutine86_0 & 0xFFFF
   2970          
   2971          /******************************************************************************
   2972           * @fn          ZDSecMgrSwitchKeyInd
   2973           *
   2974           * @brief       Process the ZDO_SwitchKeyInd_t message.
   2975           *
   2976           * @param       ind - [in] ZDO_SwitchKeyInd_t indication
   2977           *
   2978           * @return      none
   2979           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2980          void ZDSecMgrSwitchKeyInd( ZDO_SwitchKeyInd_t* ind )
   \                     ZDSecMgrSwitchKeyInd:
   2981          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2982            SSP_SwitchNwkKey( ind->keySeqNum );
   \   000004                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   000004   8A82         MOV       DPL,R2
   \   000006   8B83         MOV       DPH,R3
   \   000008   A3           INC       DPTR
   \   000009   A3           INC       DPTR
   \   00000A   A3           INC       DPTR
   \   00000B   A3           INC       DPTR
   \   00000C   E0           MOVX      A,@DPTR
   \   00000D   F9           MOV       R1,A
   \   00000E   12....       LCALL     `??SSP_SwitchNwkKey::?relay`; Banked call to: SSP_SwitchNwkKey
   2983          
   2984            // Save if nv
   2985            ZDApp_NVUpdate();
   \   000011                ; Setup parameters for call to function ZDApp_NVUpdate
   \   000011   12....       LCALL     `??ZDApp_NVUpdate::?relay`; Banked call to: ZDApp_NVUpdate
   2986          }
   \   000014   02....       LJMP      ??Subroutine86_0 & 0xFFFF
   2987          
   2988          /******************************************************************************
   2989           * @fn          ZDSecMgrAuthenticateInd
   2990           *
   2991           * @brief       Process the ZDO_AuthenticateInd_t message.
   2992           *
   2993           * @param       ind - [in] ZDO_AuthenticateInd_t indication
   2994           *
   2995           * @return      none
   2996           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2997          void ZDSecMgrAuthenticateInd( ZDO_AuthenticateInd_t* ind )
   \                     ZDSecMgrAuthenticateInd:
   2998          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 20
   \   000005   74EC         MOV       A,#-0x14
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   2999            APSME_AuthenticateReq_t req;
   3000            AddrMgrEntry_t          entry;
   3001          
   3002          
   3003            // update the address manager
   3004            //---------------------------------------------------------------------------
   3005            // note:
   3006            // required for EA processing, but ultimately EA logic could also use the
   3007            // neighbor table to look up addresses -- also(IF using EA) the neighbor
   3008            // table is supposed to have authentication states for neighbors
   3009            //---------------------------------------------------------------------------
   3010            entry.user    = ADDRMGR_USER_SECURITY;
   \   00000E   7407         MOV       A,#0x7
   \   000010   12....       LCALL     ?XSTACK_DISP0_8
   \   000013   7402         MOV       A,#0x2
   \   000015   F0           MOVX      @DPTR,A
   3011            entry.nwkAddr = ind->aps.initNwkAddr;
   \   000016   EA           MOV       A,R2
   \   000017   2402         ADD       A,#0x2
   \   000019   F5..         MOV       ?V2,A
   \   00001B   E4           CLR       A
   \   00001C   3F           ADDC      A,R7
   \   00001D   F5..         MOV       ?V3,A
   \   00001F   85..82       MOV       DPL,?V2
   \   000022   F583         MOV       DPH,A
   \   000024   12....       LCALL     ??Subroutine99_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_200:
   \   000027   7408         MOV       A,#0x8
   \   000029   12....       LCALL     ?XSTACK_DISP0_8
   \   00002C   12....       LCALL     ??Subroutine91_0 & 0xFFFF
   3012            AddrMgrExtAddrSet( entry.extAddr, ind->aps.initExtAddr );
   \                     ??CrossCallReturnLabel_158:
   \   00002F   EA           MOV       A,R2
   \   000030   12....       LCALL     ?Subroutine61 & 0xFFFF
   \                     ??CrossCallReturnLabel_87:
   \   000033                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000033   AC..         MOV       R4,?V0
   \   000035   FD           MOV       R5,A
   \   000036   740A         MOV       A,#0xa
   \   000038   12....       LCALL     ?XSTACK_DISP0_8
   \   00003B   AA82         MOV       R2,DPL
   \   00003D   AB83         MOV       R3,DPH
   \   00003F   12....       LCALL     `??AddrMgrExtAddrSet::?relay`; Banked call to: AddrMgrExtAddrSet
   3013          
   3014            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \   000042                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000042   7407         MOV       A,#0x7
   \   000044   12....       LCALL     ?XSTACK_DISP101_8
   \   000047   12....       LCALL     `??AddrMgrEntryUpdate::?relay`; Banked call to: AddrMgrEntryUpdate
   \   00004A   E9           MOV       A,R1
   \   00004B   6401         XRL       A,#0x1
   \   00004D   7030         JNZ       ??ZDSecMgrAuthenticateInd_0
   3015            {
   3016              // set request fields
   3017              req.nwkAddr   = ind->aps.initNwkAddr;
   \   00004F   85..82       MOV       DPL,?V2
   \   000052   85..83       MOV       DPH,?V3
   \   000055   12....       LCALL     ??Subroutine99_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_201:
   \   000058   12....       LCALL     ?Subroutine30 & 0xFFFF
   3018              req.extAddr   = ind->aps.initExtAddr;
   \                     ??CrossCallReturnLabel_184:
   \   00005B   12....       LCALL     ?XSTACK_DISP0_8
   \   00005E   E5..         MOV       A,?V0
   \   000060   F0           MOVX      @DPTR,A
   \   000061   A3           INC       DPTR
   \   000062   E5..         MOV       A,?V1
   \   000064   F0           MOVX      @DPTR,A
   3019              req.action    = APSME_EA_ACCEPT;
   \   000065   7406         MOV       A,#0x6
   \   000067   12....       LCALL     ?XSTACK_DISP0_8
   \   00006A   7401         MOV       A,#0x1
   \   00006C   F0           MOVX      @DPTR,A
   3020              req.challenge = ind->aps.challenge;
   \   00006D   EE           MOV       A,R6
   \   00006E   240C         ADD       A,#0xc
   \   000070   F8           MOV       R0,A
   \   000071   E4           CLR       A
   \   000072   3F           ADDC      A,R7
   \   000073   F9           MOV       R1,A
   \   000074   7404         MOV       A,#0x4
   \   000076   12....       LCALL     ?XSTACK_DISP0_8
   \   000079   12....       LCALL     ?Subroutine17 & 0xFFFF
   3021          
   3022              // start EA processing
   3023              APSME_AuthenticateReq( &req );
   3024            }
   \                     ??CrossCallReturnLabel_2:
   \   00007C   12....       LCALL     `??APSME_AuthenticateReq::?relay`; Banked call to: APSME_AuthenticateReq
   3025          }
   \                     ??ZDSecMgrAuthenticateInd_0:
   \   00007F   7414         MOV       A,#0x14
   \   000081   02....       LJMP      ??Subroutine82_0 & 0xFFFF
   3026          
   3027          /******************************************************************************
   3028           * @fn          ZDSecMgrAuthenticateCfm
   3029           *
   3030           * @brief       Process the ZDO_AuthenticateCfm_t message.
   3031           *
   3032           * @param       cfm - [in] ZDO_AuthenticateCfm_t confirmation
   3033           *
   3034           * @return      none
   3035           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3036          void ZDSecMgrAuthenticateCfm( ZDO_AuthenticateCfm_t* cfm )
   \                     ZDSecMgrAuthenticateCfm:
   3037          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   3038            if ( cfm->aps.status == ZSuccess )
   \   000004   EA           MOV       A,R2
   \   000005   240B         ADD       A,#0xb
   \   000007   F582         MOV       DPL,A
   \   000009   E4           CLR       A
   \   00000A   3B           ADDC      A,R3
   \   00000B   F583         MOV       DPH,A
   \   00000D   E0           MOVX      A,@DPTR
   \   00000E   701F         JNZ       ??ZDSecMgrAuthenticateCfm_0
   3039            {
   3040              if ( ( cfm->aps.initiator == TRUE ) && ( devState == DEV_END_DEVICE_UNAUTH ) )
   \   000010   8A82         MOV       DPL,R2
   \   000012   8B83         MOV       DPH,R3
   \   000014   A3           INC       DPTR
   \   000015   A3           INC       DPTR
   \   000016   E0           MOVX      A,@DPTR
   \   000017   6401         XRL       A,#0x1
   \   000019   7014         JNZ       ??ZDSecMgrAuthenticateCfm_0
   \   00001B   90....       MOV       DPTR,#devState
   \   00001E   E0           MOVX      A,@DPTR
   \   00001F   6405         XRL       A,#0x5
   \   000021   700C         JNZ       ??ZDSecMgrAuthenticateCfm_0
   3041              {
   3042                // inform ZDO that device has been authenticated
   3043                osal_set_event ( ZDAppTaskID, ZDO_DEVICE_AUTH );
   \   000023                ; Setup parameters for call to function osal_set_event
   \   000023   7A80         MOV       R2,#-0x80
   \   000025   7B00         MOV       R3,#0x0
   \   000027   90....       MOV       DPTR,#ZDAppTaskID
   \   00002A   E0           MOVX      A,@DPTR
   \   00002B   F9           MOV       R1,A
   \   00002C   12....       LCALL     `??osal_set_event::?relay`; Banked call to: osal_set_event
   3044              }
   3045            }
   3046          }
   \                     ??ZDSecMgrAuthenticateCfm_0:
   \   00002F   02....       LJMP      ??Subroutine86_0 & 0xFFFF
   3047          
   3048          #if ( ZG_BUILD_COORDINATOR_TYPE )
   3049          /******************************************************************************
   3050           * @fn          ZDSecMgrUpdateNwkKey
   3051           *
   3052           * @brief       Load a new NWK key and trigger a network wide update.
   3053           *
   3054           * @param       key       - [in] new NWK key
   3055           * @param       keySeqNum - [in] new NWK key sequence number
   3056           *
   3057           * @return      ZStatus_t
   3058           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3059          ZStatus_t ZDSecMgrUpdateNwkKey( uint8* key, uint8 keySeqNum, uint16 dstAddr )
   \                     ZDSecMgrUpdateNwkKey:
   3060          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV       A,#-0xd
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   \   00000E   89..         MOV       ?V1,R1
   3061            ZStatus_t               status;
   3062            APSME_TransportKeyReq_t req;
   3063          
   3064            // initialize common elements of local variables
   3065            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   3066              req.keyType   = KEY_TYPE_NWK_HIGH;
   3067            else
   3068              req.keyType   = KEY_TYPE_NWK;
   \   000010   7402         MOV       A,#0x2
   \   000012   12....       LCALL     ?XSTACK_DISP0_8
   \   000015   7401         MOV       A,#0x1
   \   000017   F0           MOVX      @DPTR,A
   3069          
   3070            req.dstAddr   = dstAddr;
   \   000018   85..82       MOV       DPL,?XSP + 0
   \   00001B   85..83       MOV       DPH,?XSP + 1
   \   00001E   EC           MOV       A,R4
   \   00001F   F0           MOVX      @DPTR,A
   \   000020   A3           INC       DPTR
   \   000021   ED           MOV       A,R5
   \   000022   F0           MOVX      @DPTR,A
   3071            req.keySeqNum = keySeqNum;
   \   000023   7403         MOV       A,#0x3
   \   000025   12....       LCALL     ?XSTACK_DISP0_8
   \   000028   E9           MOV       A,R1
   \   000029   F0           MOVX      @DPTR,A
   3072            req.key       = key;
   \   00002A   7404         MOV       A,#0x4
   \   00002C   12....       LCALL     ?XSTACK_DISP0_8
   \   00002F   12....       LCALL     ?Subroutine35 & 0xFFFF
   3073            req.extAddr   = NULL;
   \                     ??CrossCallReturnLabel_35:
   \   000032   7406         MOV       A,#0x6
   \   000034   12....       LCALL     ?XSTACK_DISP0_8
   \   000037   E4           CLR       A
   \   000038   F0           MOVX      @DPTR,A
   \   000039   A3           INC       DPTR
   \   00003A   F0           MOVX      @DPTR,A
   3074            req.nwkSecure = TRUE;
   \   00003B   740A         MOV       A,#0xa
   \   00003D   12....       LCALL     ?XSTACK_DISP0_8
   \   000040   7401         MOV       A,#0x1
   \   000042   F0           MOVX      @DPTR,A
   3075            req.apsSecure = TRUE;
   \   000043   7409         MOV       A,#0x9
   \   000045   12....       LCALL     ?XSTACK_DISP0_8
   \   000048   7401         MOV       A,#0x1
   \   00004A   F0           MOVX      @DPTR,A
   3076            req.tunnel    = NULL;
   \   00004B   740B         MOV       A,#0xb
   \   00004D   12....       LCALL     ?XSTACK_DISP0_8
   \   000050   E4           CLR       A
   \   000051   F0           MOVX      @DPTR,A
   \   000052   A3           INC       DPTR
   \   000053   12....       LCALL     ?Subroutine32 & 0xFFFF
   3077          
   3078            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   3079            {
   3080              ZDSecMgrEntry_t*        entry;
   3081              uint16                  index;
   3082              AddrMgrEntry_t          addrEntry;
   3083          
   3084              addrEntry.user = ADDRMGR_USER_SECURITY;
   3085          
   3086              status = ZFailure;
   3087          
   3088              // verify data is available
   3089              if ( ZDSecMgrEntries != NULL )
   3090              {
   3091                // find available entry
   3092                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   3093                {
   3094                  if ( ZDSecMgrEntries[index].ami != INVALID_NODE_ADDR )
   3095                  {
   3096                    // return successful result
   3097                    entry = &ZDSecMgrEntries[index];
   3098          
   3099                    // get NWK address
   3100                    addrEntry.index = entry->ami;
   3101                    if ( AddrMgrEntryGet( &addrEntry ) == TRUE )
   3102                    {
   3103                      req.dstAddr = addrEntry.nwkAddr;
   3104                      req.extAddr = addrEntry.extAddr;
   3105                      status = APSME_TransportKeyReq( &req );
   3106                    }
   3107                  }
   3108                }
   3109              }
   3110            }
   3111            else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   3112            {
   3113              status = APSME_TransportKeyReq( &req );
   \                     ??CrossCallReturnLabel_26:
   \   000056   E9           MOV       A,R1
   \   000057   F5..         MOV       ?V0,A
   3114            }
   3115          
   3116            SSP_UpdateNwkKey( key, keySeqNum );
   \   000059                ; Setup parameters for call to function SSP_UpdateNwkKey
   \   000059   A9..         MOV       R1,?V1
   \   00005B   EE           MOV       A,R6
   \   00005C   FA           MOV       R2,A
   \   00005D   EF           MOV       A,R7
   \   00005E   FB           MOV       R3,A
   \   00005F   12....       LCALL     `??SSP_UpdateNwkKey::?relay`; Banked call to: SSP_UpdateNwkKey
   3117          
   3118            // Save if nv
   3119            ZDApp_NVUpdate();
   \   000062                ; Setup parameters for call to function ZDApp_NVUpdate
   \   000062   12....       LCALL     `??ZDApp_NVUpdate::?relay`; Banked call to: ZDApp_NVUpdate
   3120          
   3121            return status;
   \   000065   02....       LJMP      ?Subroutine12 & 0xFFFF
   3122          }
   3123          #endif // ( ZG_BUILD_COORDINATOR_TYPE )
   3124          
   3125          #if ( ZG_BUILD_COORDINATOR_TYPE )
   3126          /******************************************************************************
   3127           * @fn          ZDSecMgrSwitchNwkKey
   3128           *
   3129           * @brief       Causes the NWK key to switch via a network wide command.
   3130           *
   3131           * @param       keySeqNum - [in] new NWK key sequence number
   3132           *
   3133           * @return      ZStatus_t
   3134           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3135          ZStatus_t ZDSecMgrSwitchNwkKey( uint8 keySeqNum, uint16 dstAddr )
   \                     ZDSecMgrSwitchNwkKey:
   3136          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 3
   \   000005   74FD         MOV       A,#-0x3
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   E9           MOV       A,R1
   \   00000B   FF           MOV       R7,A
   3137            ZStatus_t            status;
   3138            APSME_SwitchKeyReq_t req;
   3139          
   3140            // initialize common elements of local variables
   3141            req.dstAddr = dstAddr;
   \   00000C   12....       LCALL     ?Subroutine21 & 0xFFFF
   3142            req.keySeqNum = keySeqNum;
   \                     ??CrossCallReturnLabel_216:
   \   00000F   12....       LCALL     ?XSTACK_DISP0_8
   \   000012   E9           MOV       A,R1
   \   000013   12....       LCALL     ??Subroutine90_0 & 0xFFFF
   3143          
   3144            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   3145            {
   3146              ZDSecMgrEntry_t*     entry;
   3147              uint16               index;
   3148              AddrMgrEntry_t       addrEntry;
   3149          
   3150              addrEntry.user = ADDRMGR_USER_SECURITY;
   3151          
   3152              status = ZFailure;
   3153          
   3154              // verify data is available
   3155              if ( ZDSecMgrEntries != NULL )
   3156              {
   3157                // find available entry
   3158                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   3159                {
   3160                  if ( ZDSecMgrEntries[index].ami != INVALID_NODE_ADDR )
   3161                  {
   3162                    // return successful result
   3163                    entry = &ZDSecMgrEntries[index];
   3164          
   3165                    // get NWK address
   3166                    addrEntry.index = entry->ami;
   3167          
   3168                    if ( AddrMgrEntryGet( &addrEntry ) == TRUE )
   3169                    {
   3170                      req.dstAddr = addrEntry.nwkAddr;
   3171                      status = APSME_SwitchKeyReq( &req );
   3172                    }
   3173                  }
   3174                }
   3175              }
   3176            }
   3177            else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   3178            {
   3179              status = APSME_SwitchKeyReq( &req );
   \                     ??CrossCallReturnLabel_148:
   \   000016   12....       LCALL     `??APSME_SwitchKeyReq::?relay`; Banked call to: APSME_SwitchKeyReq
   \   000019   E9           MOV       A,R1
   \   00001A   FE           MOV       R6,A
   3180            }
   3181          
   3182            SSP_SwitchNwkKey( keySeqNum );
   \   00001B                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   00001B   EF           MOV       A,R7
   \   00001C   F9           MOV       R1,A
   \   00001D   12....       LCALL     `??SSP_SwitchNwkKey::?relay`; Banked call to: SSP_SwitchNwkKey
   3183          
   3184            // Save if nv
   3185            ZDApp_NVUpdate();
   \   000020                ; Setup parameters for call to function ZDApp_NVUpdate
   \   000020   12....       LCALL     `??ZDApp_NVUpdate::?relay`; Banked call to: ZDApp_NVUpdate
   3186          
   3187            return status;
   \   000023   EE           MOV       A,R6
   \   000024   F9           MOV       R1,A
   \   000025   7403         MOV       A,#0x3
   \   000027   02....       LJMP      ??Subroutine88_0 & 0xFFFF
   3188          }
   3189          #endif // ( ZG_BUILD_COORDINATOR_TYPE )
   3190          
   3191          #if ( ZG_BUILD_JOINING_TYPE )
   3192          /******************************************************************************
   3193           * @fn          ZDSecMgrRequestAppKey
   3194           *
   3195           * @brief       Request an application key with partner.
   3196           *
   3197           * @param       partNwkAddr - [in] partner network address
   3198           *
   3199           * @return      ZStatus_t
   3200           */
   3201          ZStatus_t ZDSecMgrRequestAppKey( uint16 partNwkAddr )
   3202          {
   3203            ZStatus_t             status;
   3204            APSME_RequestKeyReq_t req;
   3205            uint8                 partExtAddr[Z_EXTADDR_LEN];
   3206          
   3207          
   3208            if ( AddrMgrExtAddrLookup( partNwkAddr, partExtAddr ) )
   3209            {
   3210              req.dstAddr = 0;
   3211              req.keyType = KEY_TYPE_APP_MASTER;
   3212              req.partExtAddr = partExtAddr;
   3213              status = APSME_RequestKeyReq( &req );
   3214            }
   3215            else
   3216            {
   3217              status = ZFailure;
   3218            }
   3219          
   3220            return status;
   3221          }
   3222          #endif // ( ZG_BUILD_JOINING_TYPE )
   3223          
   3224          #if ( ZG_BUILD_JOINING_TYPE )
   3225          /******************************************************************************
   3226           * @fn          ZDSecMgrSetupPartner
   3227           *
   3228           * @brief       Setup for application key partner.
   3229           *
   3230           * @param       partNwkAddr - [in] partner network address
   3231           *
   3232           * @return      ZStatus_t
   3233           */
   3234          ZStatus_t ZDSecMgrSetupPartner( uint16 partNwkAddr, uint8* partExtAddr )
   3235          {
   3236            AddrMgrEntry_t entry;
   3237            ZStatus_t      status;
   3238          
   3239            status = ZFailure;
   3240          
   3241            // update the address manager
   3242            entry.user    = ADDRMGR_USER_SECURITY;
   3243            entry.nwkAddr = partNwkAddr;
   3244            AddrMgrExtAddrSet( entry.extAddr, partExtAddr );
   3245          
   3246            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   3247            {
   3248              status = ZSuccess;
   3249          
   3250              // check for address discovery
   3251              if ( partNwkAddr == INVALID_NODE_ADDR )
   3252              {
   3253                status = ZDP_NwkAddrReq( partExtAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   3254              }
   3255              else if ( !AddrMgrExtAddrValid( partExtAddr ) )
   3256              {
   3257                status = ZDP_IEEEAddrReq( partNwkAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   3258              }
   3259            }
   3260          
   3261            return status;
   3262          }
   3263          #endif // ( ZG_BUILD_JOINING_TYPE )
   3264          
   3265          #if ( ZG_BUILD_COORDINATOR_TYPE )
   3266          /******************************************************************************
   3267           * @fn          ZDSecMgrAppKeyTypeSet
   3268           *
   3269           * @brief       Set application key type.
   3270           *
   3271           * @param       keyType - [in] application key type (KEY_TYPE_APP_MASTER@2 or
   3272           *                                                   KEY_TYPE_APP_LINK@3
   3273           *
   3274           * @return      ZStatus_t
   3275           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3276          ZStatus_t ZDSecMgrAppKeyTypeSet( uint8 keyType )
   \                     ZDSecMgrAppKeyTypeSet:
   3277          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV       A,R1
   \   000005   F8           MOV       R0,A
   3278            if ( keyType == KEY_TYPE_APP_LINK )
   \   000006   7403         MOV       A,#0x3
   \   000008   68           XRL       A,R0
   \   000009   90....       MOV       DPTR,#ZDSecMgrAppKeyType
   \   00000C   7004         JNZ       ??ZDSecMgrAppKeyTypeSet_0
   3279            {
   3280              ZDSecMgrAppKeyType = KEY_TYPE_APP_LINK;
   \   00000E   7403         MOV       A,#0x3
   \   000010   8002         SJMP      ??ZDSecMgrAppKeyTypeSet_1
   3281            }
   3282            else
   3283            {
   3284              ZDSecMgrAppKeyType = KEY_TYPE_APP_MASTER;
   \                     ??ZDSecMgrAppKeyTypeSet_0:
   \   000012   7402         MOV       A,#0x2
   3285            }
   \                     ??ZDSecMgrAppKeyTypeSet_1:
   \   000014   02....       LJMP      ?Subroutine7 & 0xFFFF
   3286          
   3287            return ZSuccess;
   3288          }
   3289          #endif
   3290          
   3291          /******************************************************************************
   3292           * ZigBee Device Security Manager - Stub Implementations
   3293           */
   3294          /******************************************************************************
   3295           * @fn          ZDSecMgrMasterKeyGet (stubs APSME_MasterKeyGet)
   3296           *
   3297           * @brief       Get MASTER key for specified EXT address.
   3298           *
   3299           * @param       extAddr - [in] EXT address
   3300           * @param       key     - [out] MASTER key
   3301           *
   3302           * @return      ZStatus_t
   3303           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3304          ZStatus_t ZDSecMgrMasterKeyGet( uint8* extAddr, uint8** key )
   \                     APSME_MasterKeyGet:
   3305          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EC           MOV       A,R4
   \   00000B   FE           MOV       R6,A
   \   00000C   ED           MOV       A,R5
   \   00000D   FF           MOV       R7,A
   3306            ZStatus_t status;
   3307            uint16    ami;
   3308          
   3309          
   3310            // lookup entry for specified EXT address
   3311            status = ZDSecMgrExtAddrLookup( extAddr, &ami );
   \   00000E                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00000E   AC..         MOV       R4,?XSP + 0
   \   000010   AD..         MOV       R5,?XSP + 1
   \   000012   12....       LCALL     `??ZDSecMgrExtAddrLookup::?relay`; Banked call to: ZDSecMgrExtAddrLookup
   \   000015   E9           MOV       A,R1
   \   000016   F5..         MOV       ?V0,A
   3312            //status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   3313          
   3314            if ( status == ZSuccess )
   \   000018   7012         JNZ       ??APSME_MasterKeyGet_0
   3315            {
   3316              ZDSecMgrMasterKeyLookup( ami, key );
   \   00001A                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   00001A   EE           MOV       A,R6
   \   00001B   FC           MOV       R4,A
   \   00001C   EF           MOV       A,R7
   \   00001D   FD           MOV       R5,A
   \   00001E   85..82       MOV       DPL,?XSP + 0
   \   000021   85..83       MOV       DPH,?XSP + 1
   \   000024   12....       LCALL     ??Subroutine85_0 & 0xFFFF
   3317            }
   \                     ??CrossCallReturnLabel_134:
   \   000027   12....       LCALL     `??ZDSecMgrMasterKeyLookup::?relay`; Banked call to: ZDSecMgrMasterKeyLookup
   \   00002A   8008         SJMP      ??APSME_MasterKeyGet_1
   3318            else
   3319            {
   3320              *key = NULL;
   \                     ??APSME_MasterKeyGet_0:
   \   00002C   8E82         MOV       DPL,R6
   \   00002E   8F83         MOV       DPH,R7
   \   000030   E4           CLR       A
   \   000031   F0           MOVX      @DPTR,A
   \   000032   A3           INC       DPTR
   \   000033   F0           MOVX      @DPTR,A
   3321            }
   3322          
   3323            return status;
   \                     ??APSME_MasterKeyGet_1:
   \   000034   02....       LJMP      ?Subroutine1 & 0xFFFF
   3324          }
   3325          
   3326          /******************************************************************************
   3327           * @fn          ZDSecMgrLinkKeySet (stubs APSME_LinkKeySet)
   3328           *
   3329           * @brief       Set <APSME_LinkKeyData_t> for specified NWK address.
   3330           *
   3331           * @param       extAddr - [in] EXT address
   3332           * @param       data    - [in] APSME_LinkKeyData_t
   3333           *
   3334           * @return      ZStatus_t
   3335           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3336          ZStatus_t ZDSecMgrLinkKeySet( uint8* extAddr, uint8* key )
   \                     APSME_LinkKeySet:
   3337          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV       A,#-0xf
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EC           MOV       A,R4
   \   00000B   FE           MOV       R6,A
   \   00000C   ED           MOV       A,R5
   \   00000D   FF           MOV       R7,A
   3338            ZStatus_t        status;
   3339            ZDSecMgrEntry_t* entry;
   3340          
   3341          
   3342            // lookup entry index for specified EXT address
   3343            status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   00000E                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000E   AC..         MOV       R4,?XSP + 0
   \   000010   AD..         MOV       R5,?XSP + 1
   \   000012   12....       LCALL     `??ZDSecMgrEntryLookupExt::?relay`; Banked call to: ZDSecMgrEntryLookupExt
   \   000015   E9           MOV       A,R1
   \   000016   F5..         MOV       ?V0,A
   3344          
   3345            if ( status == ZSuccess )
   \   000018   7038         JNZ       ??APSME_LinkKeySet_0
   3346            {
   3347              // setup the link key data reference
   3348              osal_memcpy( entry->lkd.key, key, SEC_KEY_LEN );
   \   00001A                ; Setup parameters for call to function osal_memcpy
   \   00001A   8E..         MOV       ?V4,R6
   \   00001C   8F..         MOV       ?V5,R7
   \   00001E   75..00       MOV       ?V6,#0x0
   \   000021   78..         MOV       R0,#?V4
   \   000023   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   000026   7C10         MOV       R4,#0x10
   \   000028   7D00         MOV       R5,#0x0
   \   00002A   7403         MOV       A,#0x3
   \   00002C   12....       LCALL     ?XSTACK_DISP0_8
   \   00002F   E0           MOVX      A,@DPTR
   \   000030   2402         ADD       A,#0x2
   \   000032   FA           MOV       R2,A
   \   000033   A3           INC       DPTR
   \   000034   E0           MOVX      A,@DPTR
   \   000035   3400         ADDC      A,#0x0
   \   000037   FB           MOV       R3,A
   \   000038   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   00003B   7403         MOV       A,#0x3
   \   00003D   12....       LCALL     ?DEALLOC_XSTACK8
   3349          
   3350              entry->lkd.apsmelkd.rxFrmCntr = 0;
   \   000040   12....       LCALL     ?Subroutine74 & 0xFFFF
   3351              entry->lkd.apsmelkd.txFrmCntr = 0;
   3352            }
   \                     ??CrossCallReturnLabel_221:
   \   000043   C8           XCH       A,R0
   \   000044   2418         ADD       A,#0x18
   \   000046   12....       LCALL     ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_84:
   \   000049   12....       LCALL     ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_11:
   \   00004C   2414         ADD       A,#0x14
   \   00004E   12....       LCALL     ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_85:
   \   000051   F0           MOVX      @DPTR,A
   3353          
   3354            return status;
   \                     ??APSME_LinkKeySet_0:
   \   000052   A9..         MOV       R1,?V0
   \   000054   7402         MOV       A,#0x2
   \   000056   02....       LJMP      ?Subroutine5 & 0xFFFF
   3355          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine60:
   \   000000   F582         MOV       DPL,A
   \   000002   E4           CLR       A
   \   000003   38           ADDC      A,R0
   \   000004   F583         MOV       DPH,A
   \   000006   E4           CLR       A
   \   000007   F0           MOVX      @DPTR,A
   \   000008   A3           INC       DPTR
   \   000009   F0           MOVX      @DPTR,A
   \   00000A   A3           INC       DPTR
   \   00000B   F0           MOVX      @DPTR,A
   \   00000C   A3           INC       DPTR
   \   00000D   22           RET
   3356          
   3357          /******************************************************************************
   3358           * @fn          ZDSecMgrAuthenticationSet
   3359           *
   3360           * @brief       Mark the specific device as authenticated or not
   3361           *
   3362           * @param       extAddr - [in] EXT address
   3363           * @param       option  - [in] authenticated or not
   3364           *
   3365           * @return      ZStatus_t
   3366           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3367          ZStatus_t ZDSecMgrAuthenticationSet( uint8* extAddr, ZDSecMgr_Authentication_Option option )
   \                     ZDSecMgrAuthenticationSet:
   3368          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   E9           MOV       A,R1
   \   00000B   FE           MOV       R6,A
   3369            ZStatus_t        status;
   3370            ZDSecMgrEntry_t* entry;
   3371          
   3372          
   3373            // lookup entry index for specified EXT address
   3374            status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   00000C                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000C   AC..         MOV       R4,?XSP + 0
   \   00000E   AD..         MOV       R5,?XSP + 1
   \   000010   12....       LCALL     `??ZDSecMgrEntryLookupExt::?relay`; Banked call to: ZDSecMgrEntryLookupExt
   \   000013   E9           MOV       A,R1
   \   000014   F9           MOV       R1,A
   3375          
   3376            if ( status == ZSuccess )
   \   000015   700E         JNZ       ??ZDSecMgrAuthenticationSet_0
   3377            {
   3378              entry->authenticateOption = option;
   \   000017   12....       LCALL     ?Subroutine74 & 0xFFFF
   3379            }
   \                     ??CrossCallReturnLabel_222:
   \   00001A   C8           XCH       A,R0
   \   00001B   241C         ADD       A,#0x1c
   \   00001D   F582         MOV       DPL,A
   \   00001F   E4           CLR       A
   \   000020   38           ADDC      A,R0
   \   000021   F583         MOV       DPH,A
   \   000023   EE           MOV       A,R6
   \   000024   F0           MOVX      @DPTR,A
   3380          
   3381            return status;
   \                     ??ZDSecMgrAuthenticationSet_0:
   \   000025   02....       LJMP      ??Subroutine87_0 & 0xFFFF
   3382          }
   3383          
   3384          /******************************************************************************
   3385           * @fn          ZDSecMgrAuthenticationCheck
   3386           *
   3387           * @brief       Check if the specific device has been authenticated or not
   3388           *              For non-trust center device, always return true
   3389           *
   3390           * @param       shortAddr - [in] short address
   3391           *
   3392           * @return      TRUE @ authenticated with CBKE
   3393           *              FALSE @ not authenticated
   3394           */
   3395          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3396          uint8 ZDSecMgrAuthenticationCheck( uint16 shortAddr )
   \                     ZDSecMgrAuthenticationCheck:
   3397          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   3398          #if defined (SE_PROFILE)
   3399          
   3400            ZDSecMgrEntry_t* entry;
   3401            uint8 extAddr[Z_EXTADDR_LEN];
   3402          
   3403            // If the local device is not the trust center, always return TRUE
   3404            if ( NLME_GetShortAddr() != TCshortAddr )
   3405            {
   3406              return TRUE;
   3407            }
   3408            // Otherwise, check the authentication option
   3409            else if ( AddrMgrExtAddrLookup( shortAddr, extAddr ) )
   3410            {
   3411              // lookup entry index for specified EXT address
   3412              if ( ZDSecMgrEntryLookupExt( extAddr, &entry ) == ZSuccess )
   3413              {
   3414                if ( entry->authenticateOption != ZDSecMgr_Not_Authenticated )
   3415                {
   3416                  return TRUE;
   3417                }
   3418                else
   3419                {
   3420                  return FALSE;
   3421                }
   3422              }
   3423            }
   3424            return FALSE;
   3425          
   3426          #else
   3427            (void)shortAddr;  // Intentionally unreferenced parameter
   3428            
   3429            // For non AMI/SE Profile, perform no check and always return true.
   3430            return TRUE;
   \   000000   7901         MOV       R1,#0x1
   \   000002   02....       LJMP      ?BRET
   3431          
   3432          #endif // SE_PROFILE
   3433          }
   3434          
   3435          
   3436          /******************************************************************************
   3437           * @fn          ZDSecMgrLinkKeyDataGet (stubs APSME_LinkKeyDataGet)
   3438           *
   3439           * @brief       Get <APSME_LinkKeyData_t> for specified NWK address.
   3440           *
   3441           * @param       extAddr - [in] EXT address
   3442           * @param       data    - [out] APSME_LinkKeyData_t
   3443           *
   3444           * @return      ZStatus_t
   3445           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3446          ZStatus_t ZDSecMgrLinkKeyDataGet(uint8* extAddr, APSME_LinkKeyData_t** data)
   \                     APSME_LinkKeyDataGet:
   3447          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EC           MOV       A,R4
   \   00000B   FE           MOV       R6,A
   \   00000C   ED           MOV       A,R5
   \   00000D   FF           MOV       R7,A
   3448            ZStatus_t        status;
   3449            ZDSecMgrEntry_t* entry;
   3450          
   3451          
   3452            // lookup entry index for specified NWK address
   3453            status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   00000E                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000E   AC..         MOV       R4,?XSP + 0
   \   000010   AD..         MOV       R5,?XSP + 1
   \   000012   12....       LCALL     `??ZDSecMgrEntryLookupExt::?relay`; Banked call to: ZDSecMgrEntryLookupExt
   \   000015   E9           MOV       A,R1
   \   000016   F9           MOV       R1,A
   3454          
   3455            if ( status == ZSuccess )
   \   000017   702F         JNZ       ??APSME_LinkKeyDataGet_0
   3456            {
   3457              // setup the link key data reference
   3458              (*data) = &entry->lkd.apsmelkd;
   \   000019   85..82       MOV       DPL,?XSP + 0
   \   00001C   85..83       MOV       DPH,?XSP + 1
   \   00001F   E0           MOVX      A,@DPTR
   \   000020   2412         ADD       A,#0x12
   \   000022   FA           MOV       R2,A
   \   000023   A3           INC       DPTR
   \   000024   E0           MOVX      A,@DPTR
   \   000025   3400         ADDC      A,#0x0
   \   000027   FB           MOV       R3,A
   \   000028   8E82         MOV       DPL,R6
   \   00002A   8F83         MOV       DPH,R7
   \   00002C   12....       LCALL     ?Subroutine35 & 0xFFFF
   3459              (*data)->key = entry->lkd.key;
   \                     ??CrossCallReturnLabel_36:
   \   00002F   85..82       MOV       DPL,?XSP + 0
   \   000032   85..83       MOV       DPH,?XSP + 1
   \   000035   E0           MOVX      A,@DPTR
   \   000036   2402         ADD       A,#0x2
   \   000038   FC           MOV       R4,A
   \   000039   A3           INC       DPTR
   \   00003A   E0           MOVX      A,@DPTR
   \   00003B   3400         ADDC      A,#0x0
   \   00003D   FD           MOV       R5,A
   \   00003E   8A82         MOV       DPL,R2
   \   000040   8B83         MOV       DPH,R3
   \   000042   EC           MOV       A,R4
   \   000043   F0           MOVX      @DPTR,A
   \   000044   A3           INC       DPTR
   \   000045   ED           MOV       A,R5
   \   000046   8007         SJMP      ??APSME_LinkKeyDataGet_1
   3460            }
   3461            else
   3462            {
   3463              *data = NULL;
   \                     ??APSME_LinkKeyDataGet_0:
   \   000048   8E82         MOV       DPL,R6
   \   00004A   8F83         MOV       DPH,R7
   \   00004C   E4           CLR       A
   \   00004D   F0           MOVX      @DPTR,A
   \   00004E   A3           INC       DPTR
   \                     ??APSME_LinkKeyDataGet_1:
   \   00004F   F0           MOVX      @DPTR,A
   3464            }
   3465          
   3466            return status;
   \   000050   02....       LJMP      ??Subroutine87_0 & 0xFFFF
   3467          }
   3468          
   3469          /******************************************************************************
   3470           * @fn          ZDSecMgrKeyFwdToChild (stubs APSME_KeyFwdToChild)
   3471           *
   3472           * @brief       Verify and process key transportation to child.
   3473           *
   3474           * @param       ind - [in] APSME_TransportKeyInd_t
   3475           *
   3476           * @return      uint8 - success(TRUE:FALSE)
   3477           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3478          uint8 ZDSecMgrKeyFwdToChild( APSME_TransportKeyInd_t* ind )
   \                     APSME_KeyFwdToChild:
   3479          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   3480            uint8 success;
   3481          
   3482            success = FALSE;
   \   000005   7E00         MOV       R6,#0x0
   3483          
   3484            // verify from Trust Center
   3485            if ( ind->srcAddr == APSME_TRUSTCENTER_NWKADDR )
   \   000007   8A82         MOV       DPL,R2
   \   000009   8B83         MOV       DPH,R3
   \   00000B   12....       LCALL     ??Subroutine94_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_174:
   \   00000E   7028         JNZ       ??APSME_KeyFwdToChild_0
   3486            {
   3487              success = TRUE;
   \   000010   7E01         MOV       R6,#0x1
   3488          
   3489              // check for initial NWK key
   3490              if ( ( ind->keyType == KEY_TYPE_NWK      ) ||
   3491                   ( ind->keyType == 6                 ) ||
   3492                   ( ind->keyType == KEY_TYPE_NWK_HIGH )    )
   \   000012   8A82         MOV       DPL,R2
   \   000014   8B83         MOV       DPH,R3
   \   000016   A3           INC       DPTR
   \   000017   A3           INC       DPTR
   \   000018   E0           MOVX      A,@DPTR
   \   000019   F8           MOV       R0,A
   \   00001A   EE           MOV       A,R6
   \   00001B   68           XRL       A,R0
   \   00001C   600A         JZ        ??APSME_KeyFwdToChild_1
   \   00001E   7406         MOV       A,#0x6
   \   000020   68           XRL       A,R0
   \   000021   6005         JZ        ??APSME_KeyFwdToChild_1
   \   000023   7405         MOV       A,#0x5
   \   000025   68           XRL       A,R0
   \   000026   7010         JNZ       ??APSME_KeyFwdToChild_0
   3493              {
   3494                // set association status to authenticated
   3495                ZDSecMgrAssocDeviceAuth( AssocGetWithExt( ind->dstExtAddr ) );
   \                     ??APSME_KeyFwdToChild_1:
   \   000028                ; Setup parameters for call to function AssocGetWithExt
   \   000028   8A82         MOV       DPL,R2
   \   00002A   8B83         MOV       DPH,R3
   \   00002C   A3           INC       DPTR
   \   00002D   A3           INC       DPTR
   \   00002E   A3           INC       DPTR
   \   00002F   A3           INC       DPTR
   \   000030   A3           INC       DPTR
   \   000031   A3           INC       DPTR
   \   000032   12....       LCALL     ?Subroutine54 & 0xFFFF
   3496              }
   3497            }
   \                     ??CrossCallReturnLabel_68:
   \   000035                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   000035   12....       LCALL     `??ZDSecMgrAssocDeviceAuth::?relay`; Banked call to: ZDSecMgrAssocDeviceAuth
   3498          
   3499            return success;
   \                     ??APSME_KeyFwdToChild_0:
   \   000038                REQUIRE ?Subroutine10
   \   000038                ; // Fall through to label ?Subroutine10
   3500          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   EE           MOV       A,R6
   \   000001   F9           MOV       R1,A
   \   000002   02....       LJMP      ??Subroutine102_0 & 0xFFFF
   3501          
   3502          /******************************************************************************
   3503           * @fn          ZDSecMgrAddLinkKey
   3504           *
   3505           * @brief       Add the application link key to ZDSecMgr. Also mark the device
   3506           *              as authenticated in the authenticateOption. Note that this function
   3507           *              is hardwared to CBKE right now.
   3508           *
   3509           * @param       shortAddr - short address of the partner device
   3510           * @param       extAddr - extended address of the partner device
   3511           * @param       key - link key
   3512           *
   3513           * @return      none
   3514           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3515          void ZDSecMgrAddLinkKey( uint16 shortAddr, uint8 *extAddr, uint8 *key)
   \                     ZDSecMgrAddLinkKey:
   3516          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV       A,#-0x4
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EC           MOV       A,R4
   \   00000B   FE           MOV       R6,A
   \   00000C   ED           MOV       A,R5
   \   00000D   FF           MOV       R7,A
   3517            uint16           ami;
   3518            ZDSecMgrEntry_t* entry;
   3519          
   3520            ZDSecMgrAddrStore( shortAddr, extAddr, &ami );
   \   00000E                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   00000E   7402         MOV       A,#0x2
   \   000010   12....       LCALL     ?XSTACK_DISP100_8
   \   000013   88..         MOV       ?V0,R0
   \   000015   89..         MOV       ?V1,R1
   \   000017   78..         MOV       R0,#?V0
   \   000019   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00001C   12....       LCALL     `??ZDSecMgrAddrStore::?relay`; Banked call to: ZDSecMgrAddrStore
   \   00001F   7402         MOV       A,#0x2
   \   000021   12....       LCALL     ?DEALLOC_XSTACK8
   3521          
   3522            ZDSecMgrEntryLookupAMI( ami, &entry );
   \   000024                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   000024   AC..         MOV       R4,?XSP + 0
   \   000026   AD..         MOV       R5,?XSP + 1
   \   000028   7402         MOV       A,#0x2
   \   00002A   12....       LCALL     ?XSTACK_DISP0_8
   \   00002D   12....       LCALL     ?Subroutine52 & 0xFFFF
   3523          
   3524            // If no existing entry, create one
   3525            if ( entry == NULL )
   \                     ??CrossCallReturnLabel_64:
   \   000030   12....       LCALL     ??Subroutine93_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_176:
   \   000033   701D         JNZ       ??CrossCallReturnLabel_159
   3526            {
   3527              if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   \   000035                ; Setup parameters for call to function ZDSecMgrEntryNew
   \   000035   AA..         MOV       R2,?XSP + 0
   \   000037   AB..         MOV       R3,?XSP + 1
   \   000039   12....       LCALL     `??ZDSecMgrEntryNew::?relay`; Banked call to: ZDSecMgrEntryNew
   \   00003C   E9           MOV       A,R1
   \   00003D   7013         JNZ       ??CrossCallReturnLabel_159
   3528              {
   3529                entry->ami = ami;
   \   00003F   7402         MOV       A,#0x2
   \   000041   12....       LCALL     ?XSTACK_DISP0_8
   \   000044   12....       LCALL     ?Subroutine49 & 0xFFFF
   3530              }
   3531            }
   \                     ??CrossCallReturnLabel_60:
   \   000047   E0           MOVX      A,@DPTR
   \   000048   FA           MOV       R2,A
   \   000049   A3           INC       DPTR
   \   00004A   E0           MOVX      A,@DPTR
   \   00004B   F583         MOV       DPH,A
   \   00004D   8A82         MOV       DPL,R2
   \   00004F   12....       LCALL     ??Subroutine91_0 & 0xFFFF
   3532            // Write the link key
   3533            APSME_LinkKeySet( extAddr, key );
   \                     ??CrossCallReturnLabel_159:
   \   000052                ; Setup parameters for call to function APSME_LinkKeySet
   \   000052   740E         MOV       A,#0xe
   \   000054   12....       LCALL     ?XSTACK_DISP0_8
   \   000057   12....       LCALL     ?Subroutine66 & 0xFFFF
   \                     ??CrossCallReturnLabel_94:
   \   00005A   12....       LCALL     `??APSME_LinkKeySet::?relay`; Banked call to: APSME_LinkKeySet
   3534          
   3535          #if defined (SE_PROFILE)
   3536            // Mark the device as authenticated.
   3537            ZDSecMgrAuthenticationSet( extAddr, ZDSecMgr_Authenticated_CBCK );
   3538          #endif
   3539          
   3540            // Write the new established link key to NV.
   3541            ZDSecMgrWriteNV();
   \   00005D                ; Setup parameters for call to function ZDSecMgrWriteNV
   \   00005D   12....       LCALL     `??ZDSecMgrWriteNV::?relay`; Banked call to: ZDSecMgrWriteNV
   3542          }
   \   000060   02....       LJMP      ?Subroutine13 & 0xFFFF
   3543          
   3544          /******************************************************************************
   3545           * @fn          ZDSecMgrInitNV
   3546           *
   3547           * @brief       Initialize the SecMgr entry data in NV.
   3548           *
   3549           * @param       none
   3550           *
   3551           * @return      uint8 - <osal_nv_item_init> return codes
   3552           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3553          uint8 ZDSecMgrInitNV( void )
   \                     ZDSecMgrInitNV:
   3554          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   3555            uint8  status;
   3556            uint16 size;
   3557          
   3558            size = (uint16)( sizeof(ZDSecMgrEntry_t) * ZDSECMGR_ENTRY_MAX );
   3559          
   3560            status = osal_nv_item_init( ZCD_NV_APS_LINK_KEY_TABLE, size, NULL );
   \   000005                ; Setup parameters for call to function osal_nv_item_init
   \   000005   E4           CLR       A
   \   000006   F5..         MOV       ?V0,A
   \   000008   F5..         MOV       ?V1,A
   \   00000A   78..         MOV       R0,#?V0
   \   00000C   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00000F   7C57         MOV       R4,#0x57
   \   000011   7D00         MOV       R5,#0x0
   \   000013   7A4C         MOV       R2,#0x4c
   \   000015   7B00         MOV       R3,#0x0
   \   000017   12....       LCALL     `??osal_nv_item_init::?relay`; Banked call to: osal_nv_item_init
   \   00001A   7402         MOV       A,#0x2
   \   00001C   12....       LCALL     ?DEALLOC_XSTACK8
   \   00001F   E9           MOV       A,R1
   \   000020   FE           MOV       R6,A
   3561          
   3562            // The item does not already exist
   3563            if ( status != ZSUCCESS )
   \   000021   6003         JZ        ??ZDSecMgrInitNV_0
   3564            {
   3565              ZDSecMgrSetDefaultNV();
   \   000023                ; Setup parameters for call to function ZDSecMgrSetDefaultNV
   \   000023   12....       LCALL     `??ZDSecMgrSetDefaultNV::?relay`; Banked call to: ZDSecMgrSetDefaultNV
   3566            }
   3567          
   3568            return status;
   \                     ??ZDSecMgrInitNV_0:
   \   000026   02....       LJMP      ?Subroutine10 & 0xFFFF
   3569          }
   3570          
   3571          
   3572          /******************************************************************************
   3573           * @fn          ZDSecMgrSetDefaultNV
   3574           *
   3575           * @brief       Set default SecMgr entry data in NV.
   3576           *
   3577           * @param       none
   3578           *
   3579           * @return      none
   3580           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   A8..         MOV       R0,?XSP + 0
   \   000002   A9..         MOV       R1,?XSP + 1
   \   000004   88..         MOV       ?V0,R0
   \   000006   89..         MOV       ?V1,R1
   \   000008   78..         MOV       R0,#?V0
   \   00000A   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00000D   75..02       MOV       ?V0,#0x2
   \   000010   75..00       MOV       ?V1,#0x0
   \   000013   78..         MOV       R0,#?V0
   \   000015   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000018   7C00         MOV       R4,#0x0
   \   00001A   7D00         MOV       R5,#0x0
   \   00001C   7A4C         MOV       R2,#0x4c
   \   00001E   7B00         MOV       R3,#0x0
   \   000020   12....       LCALL     `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000023   7404         MOV       A,#0x4
   \   000025   12....       LCALL     ?DEALLOC_XSTACK8
   \   000028                REQUIRE ??Subroutine100_0
   \   000028                ; // Fall through to label ??Subroutine100_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3581          void ZDSecMgrSetDefaultNV( void )
   \                     ZDSecMgrSetDefaultNV:
   3582          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   3583            nvDeviceListHdr_t hdr;
   3584          
   3585            // Initialize the header
   3586            hdr.numRecs = 0;
   \   00000A   85..82       MOV       DPL,?XSP + 0
   \   00000D   85..83       MOV       DPH,?XSP + 1
   \   000010   E4           CLR       A
   \   000011   F0           MOVX      @DPTR,A
   \   000012   A3           INC       DPTR
   \   000013   F0           MOVX      @DPTR,A
   3587          
   3588            // Save off the header
   3589            osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof( nvDeviceListHdr_t ), &hdr );
   \   000014                ; Setup parameters for call to function osal_nv_write
   \   000014   02....       LJMP      ?Subroutine2 & 0xFFFF
   3590          }
   3591          
   3592          
   3593          
   3594          /*********************************************************************
   3595           * @fn      ZDSecMgrWriteNV()
   3596           *
   3597           * @brief   Save off the link key list to NV
   3598           *
   3599           * @param   none
   3600           *
   3601           * @return  none
   3602           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3603          void ZDSecMgrWriteNV( void )
   \                     ZDSecMgrWriteNV:
   3604          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   3605            uint16 i;
   3606            nvDeviceListHdr_t hdr;
   3607          
   3608            hdr.numRecs = 0;
   \   00000A   85..82       MOV       DPL,?XSP + 0
   \   00000D   85..83       MOV       DPH,?XSP + 1
   \   000010   E4           CLR       A
   \   000011   F0           MOVX      @DPTR,A
   \   000012   A3           INC       DPTR
   \   000013   F0           MOVX      @DPTR,A
   3609          
   3610            for ( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   \   000014   FE           MOV       R6,A
   \   000015   FF           MOV       R7,A
   3611            {
   3612              if ( ZDSecMgrEntries[i].ami != INVALID_NODE_ADDR )
   \                     ??ZDSecMgrWriteNV_0:
   \   000016   EE           MOV       A,R6
   \   000017   F8           MOV       R0,A
   \   000018   EF           MOV       A,R7
   \   000019   F9           MOV       R1,A
   \   00001A   E8           MOV       A,R0
   \   00001B   75F01D       MOV       B,#0x1d
   \   00001E   A4           MUL       AB
   \   00001F   F8           MOV       R0,A
   \   000020   AAF0         MOV       R2,B
   \   000022   75F01D       MOV       B,#0x1d
   \   000025   E9           MOV       A,R1
   \   000026   A4           MUL       AB
   \   000027   2A           ADD       A,R2
   \   000028   F9           MOV       R1,A
   \   000029   90....       MOV       DPTR,#ZDSecMgrEntries
   \   00002C   E0           MOVX      A,@DPTR
   \   00002D   28           ADD       A,R0
   \   00002E   F5..         MOV       ?V0,A
   \   000030   A3           INC       DPTR
   \   000031   E0           MOVX      A,@DPTR
   \   000032   39           ADDC      A,R1
   \   000033   F5..         MOV       ?V1,A
   \   000035   85..82       MOV       DPL,?V0
   \   000038   F583         MOV       DPH,A
   \   00003A   E0           MOVX      A,@DPTR
   \   00003B   64FE         XRL       A,#0xfe
   \   00003D   7003         JNZ       ??ZDSecMgrWriteNV_1
   \   00003F   A3           INC       DPTR
   \   000040   E0           MOVX      A,@DPTR
   \   000041   F4           CPL       A
   \                     ??ZDSecMgrWriteNV_1:
   \   000042   6049         JZ        ??ZDSecMgrWriteNV_2
   3613              {
   3614                // Save off the record
   3615                osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE,
   3616                        (uint16)((sizeof(nvDeviceListHdr_t)) + (hdr.numRecs * sizeof(ZDSecMgrEntry_t))),
   3617                                sizeof(ZDSecMgrEntry_t), &ZDSecMgrEntries[i] );
   \   000044                ; Setup parameters for call to function osal_nv_write
   \   000044   78..         MOV       R0,#?V0
   \   000046   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000049   75..1D       MOV       ?V0,#0x1d
   \   00004C   75..00       MOV       ?V1,#0x0
   \   00004F   78..         MOV       R0,#?V0
   \   000051   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000054   7404         MOV       A,#0x4
   \   000056   12....       LCALL     ?XSTACK_DISP0_8
   \   000059   12....       LCALL     ??Subroutine99_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_202:
   \   00005C   E8           MOV       A,R0
   \   00005D   75F01D       MOV       B,#0x1d
   \   000060   A4           MUL       AB
   \   000061   F8           MOV       R0,A
   \   000062   AAF0         MOV       R2,B
   \   000064   75F01D       MOV       B,#0x1d
   \   000067   E9           MOV       A,R1
   \   000068   A4           MUL       AB
   \   000069   2A           ADD       A,R2
   \   00006A   F9           MOV       R1,A
   \   00006B   E8           MOV       A,R0
   \   00006C   2402         ADD       A,#0x2
   \   00006E   FC           MOV       R4,A
   \   00006F   E4           CLR       A
   \   000070   39           ADDC      A,R1
   \   000071   FD           MOV       R5,A
   \   000072   7A4C         MOV       R2,#0x4c
   \   000074   7B00         MOV       R3,#0x0
   \   000076   12....       LCALL     `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000079   7404         MOV       A,#0x4
   \   00007B   12....       LCALL     ?DEALLOC_XSTACK8
   3618                hdr.numRecs++;
   \   00007E   85..82       MOV       DPL,?XSP + 0
   \   000081   85..83       MOV       DPH,?XSP + 1
   \   000084   E0           MOVX      A,@DPTR
   \   000085   2401         ADD       A,#0x1
   \   000087   F0           MOVX      @DPTR,A
   \   000088   A3           INC       DPTR
   \   000089   E0           MOVX      A,@DPTR
   \   00008A   3400         ADDC      A,#0x0
   \   00008C   F0           MOVX      @DPTR,A
   3619              }
   3620            }
   \                     ??ZDSecMgrWriteNV_2:
   \   00008D   0E           INC       R6
   \   00008E   EE           MOV       A,R6
   \   00008F   7001         JNZ       ??ZDSecMgrWriteNV_3
   \   000091   0F           INC       R7
   \                     ??ZDSecMgrWriteNV_3:
   \   000092   C3           CLR       C
   \   000093   9403         SUBB      A,#0x3
   \   000095   EF           MOV       A,R7
   \   000096   9400         SUBB      A,#0x0
   \   000098   5003         JNC       $+5
   \   00009A   02....       LJMP      ??ZDSecMgrWriteNV_0 & 0xFFFF
   3621          
   3622            // Save off the header
   3623            osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof( nvDeviceListHdr_t ), &hdr );
   \   00009D                ; Setup parameters for call to function osal_nv_write
   \   00009D   02....       LJMP      ?Subroutine2 & 0xFFFF
   3624          }
   3625          
   3626          /******************************************************************************
   3627           * @fn          ZDSecMgrRestoreFromNV
   3628           *
   3629           * @brief       Restore the SecMgr entry data from NV.
   3630           *
   3631           * @param       none
   3632           *
   3633           * @return      ZStatus_t ZSuccess or ZFailure
   3634           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3635          ZStatus_t ZDSecMgrRestoreFromNV( void )
   \                     ZDSecMgrRestoreFromNV:
   3636          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000   74F3         MOV       A,#-0xd
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 13
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   3637            uint8 x = 0;
   \   00000A   75..00       MOV       ?V4,#0x0
   3638            nvDeviceListHdr_t hdr;
   3639          
   3640            // Initialize the device list
   3641            if ( osal_nv_read( ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof(nvDeviceListHdr_t), &hdr ) == ZSUCCESS )
   \   00000D                ; Setup parameters for call to function osal_nv_read
   \   00000D   A8..         MOV       R0,?XSP + 0
   \   00000F   A9..         MOV       R1,?XSP + 1
   \   000011   88..         MOV       ?V0,R0
   \   000013   89..         MOV       ?V1,R1
   \   000015   78..         MOV       R0,#?V0
   \   000017   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00001A   75..02       MOV       ?V0,#0x2
   \   00001D   75..00       MOV       ?V1,#0x0
   \   000020   78..         MOV       R0,#?V0
   \   000022   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000025   7C00         MOV       R4,#0x0
   \   000027   7D00         MOV       R5,#0x0
   \   000029   7A4C         MOV       R2,#0x4c
   \   00002B   7B00         MOV       R3,#0x0
   \   00002D   12....       LCALL     `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   000030   7404         MOV       A,#0x4
   \   000032   12....       LCALL     ?DEALLOC_XSTACK8
   \   000035   E9           MOV       A,R1
   \   000036   606B         JZ        ??ZDSecMgrRestoreFromNV_0
   3642            {
   3643              // Read in the device list
   3644              for ( ; x < hdr.numRecs; x++ )
   3645              {
   3646                if ( osal_nv_read( ZCD_NV_APS_LINK_KEY_TABLE,
   3647                          (uint16)(sizeof(nvDeviceListHdr_t) + (x * sizeof(ZDSecMgrEntry_t))),
   3648                                sizeof(ZDSecMgrEntry_t), &ZDSecMgrEntries[x] ) == ZSUCCESS )
   3649                {
   3650                  ZDSecMgrEntries[x].lkd.apsmelkd.txFrmCntr += ( MAX_APS_FRAMECOUNTER_CHANGES + 1 );
   3651                }
   3652              }
   3653          
   3654              // Write the updated entry back to NV.
   3655              ZDSecMgrWriteNV();
   3656          
   3657              return ZSuccess;
   3658            }
   3659            return ZFailure;
   \   000038   7901         MOV       R1,#0x1
   \                     ??ZDSecMgrRestoreFromNV_1:
   \   00003A   7402         MOV       A,#0x2
   \   00003C   12....       LCALL     ?DEALLOC_XSTACK8
   \   00003F   7F05         MOV       R7,#0x5
   \   000041   02....       LJMP      ?BANKED_LEAVE_XDATA
   \                     ??ZDSecMgrRestoreFromNV_2:
   \   000044   E5..         MOV       A,?V4
   \   000046   75F01D       MOV       B,#0x1d
   \   000049   A4           MUL       AB
   \   00004A   FE           MOV       R6,A
   \   00004B   AFF0         MOV       R7,B
   \   00004D                ; Setup parameters for call to function osal_nv_read
   \   00004D   90....       MOV       DPTR,#ZDSecMgrEntries
   \   000050   E0           MOVX      A,@DPTR
   \   000051   2E           ADD       A,R6
   \   000052   F5..         MOV       ?V0,A
   \   000054   A3           INC       DPTR
   \   000055   E0           MOVX      A,@DPTR
   \   000056   3F           ADDC      A,R7
   \   000057   F5..         MOV       ?V1,A
   \   000059   78..         MOV       R0,#?V0
   \   00005B   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00005E   75..1D       MOV       ?V0,#0x1d
   \   000061   75..00       MOV       ?V1,#0x0
   \   000064   78..         MOV       R0,#?V0
   \   000066   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000069   EF           MOV       A,R7
   \   00006A   FB           MOV       R3,A
   \   00006B   EE           MOV       A,R6
   \   00006C   2402         ADD       A,#0x2
   \   00006E   FC           MOV       R4,A
   \   00006F   E4           CLR       A
   \   000070   3B           ADDC      A,R3
   \   000071   FD           MOV       R5,A
   \   000072   7A4C         MOV       R2,#0x4c
   \   000074   7B00         MOV       R3,#0x0
   \   000076   12....       LCALL     `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   000079   7404         MOV       A,#0x4
   \   00007B   12....       LCALL     ?DEALLOC_XSTACK8
   \   00007E   E9           MOV       A,R1
   \   00007F   7020         JNZ       ??ZDSecMgrRestoreFromNV_3
   \   000081   90....       MOV       DPTR,#__Constant_b
   \   000084   78..         MOV       R0,#?V0
   \   000086   12....       LCALL     ?L_MOV_X
   \   000089   90....       MOV       DPTR,#ZDSecMgrEntries
   \   00008C   E0           MOVX      A,@DPTR
   \   00008D   2E           ADD       A,R6
   \   00008E   F8           MOV       R0,A
   \   00008F   A3           INC       DPTR
   \   000090   E0           MOVX      A,@DPTR
   \   000091   3F           ADDC      A,R7
   \   000092   F9           MOV       R1,A
   \   000093   E8           MOV       A,R0
   \   000094   2414         ADD       A,#0x14
   \   000096   F582         MOV       DPL,A
   \   000098   E4           CLR       A
   \   000099   39           ADDC      A,R1
   \   00009A   F583         MOV       DPH,A
   \   00009C   78..         MOV       R0,#?V0
   \   00009E   12....       LCALL     ?L_ADD_TO_X
   \                     ??ZDSecMgrRestoreFromNV_3:
   \   0000A1   05..         INC       ?V4
   \                     ??ZDSecMgrRestoreFromNV_0:
   \   0000A3   85..82       MOV       DPL,?XSP + 0
   \   0000A6   85..83       MOV       DPH,?XSP + 1
   \   0000A9   12....       LCALL     ??Subroutine99_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_203:
   \   0000AC   C3           CLR       C
   \   0000AD   E5..         MOV       A,?V4
   \   0000AF   98           SUBB      A,R0
   \   0000B0   E4           CLR       A
   \   0000B1   99           SUBB      A,R1
   \   0000B2   4090         JC        ??ZDSecMgrRestoreFromNV_2
   \   0000B4                ; Setup parameters for call to function ZDSecMgrWriteNV
   \   0000B4   12....       LCALL     `??ZDSecMgrWriteNV::?relay`; Banked call to: ZDSecMgrWriteNV
   \   0000B7   7900         MOV       R1,#0x0
   \   0000B9   02....       LJMP      ??ZDSecMgrRestoreFromNV_1 & 0xFFFF
   3660          }
   3661          
   3662          /******************************************************************************
   3663           * @fn          ZDSecMgrAPSRemove
   3664           *
   3665           * @brief       Remove device from network.
   3666           *
   3667           * @param       nwkAddr - device's NWK address
   3668           * @param       extAddr - device's Extended address
   3669           * @param       parentAddr - parent's NWK address
   3670           *
   3671           * @return      ZStatus_t
   3672           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3673          ZStatus_t ZDSecMgrAPSRemove( uint16 nwkAddr, uint8 *extAddr, uint16 parentAddr )
   \                     ZDSecMgrAPSRemove:
   3674          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 10
   \   000004   74F6         MOV       A,#-0xa
   \   000006   12....       LCALL     ?ALLOC_XSTACK8
   3675            ZDSecMgrDevice_t device;
   3676          
   3677            if ( ( nwkAddr == INVALID_NODE_ADDR ) ||
   3678                 ( extAddr == NULL )              ||
   3679                 ( parentAddr == INVALID_NODE_ADDR ) )
   \   000009   74FE         MOV       A,#-0x2
   \   00000B   6A           XRL       A,R2
   \   00000C   7003         JNZ       ??ZDSecMgrAPSRemove_0
   \   00000E   74FF         MOV       A,#-0x1
   \   000010   6B           XRL       A,R3
   \                     ??ZDSecMgrAPSRemove_0:
   \   000011   6016         JZ        ??ZDSecMgrAPSRemove_1
   \   000013   EC           MOV       A,R4
   \   000014   4D           ORL       A,R5
   \   000015   6012         JZ        ??ZDSecMgrAPSRemove_1
   \   000017   740A         MOV       A,#0xa
   \   000019   12....       LCALL     ?XSTACK_DISP0_8
   \   00001C   12....       LCALL     ??Subroutine99_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_204:
   \   00001F   74FE         MOV       A,#-0x2
   \   000021   68           XRL       A,R0
   \   000022   7003         JNZ       ??ZDSecMgrAPSRemove_2
   \   000024   74FF         MOV       A,#-0x1
   \   000026   69           XRL       A,R1
   \                     ??ZDSecMgrAPSRemove_2:
   \   000027   7004         JNZ       ??ZDSecMgrAPSRemove_3
   3680            {
   3681              return ( ZFailure );
   \                     ??ZDSecMgrAPSRemove_1:
   \   000029   7901         MOV       R1,#0x1
   \   00002B   8018         SJMP      ??ZDSecMgrAPSRemove_4
   3682            }
   3683          
   3684            device.nwkAddr = nwkAddr;
   \                     ??ZDSecMgrAPSRemove_3:
   \   00002D   12....       LCALL     ?Subroutine21 & 0xFFFF
   3685            device.extAddr = extAddr;
   \                     ??CrossCallReturnLabel_217:
   \   000030   12....       LCALL     ?XSTACK_DISP0_8
   \   000033   EC           MOV       A,R4
   \   000034   F0           MOVX      @DPTR,A
   \   000035   A3           INC       DPTR
   \   000036   ED           MOV       A,R5
   \   000037   F0           MOVX      @DPTR,A
   3686            device.parentAddr = parentAddr;
   \   000038   7404         MOV       A,#0x4
   \   00003A   12....       LCALL     ?XSTACK_DISP0_8
   \   00003D   12....       LCALL     ?Subroutine17 & 0xFFFF
   3687          
   3688            // remove device
   3689            ZDSecMgrDeviceRemove( &device );
   \                     ??CrossCallReturnLabel_3:
   \   000040   12....       LCALL     `??ZDSecMgrDeviceRemove::?relay`; Banked call to: ZDSecMgrDeviceRemove
   3690          
   3691            return ( ZSuccess );
   \   000043   7900         MOV       R1,#0x0
   \                     ??ZDSecMgrAPSRemove_4:
   \   000045   02....       LJMP      ?Subroutine6 & 0xFFFF
   3692          }

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for ZDSecMgrTCMasterKey>`:
   \   000000   00           DB 0
   \   000001   00           DB 0
   \   000002   00           DB 0
   \   000003   00           DB 0
   \   000004   00           DB 0
   \   000005   00           DB 0
   \   000006   00           DB 0
   \   000007   00           DB 0
   \   000008   89           DB 137
   \   000009   67           DB 103
   \   00000A   45           DB 69
   \   00000B   23           DB 35
   \   00000C   01           DB 1
   \   00000D   EF           DB 239
   \   00000E   CD           DB 205
   \   00000F   AB           DB 171

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for ZDSecMgrAppKeyType>`:
   \   000000   03           DB 3

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_b:
   \   000000   0B000000     DD 11

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrMasterKeyInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrMasterKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAddrStore::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAddrStore

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrExtAddrStore::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrExtAddrStore

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrExtAddrLookup::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrExtAddrLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrMasterKeyLookup::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrMasterKeyLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrMasterKeyStore::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrMasterKeyStore

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEntryInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEntryLookup::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEntryLookupAMI::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookupAMI

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEntryLookupExt::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookupExt

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEntryFree::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryFree

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEntryNew::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryNew

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrCtrlInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrCtrlRelease::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlRelease

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrCtrlLookup::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrCtrlSet::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlSet

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrCtrlAdd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlAdd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrCtrlTerm::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlTerm

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrCtrlReset::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlReset

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrMasterKeyLoad::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrMasterKeyLoad

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAppKeyGet::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAppKeyGet

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAppKeyReq::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAppKeyReq

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEstablishKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEstablishKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrSendMasterKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSendMasterKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrSendNwkKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSendNwkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceEntryRemove::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceEntryRemove

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAddrMgrUpdate::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAddrMgrUpdate

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceEntryAdd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceEntryAdd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceCtrlHandler::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceCtrlHandler

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceCtrlSetup::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceCtrlSetup

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceCtrlUpdate::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceCtrlUpdate

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_SKA_TimerExpired::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_SKA_TimerExpired

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceRemove::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceRemove

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceValidateSKKE::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidateSKKE

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceValidateRM::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidateRM

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceValidateCM::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidateCM

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceValidate::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidate

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceJoin::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceJoin

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceJoinDirect::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceJoinDirect

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceJoinFwd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceJoinFwd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceNew::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceNew

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAssocDeviceAuth::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAssocDeviceAuth

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAuthInitiate::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthInitiate

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAuthNwkKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthNwkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrConfig::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrConfig

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrPermitJoining::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrPermitJoining

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrPermitJoiningTimeout::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrPermitJoiningTimeout

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrNewDeviceEvent::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrNewDeviceEvent

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEvent::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEvent

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEstablishKeyCfm::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEstablishKeyCfm

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrTCExtAddrCheck::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrTCExtAddrCheck

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrTCDataLoad::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrTCDataLoad

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEstablishKeyInd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEstablishKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrTransportKeyInd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrTransportKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrUpdateDeviceInd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrUpdateDeviceInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrRemoveDeviceInd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRemoveDeviceInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrRequestKeyInd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRequestKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrSwitchKeyInd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSwitchKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAuthenticateInd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticateInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAuthenticateCfm::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticateCfm

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrUpdateNwkKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrUpdateNwkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrSwitchNwkKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSwitchNwkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAppKeyTypeSet::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAppKeyTypeSet

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_MasterKeyGet::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_MasterKeyGet

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_LinkKeySet::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_LinkKeySet

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAuthenticationSet::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticationSet

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAuthenticationCheck::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticationCheck

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_LinkKeyDataGet::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_LinkKeyDataGet

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_KeyFwdToChild::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_KeyFwdToChild

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAddLinkKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAddLinkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrInitNV::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrInitNV

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrSetDefaultNV::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSetDefaultNV

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrWriteNV::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrWriteNV

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrRestoreFromNV::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRestoreFromNV

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAPSRemove::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAPSRemove
   3693          
   3694          /******************************************************************************
   3695          ******************************************************************************/
   3696          

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      0     10   APSME_KeyFwdToChild
        0     10   -> AssocGetWithExt
        0     10   -> ZDSecMgrAssocDeviceAuth
      0     11   APSME_LinkKeyDataGet
        0     11   -> ZDSecMgrEntryLookupExt
      0     34   APSME_LinkKeySet
        0     17   -> ZDSecMgrEntryLookupExt
        0     20   -> osal_memcpy
      0     11   APSME_MasterKeyGet
        0     11   -> ZDSecMgrExtAddrLookup
        0     11   -> ZDSecMgrMasterKeyLookup
      0      9   APSME_SKA_TimerExpired
        0      9   -> ZDSecMgrDeviceCtrlUpdate
      2     12   ZDSecMgrAPSRemove
        2     10   -> ZDSecMgrDeviceRemove
      0     18   ZDSecMgrAddLinkKey
        0     14   -> APSME_LinkKeySet
        0     16   -> ZDSecMgrAddrStore
        0     14   -> ZDSecMgrEntryLookupAMI
        0     14   -> ZDSecMgrEntryNew
        0     14   -> ZDSecMgrWriteNV
      0     36   ZDSecMgrAddrMgrUpdate
        0     22   -> AddrMgrEntryGet
        0     22   -> AddrMgrEntryUpdate
      0     38   ZDSecMgrAddrStore
        0     22   -> AddrMgrEntryUpdate
        0     22   -> AddrMgrExtAddrSet
      3     59   ZDSecMgrAppKeyGet
        2      0   -> SSP_GetTrueRand
      0     59   ZDSecMgrAppKeyReq
        0     51   -> APSME_LookupExtAddr
        0     51   -> APSME_LookupNwkAddr
        0     51   -> APSME_TransportKeyReq
        0     59   -> ZDSecMgrAppKeyGet
      2      0   ZDSecMgrAppKeyTypeSet
      2     35   ZDSecMgrAssocDeviceAuth
      0     16   ZDSecMgrAuthInitiate
        0     16   -> APSME_AuthenticateReq
        0     16   -> APSME_LookupNwkAddr
      2     10   ZDSecMgrAuthNwkKey
        2      0   -> osal_set_event
      2      0   ZDSecMgrAuthenticateCfm
        2      0   -> osal_set_event
      0     32   ZDSecMgrAuthenticateInd
        0     32   -> APSME_AuthenticateReq
        0     32   -> AddrMgrEntryUpdate
        0     32   -> AddrMgrExtAddrSet
      0      0   ZDSecMgrAuthenticationCheck
      1     11   ZDSecMgrAuthenticationSet
        0     11   -> ZDSecMgrEntryLookupExt
      2      0   ZDSecMgrConfig
        2      0   -> APSME_SecurityNM
      0     28   ZDSecMgrCtrlAdd
        0     14   -> ZDSecMgrCtrlSet
      2      0   ZDSecMgrCtrlInit
        2      0   -> osal_mem_alloc
      0     23   ZDSecMgrCtrlLookup
      2      0   ZDSecMgrCtrlRelease
      0     28   ZDSecMgrCtrlReset
        0     12   -> ZDSecMgrCtrlAdd
        0     12   -> ZDSecMgrCtrlLookup
        0     14   -> ZDSecMgrCtrlSet
      1     23   ZDSecMgrCtrlSet
      2     11   ZDSecMgrCtrlTerm
        2      2   -> ZDSecMgrCtrlLookup
      1     42   ZDSecMgrDeviceCtrlHandler
        0      9   -> ZDSecMgrEstablishKey
        0      9   -> ZDSecMgrSendMasterKey
        0      9   -> ZDSecMgrSendNwkKey
        0      9   -> osal_start_timerEx
      2      0   ZDSecMgrDeviceCtrlSetup
        2      0   -> ZDSecMgrDeviceCtrlHandler
      0     22   ZDSecMgrDeviceCtrlUpdate
        0     13   -> ZDSecMgrCtrlLookup
        0     13   -> ZDSecMgrEntryLookupExt
      0     28   ZDSecMgrDeviceEntryAdd
        0     14   -> ZDSecMgrAddrMgrUpdate
        0     14   -> ZDSecMgrCtrlAdd
        0     14   -> ZDSecMgrCtrlReset
        0     14   -> ZDSecMgrDeviceEntryRemove
        0     14   -> ZDSecMgrEntryLookup
        0     14   -> ZDSecMgrEntryLookupAMI
        0     14   -> ZDSecMgrEntryNew
      0     23   ZDSecMgrDeviceEntryRemove
        0      9   -> ZDSecMgrCtrlTerm
      0     19   ZDSecMgrDeviceJoin
        0      9   -> ZDSecMgrDeviceRemove
        0      9   -> ZDSecMgrDeviceValidate
        0      9   -> ZDSecMgrSendNwkKey
      0      9   ZDSecMgrDeviceJoinDirect
        0      9   -> AssocGetWithShort
        0      9   -> ZDSecMgrAssocDeviceAuth
        0      9   -> ZDSecMgrDeviceJoin
      2      8   ZDSecMgrDeviceJoinFwd
        2      8   -> APSME_UpdateDeviceReq
      2     35   ZDSecMgrDeviceNew
        2      0   -> ZDSecMgrDeviceJoinDirect
      0     38   ZDSecMgrDeviceRemove
        0     19   -> APSME_RemoveDeviceReq
        0     19   -> AssocGetWithExt
        0     19   -> NLME_GetShortAddr
        0     19   -> NLME_LeaveReq
      2      9   ZDSecMgrDeviceValidate
        2      0   -> ZDSecMgrDeviceValidateRM
      0     16   ZDSecMgrDeviceValidateCM
        0     16   -> ZDSecMgrAddrStore
        0     14   -> ZDSecMgrDeviceEntryAdd
        0     14   -> ZDSecMgrMasterKeyLoad
      2      0   ZDSecMgrDeviceValidateRM
      0     44   ZDSecMgrDeviceValidateSKKE
        0     13   -> ZDSecMgrDeviceEntryAdd
        0     13   -> ZDSecMgrExtAddrLookup
        0     13   -> ZDSecMgrMasterKeyLookup
      2      0   ZDSecMgrEntryFree
      2      0   ZDSecMgrEntryInit
        2      0   -> ZDSecMgrRestoreFromNV
        2      0   -> osal_mem_alloc
      0     37   ZDSecMgrEntryLookup
        0     23   -> AddrMgrEntryLookupNwk
      0     24   ZDSecMgrEntryLookupAMI
      0     28   ZDSecMgrEntryLookupExt
        0     11   -> ZDSecMgrEntryLookupAMI
        0     11   -> ZDSecMgrExtAddrLookup
      0     24   ZDSecMgrEntryNew
      0     26   ZDSecMgrEstablishKey
        0     17   -> APSME_EstablishKeyReq
        0     17   -> NLME_GetShortAddr
      2      0   ZDSecMgrEstablishKeyCfm
        2      0   -> ZDSecMgrDeviceCtrlUpdate
      1     31   ZDSecMgrEstablishKeyInd
        0     31   -> APSME_EstablishKeyRsp
        0     31   -> ZDSecMgrDeviceValidateSKKE
        0     31   -> ZDSecMgrTCDataLoad
        0     31   -> ZDSecMgrTCExtAddrCheck
      1     33   ZDSecMgrEvent
        0     33   -> AddrMgrEntryGet
        0     33   -> ZDSecMgrDeviceCtrlHandler
        0     33   -> osal_start_timerEx
      0     41   ZDSecMgrExtAddrLookup
        0     22   -> AddrMgrEntryLookupExt
        0     22   -> AddrMgrExtAddrSet
      0     24   ZDSecMgrExtAddrStore
        0     22   -> AddrMgrEntryUpdate
        0     22   -> AddrMgrExtAddrSet
      2      0   ZDSecMgrInit
        2      0   -> APSME_SecurityNM
      0     12   ZDSecMgrInitNV
        0     10   -> ZDSecMgrSetDefaultNV
        0     12   -> osal_nv_item_init
      2      0   ZDSecMgrMasterKeyInit
        2      0   -> osal_mem_alloc
      0     36   ZDSecMgrMasterKeyLoad
        0     19   -> ZDSecMgrExtAddrLookup
        0     19   -> ZDSecMgrMasterKeyLookup
        0     19   -> ZDSecMgrMasterKeyStore
        0     22   -> osal_memcpy
      0     33   ZDSecMgrMasterKeyLookup
      0     36   ZDSecMgrMasterKeyStore
        0     17   -> osal_memcpy
        0     14   -> osal_memset
      1     35   ZDSecMgrNewDeviceEvent
        0     35   -> AddrMgrEntryGet
        0     35   -> AssocMatchDeviceStatus
        0     35   -> AssocRemove
        0     35   -> NLME_GetShortAddr
        0     35   -> ZDSecMgrAssocDeviceAuth
        0     35   -> ZDSecMgrDeviceNew
      2      0   ZDSecMgrPermitJoining
      2      0   ZDSecMgrPermitJoiningTimeout
      0     19   ZDSecMgrRemoveDeviceInd
        0     19   -> APSME_LookupNwkAddr
        0     19   -> NLME_GetShortAddr
        0     19   -> ZDSecMgrDeviceRemove
      2      0   ZDSecMgrRequestKeyInd
        2      0   -> ZDSecMgrAppKeyReq
      0     19   ZDSecMgrRestoreFromNV
        0     15   -> ZDSecMgrWriteNV
        0     19   -> osal_nv_read
      0     32   ZDSecMgrSendMasterKey
        0     23   -> APSME_TransportKeyReq
        0     23   -> NLME_GetShortAddr
        0     23   -> ZDSecMgrMasterKeyLookup
      1     34   ZDSecMgrSendNwkKey
        0     25   -> APSME_TransportKeyReq
        0     25   -> NLME_GetShortAddr
      0     26   ZDSecMgrSetDefaultNV
        0     16   -> osal_nv_write
      2      0   ZDSecMgrSwitchKeyInd
        2      0   -> SSP_SwitchNwkKey
        2      0   -> ZDApp_NVUpdate
      1     12   ZDSecMgrSwitchNwkKey
        0     12   -> APSME_SwitchKeyReq
        0     12   -> SSP_SwitchNwkKey
        0     12   -> ZDApp_NVUpdate
      0     47   ZDSecMgrTCDataLoad
        0     16   -> ZDSecMgrAddrStore
        0     14   -> ZDSecMgrMasterKeyLookup
        0     14   -> ZDSecMgrMasterKeyStore
      0     48   ZDSecMgrTCExtAddrCheck
        0     17   -> AddrMgrExtAddrEqual
        0     17   -> AddrMgrExtAddrLookup
      0     10   ZDSecMgrTransportKeyInd
        0     10   -> SSP_SwitchNwkKey
        0     10   -> SSP_UpdateNwkKey
        0     10   -> ZDSecMgrAuthNwkKey
        0     10   -> ZDSecMgrTCDataLoad
      2     10   ZDSecMgrUpdateDeviceInd
        2     10   -> ZDSecMgrDeviceJoin
      1     23   ZDSecMgrUpdateNwkKey
        0     23   -> APSME_TransportKeyReq
        0     23   -> SSP_UpdateNwkKey
        0     23   -> ZDApp_NVUpdate
      0     31   ZDSecMgrWriteNV
        0     16   -> osal_nv_write


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  ?<Initializer for ZDSecMgrAppKeyType>
      16  ?<Initializer for ZDSecMgrTCMasterKey>
       2  ??Subroutine100_0
       3  ??Subroutine101_0
       5  ??Subroutine102_0
       8  ??Subroutine103_0
       5  ??Subroutine104_0
       6  ??Subroutine105_0
       8  ??Subroutine75_0
       5  ??Subroutine76_0
       9  ??Subroutine77_0
      12  ??Subroutine78_0
       6  ??Subroutine79_0
       6  ??Subroutine80_0
       4  ??Subroutine81_0
       3  ??Subroutine82_0
       5  ??Subroutine83_0
       9  ??Subroutine84_0
       4  ??Subroutine85_0
       7  ??Subroutine86_0
       2  ??Subroutine87_0
       3  ??Subroutine88_0
       5  ??Subroutine89_0
       6  ??Subroutine90_0
       4  ??Subroutine91_0
       3  ??Subroutine92_0
       6  ??Subroutine93_0
       6  ??Subroutine94_0
       6  ??Subroutine95_0
       6  ??Subroutine96_0
       6  ??Subroutine97_0
       2  ??Subroutine98_0
       4  ??Subroutine99_0
       7  ?Subroutine0
       2  ?Subroutine1
       5  ?Subroutine10
       5  ?Subroutine11
       2  ?Subroutine12
       5  ?Subroutine13
       5  ?Subroutine14
       2  ?Subroutine15
       6  ?Subroutine16
       8  ?Subroutine17
      10  ?Subroutine18
       6  ?Subroutine19
      40  ?Subroutine2
       4  ?Subroutine20
       6  ?Subroutine21
      11  ?Subroutine22
       6  ?Subroutine23
       9  ?Subroutine24
      12  ?Subroutine25
       9  ?Subroutine26
       6  ?Subroutine27
       6  ?Subroutine28
       6  ?Subroutine29
       5  ?Subroutine3
       6  ?Subroutine30
       3  ?Subroutine31
       9  ?Subroutine32
       4  ?Subroutine33
       7  ?Subroutine34
       6  ?Subroutine35
       9  ?Subroutine36
       1  ?Subroutine37
       4  ?Subroutine38
      12  ?Subroutine39
       2  ?Subroutine4
      14  ?Subroutine40
      16  ?Subroutine41
       8  ?Subroutine42
      13  ?Subroutine43
      14  ?Subroutine44
       7  ?Subroutine45
       6  ?Subroutine46
       5  ?Subroutine47
       6  ?Subroutine48
       4  ?Subroutine49
       8  ?Subroutine5
       9  ?Subroutine50
      11  ?Subroutine51
       7  ?Subroutine52
       7  ?Subroutine53
       7  ?Subroutine54
       4  ?Subroutine55
      16  ?Subroutine56
       7  ?Subroutine57
       9  ?Subroutine58
      12  ?Subroutine59
       2  ?Subroutine6
      14  ?Subroutine60
       9  ?Subroutine61
      11  ?Subroutine62
       7  ?Subroutine63
       8  ?Subroutine64
       6  ?Subroutine65
      10  ?Subroutine66
       8  ?Subroutine67
       6  ?Subroutine68
      12  ?Subroutine69
       6  ?Subroutine7
      10  ?Subroutine70
       4  ?Subroutine71
      11  ?Subroutine72
       6  ?Subroutine73
       6  ?Subroutine74
       5  ?Subroutine8
       5  ?Subroutine9
      56  APSME_KeyFwdToChild
       6  APSME_KeyFwdToChild::?relay
      83  APSME_LinkKeyDataGet
       6  APSME_LinkKeyDataGet::?relay
      89  APSME_LinkKeySet
       6  APSME_LinkKeySet::?relay
      55  APSME_MasterKeyGet
       6  APSME_MasterKeyGet::?relay
      20  APSME_SKA_TimerExpired
       6  APSME_SKA_TimerExpired::?relay
      10  TrustCenterLinkKey
      72  ZDSecMgrAPSRemove
       6  ZDSecMgrAPSRemove::?relay
      99  ZDSecMgrAddLinkKey
       6  ZDSecMgrAddLinkKey::?relay
      66  ZDSecMgrAddrMgrUpdate
       6  ZDSecMgrAddrMgrUpdate::?relay
      69  ZDSecMgrAddrStore
       6  ZDSecMgrAddrStore::?relay
      33  ZDSecMgrAppKeyGet
       6  ZDSecMgrAppKeyGet::?relay
     248  ZDSecMgrAppKeyReq
       6  ZDSecMgrAppKeyReq::?relay
       1  ZDSecMgrAppKeyType
      23  ZDSecMgrAppKeyTypeSet
       6  ZDSecMgrAppKeyTypeSet::?relay
      23  ZDSecMgrAssocDeviceAuth
       6  ZDSecMgrAssocDeviceAuth::?relay
      59  ZDSecMgrAuthInitiate
       6  ZDSecMgrAuthInitiate::?relay
      27  ZDSecMgrAuthNwkKey
       6  ZDSecMgrAuthNwkKey::?relay
      50  ZDSecMgrAuthenticateCfm
       6  ZDSecMgrAuthenticateCfm::?relay
     132  ZDSecMgrAuthenticateInd
       6  ZDSecMgrAuthenticateInd::?relay
       5  ZDSecMgrAuthenticationCheck
       6  ZDSecMgrAuthenticationCheck::?relay
      40  ZDSecMgrAuthenticationSet
       6  ZDSecMgrAuthenticationSet::?relay
       3  ZDSecMgrConfig
       6  ZDSecMgrConfig::?relay
      96  ZDSecMgrCtrlAdd
       6  ZDSecMgrCtrlAdd::?relay
       2  ZDSecMgrCtrlData
      68  ZDSecMgrCtrlInit
       6  ZDSecMgrCtrlInit::?relay
      99  ZDSecMgrCtrlLookup
       6  ZDSecMgrCtrlLookup::?relay
      18  ZDSecMgrCtrlRelease
       6  ZDSecMgrCtrlRelease::?relay
      75  ZDSecMgrCtrlReset
       6  ZDSecMgrCtrlReset::?relay
      76  ZDSecMgrCtrlSet
       6  ZDSecMgrCtrlSet::?relay
      41  ZDSecMgrCtrlTerm
       6  ZDSecMgrCtrlTerm::?relay
     103  ZDSecMgrDeviceCtrlHandler
       6  ZDSecMgrDeviceCtrlHandler::?relay
      58  ZDSecMgrDeviceCtrlSetup
       6  ZDSecMgrDeviceCtrlSetup::?relay
      93  ZDSecMgrDeviceCtrlUpdate
       6  ZDSecMgrDeviceCtrlUpdate::?relay
     159  ZDSecMgrDeviceEntryAdd
       6  ZDSecMgrDeviceEntryAdd::?relay
      25  ZDSecMgrDeviceEntryRemove
       6  ZDSecMgrDeviceEntryRemove::?relay
      36  ZDSecMgrDeviceJoin
       6  ZDSecMgrDeviceJoin::?relay
      28  ZDSecMgrDeviceJoinDirect
       6  ZDSecMgrDeviceJoinDirect::?relay
     159  ZDSecMgrDeviceJoinFwd
       6  ZDSecMgrDeviceJoinFwd::?relay
       9  ZDSecMgrDeviceNew
       6  ZDSecMgrDeviceNew::?relay
     167  ZDSecMgrDeviceRemove
       6  ZDSecMgrDeviceRemove::?relay
      49  ZDSecMgrDeviceValidate
       6  ZDSecMgrDeviceValidate::?relay
      90  ZDSecMgrDeviceValidateCM
       6  ZDSecMgrDeviceValidateCM::?relay
      17  ZDSecMgrDeviceValidateRM
       6  ZDSecMgrDeviceValidateRM::?relay
      52  ZDSecMgrDeviceValidateSKKE
       6  ZDSecMgrDeviceValidateSKKE::?relay
       2  ZDSecMgrEntries
      17  ZDSecMgrEntryFree
       6  ZDSecMgrEntryFree::?relay
      62  ZDSecMgrEntryInit
       6  ZDSecMgrEntryInit::?relay
     111  ZDSecMgrEntryLookup
       6  ZDSecMgrEntryLookup::?relay
      77  ZDSecMgrEntryLookupAMI
       6  ZDSecMgrEntryLookupAMI::?relay
      42  ZDSecMgrEntryLookupExt
       6  ZDSecMgrEntryLookupExt::?relay
     115  ZDSecMgrEntryNew
       6  ZDSecMgrEntryNew::?relay
      97  ZDSecMgrEstablishKey
       6  ZDSecMgrEstablishKey::?relay
      19  ZDSecMgrEstablishKeyCfm
       6  ZDSecMgrEstablishKeyCfm::?relay
     229  ZDSecMgrEstablishKeyInd
       6  ZDSecMgrEstablishKeyInd::?relay
     273  ZDSecMgrEvent
       6  ZDSecMgrEvent::?relay
      69  ZDSecMgrExtAddrLookup
       6  ZDSecMgrExtAddrLookup::?relay
      68  ZDSecMgrExtAddrStore
       6  ZDSecMgrExtAddrStore::?relay
       3  ZDSecMgrInit
       6  ZDSecMgrInit::?relay
      41  ZDSecMgrInitNV
       6  ZDSecMgrInitNV::?relay
       2  ZDSecMgrMasterKeyData
      59  ZDSecMgrMasterKeyInit
       6  ZDSecMgrMasterKeyInit::?relay
      84  ZDSecMgrMasterKeyLoad
       6  ZDSecMgrMasterKeyLoad::?relay
      92  ZDSecMgrMasterKeyLookup
       6  ZDSecMgrMasterKeyLookup::?relay
     136  ZDSecMgrMasterKeyStore
       6  ZDSecMgrMasterKeyStore::?relay
     182  ZDSecMgrNewDeviceEvent
       6  ZDSecMgrNewDeviceEvent::?relay
      39  ZDSecMgrPermitJoining
       6  ZDSecMgrPermitJoining::?relay
       1  ZDSecMgrPermitJoiningEnabled
       1  ZDSecMgrPermitJoiningTimed
      24  ZDSecMgrPermitJoiningTimeout
       6  ZDSecMgrPermitJoiningTimeout::?relay
      73  ZDSecMgrRemoveDeviceInd
       6  ZDSecMgrRemoveDeviceInd::?relay
      30  ZDSecMgrRequestKeyInd
       6  ZDSecMgrRequestKeyInd::?relay
     188  ZDSecMgrRestoreFromNV
       6  ZDSecMgrRestoreFromNV::?relay
     124  ZDSecMgrSendMasterKey
       6  ZDSecMgrSendMasterKey::?relay
     200  ZDSecMgrSendNwkKey
       6  ZDSecMgrSendNwkKey::?relay
      23  ZDSecMgrSetDefaultNV
       6  ZDSecMgrSetDefaultNV::?relay
      23  ZDSecMgrSwitchKeyInd
       6  ZDSecMgrSwitchKeyInd::?relay
      42  ZDSecMgrSwitchNwkKey
       6  ZDSecMgrSwitchNwkKey::?relay
       1  ZDSecMgrTCAuthenticated
      79  ZDSecMgrTCDataLoad
       6  ZDSecMgrTCDataLoad::?relay
       1  ZDSecMgrTCDataLoaded
       8  ZDSecMgrTCExtAddr
      52  ZDSecMgrTCExtAddrCheck
       6  ZDSecMgrTCExtAddrCheck::?relay
      16  ZDSecMgrTCMasterKey
     142  ZDSecMgrTransportKeyInd
       6  ZDSecMgrTransportKeyInd::?relay
      48  ZDSecMgrUpdateDeviceInd
       6  ZDSecMgrUpdateDeviceInd::?relay
     104  ZDSecMgrUpdateNwkKey
       6  ZDSecMgrUpdateNwkKey::?relay
     160  ZDSecMgrWriteNV
       6  ZDSecMgrWriteNV::?relay
       4  __Constant_b

 
 6 645 bytes in segment BANKED_CODE
   456 bytes in segment BANK_RELAYS
    17 bytes in segment XDATA_I
    17 bytes in segment XDATA_ID
     4 bytes in segment XDATA_ROM_C
    28 bytes in segment XDATA_Z
 
   473 bytes of CODE     memory
     0 bytes of CONST    memory (+ 4 bytes shared)
 6 645 bytes of HUGECODE memory
    45 bytes of XDATA    memory

Errors: none
Warnings: none
