###############################################################################
#
# IAR C/C++ Compiler V10.20.1.5333 for 8051               18/Jun/2021  17:52:28
# Copyright 2004-2018 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  D:\SRC\DemoPrj\Components\osal\common\OSAL_Memory.c
#    Command line       =  
#        -f C:\Users\ADMINI~1\AppData\Local\Temp\EWDB58.tmp
#        (D:\SRC\DemoPrj\Components\osal\common\OSAL_Memory.c -D ZIGBEEPRO -D
#        HAL_UART=TRUE -D SERIAL_APP_PORT=0 -D LCD_SUPPORTED -lC
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\CoordinatorEB-Pro\List
#        -lA
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\CoordinatorEB-Pro\List
#        --diag_suppress Pe001,Pa010 -o
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\CoordinatorEB-Pro\Obj
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 8 -f
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wCoord.cfg
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRUE
#        -DZDO_COORDINATOR -DRTR_NWK -DBLINK_LEDS) -f
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg
#        (-DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0x1223
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_POLLED=3000
#        -DNWK_INDIRECT_MSG_TIMEOUT=7 -DMAX_RREQ_ENTRIES=8
#        -DAPSC_MAX_FRAME_RETRIES=3 -DNWK_MAX_DATA_RETRIES=2
#        -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9 -DAPS_MAX_GROUPS=16
#        -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 "-DCONST=const __code"
#        -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000
#        -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100
#        -DREJOIN_POLL_RATE=440) -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\ -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\SOURCE\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\ZMAIN\TI2530DB\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\MT\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\INCLUDE\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\TARGET\CC2530EB\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\MCU\CCSOC\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\INCLUDE\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\AF\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\NWK\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SEC\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SAPI\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SYS\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\ZDO\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\F8W\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\SERVICES\SADDR\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\SERVICES\SDATA\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\INCLUDE\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\HIGH_LEVEL\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW_LEVEL\srf04\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW_LEVEL\srf04\SINGLE_CHIP\
#        -Ohz --require_prototypes)
#    Locale             =  Chinese (Simplified)_CHN.936
#    List file          =  
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\CoordinatorEB-Pro\List\OSAL_Memory.lst
#    Object file        =  
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\CoordinatorEB-Pro\Obj\OSAL_Memory.r51
#
###############################################################################

D:\SRC\DemoPrj\Components\osal\common\OSAL_Memory.c
      1          /**************************************************************************************************
      2            Filename:       OSAL_Memory.c
      3            Revised:        $Date: 2009-02-05 16:41:18 -0800 (Thu, 05 Feb 2009) $
      4            Revision:       $Revision: 18998 $
      5          
      6            Description:    OSAL Heap Memory management functions.
      7          
      8          
      9            Copyright 2004-2007 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, 
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE, 
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com. 
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41           * INCLUDES
     42           */
     43          
     44          #include "comdef.h"
     45          #include "OSAL_Memory.h"
     46          #include "OnBoard.h"

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1
     47          #include "hal_assert.h"
     48          
     49          #if ( MAXMEMHEAP >= 32768 )
     50            #error MAXMEMHEAP is too big to manage!
     51          #endif
     52          
     53          // Minimum wasted bytes to justify splitting a block before allocation.
     54          #if !defined ( OSALMEM_MIN_BLKSZ )
     55            #define OSALMEM_MIN_BLKSZ    4
     56          #endif
     57          
     58          /* Profiling memory allocations showed that a significant % of very high
     59           * frequency allocations/frees are for block sizes less than or equal to 16.
     60           */
     61          #if !defined ( OSALMEM_SMALL_BLKSZ )
     62            #define OSALMEM_SMALL_BLKSZ  16
     63          #endif
     64          
     65          #if !defined ( OSALMEM_NODEBUG )
     66            #define OSALMEM_NODEBUG      TRUE
     67          #endif
     68          
     69          #if !defined ( OSALMEM_PROFILER )
     70            #define OSALMEM_PROFILER     FALSE
     71          #endif
     72          
     73          #if ( OSALMEM_PROFILER )
     74            #define OSALMEM_INIT   'X'
     75            #define OSALMEM_ALOC   'A'
     76            #define OSALMEM_REIN   'F'
     77          #endif
     78          
     79          /*********************************************************************
     80           * MACROS
     81           */
     82          
     83          /*
     84           *  The MAC_ASSERT macro is for use during debugging.
     85           *  The given expression must evaluate as "true" or else fatal error occurs.
     86           *  At that point, the call stack feature of the debugger can pinpoint where
     87           *  the problem occurred.
     88           *
     89           *  To disable this feature and save code size, the project should define
     90           *  OSALMEM_NODEBUG to TRUE.
     91           */
     92          #if ( OSALMEM_NODEBUG )
     93            #define OSALMEM_ASSERT( expr )
     94            #define OSALMEM_DEBUG( statement )
     95          #else
     96            #define OSALMEM_ASSERT( expr)        HAL_ASSERT( expr )
     97            #define OSALMEM_DEBUG( statement)    st( statement )
     98          #endif
     99          
    100          /*********************************************************************
    101           * TYPEDEFS
    102           */
    103          
    104          typedef uint16  osalMemHdr_t;
    105          
    106          /*********************************************************************
    107           * CONSTANTS
    108           */
    109          
    110          #define OSALMEM_IN_USE  0x8000
    111          
    112          /* This number sets the size of the small-block bucket. Although profiling
    113           * shows max simultaneous alloc of 16x18, timing without profiling overhead
    114           * shows that the best worst case is achieved with the following.
    115           */
    116          #define SMALLBLKHEAP    232
    117          
    118          // To maintain data alignment of the pointer returned, reserve the greater
    119          // space for the memory block header.
    120          #define HDRSZ  ( (sizeof ( halDataAlign_t ) > sizeof( osalMemHdr_t )) ? \
    121                            sizeof ( halDataAlign_t ) : sizeof( osalMemHdr_t ) )
    122          
    123          /*********************************************************************
    124           * GLOBAL VARIABLES
    125           */
    126          
    127          /*********************************************************************
    128           * EXTERNAL VARIABLES
    129           */
    130          
    131          /*********************************************************************
    132           * EXTERNAL FUNCTIONS
    133           */
    134          
    135          /*********************************************************************
    136           * LOCAL VARIABLES
    137           */
    138          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    139          static osalMemHdr_t *ff1;  // First free block in the small-block bucket.
   \                     ff1:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    140          static osalMemHdr_t *ff2;  // First free block after the small-block bucket.
   \                     ff2:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    141          
    142          #if ( OSALMEM_METRICS )
    143            static uint16 blkMax;  // Max cnt of all blocks ever seen at once.
    144            static uint16 blkCnt;  // Current cnt of all blocks.
    145            static uint16 blkFree; // Current cnt of free blocks.
    146            static uint16 memAlo;  // Current total memory allocated.
    147            static uint16 memMax;  // Max total memory ever allocated at once.
    148          #endif
    149          
    150          #if ( OSALMEM_PROFILER )
    151            #define OSALMEM_PROMAX  8
    152            /* The profiling buckets must differ by at least OSALMEM_MIN_BLKSZ; the
    153             * last bucket must equal the max alloc size. Set the bucket sizes to
    154             * whatever sizes necessary to show how your application is using memory.
    155             */
    156            static uint16 proCnt[OSALMEM_PROMAX] = { 
    157              OSALMEM_SMALL_BLKSZ, 48, 112, 176, 192, 224, 256, 65535 };
    158            static uint16 proCur[OSALMEM_PROMAX] = { 0 };
    159            static uint16 proMax[OSALMEM_PROMAX] = { 0 };
    160            static uint16 proTot[OSALMEM_PROMAX] = { 0 };
    161            static uint16 proSmallBlkMiss;
    162          #endif
    163          
    164          // Memory Allocation Heap.
    165          #if defined( EXTERNAL_RAM )
    166            static byte *theHeap = (byte *)EXT_RAM_BEG;
    167          #else

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    168            static halDataAlign_t _theHeap[ MAXMEMHEAP / sizeof( halDataAlign_t ) ];
   \                     _theHeap:
   \   000000                DS 3072
   \   000C00                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_I, align 1, keep-with-next
    169            static uint8 *theHeap = (uint8 *)_theHeap;
   \                     theHeap:
   \   000000                DS 2
   \   000002                REQUIRE `?<Initializer for theHeap>`
   \   000002                REQUIRE __INIT_XDATA_I
    170          #endif
    171          
    172          /*********************************************************************
    173           * LOCAL FUNCTIONS
    174           */
    175          
    176          /*********************************************************************
    177           * @fn      osal_mem_init
    178           *
    179           * @brief   Initialize the heap memory management system.
    180           *
    181           * @param   void
    182           *
    183           * @return  void
    184           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    185          void osal_mem_init( void )
   \                     osal_mem_init:
    186          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    187            osalMemHdr_t *tmp;
    188          
    189          #if ( OSALMEM_PROFILER )
    190            osal_memset( theHeap, OSALMEM_INIT, MAXMEMHEAP );
    191          #endif
    192          
    193            // Setup a NULL block at the end of the heap for fast comparisons with zero.
    194            tmp = (osalMemHdr_t *)theHeap + (MAXMEMHEAP / HDRSZ) - 1;
    195            *tmp = 0;
   \   000004   90....       MOV       DPTR,#theHeap
   \   000007   E0           MOVX      A,@DPTR
   \   000008   F8           MOV       R0,A
   \   000009   A3           INC       DPTR
   \   00000A   E0           MOVX      A,@DPTR
   \   00000B   C8           XCH       A,R0
   \   00000C   24FE         ADD       A,#-0x2
   \   00000E   F582         MOV       DPL,A
   \   000010   E8           MOV       A,R0
   \   000011   340B         ADDC      A,#0xb
   \   000013   F583         MOV       DPH,A
   \   000015   E4           CLR       A
   \   000016   F0           MOVX      @DPTR,A
   \   000017   A3           INC       DPTR
   \   000018   12....       LCALL     ?Subroutine1 & 0xFFFF
    196          
    197            // Setup a small-block bucket.
    198            tmp = (osalMemHdr_t *)theHeap;
    199            *tmp = SMALLBLKHEAP;
   \                     ??CrossCallReturnLabel_0:
   \   00001B   F583         MOV       DPH,A
   \   00001D   8882         MOV       DPL,R0
   \   00001F   74E8         MOV       A,#-0x18
   \   000021   F0           MOVX      @DPTR,A
   \   000022   A3           INC       DPTR
   \   000023   E4           CLR       A
   \   000024   F0           MOVX      @DPTR,A
    200          
    201            // Setup the wilderness.
    202            tmp = (osalMemHdr_t *)theHeap + (SMALLBLKHEAP / HDRSZ);
   \   000025   90....       MOV       DPTR,#theHeap
   \   000028   E0           MOVX      A,@DPTR
   \   000029   24E8         ADD       A,#-0x18
   \   00002B   F8           MOV       R0,A
   \   00002C   A3           INC       DPTR
   \   00002D   E0           MOVX      A,@DPTR
   \   00002E   3400         ADDC      A,#0x0
   \   000030   F9           MOV       R1,A
    203            *tmp = ((MAXMEMHEAP / HDRSZ) * HDRSZ) - SMALLBLKHEAP - HDRSZ;
   \   000031   8882         MOV       DPL,R0
   \   000033   F583         MOV       DPH,A
   \   000035   7416         MOV       A,#0x16
   \   000037   F0           MOVX      @DPTR,A
   \   000038   A3           INC       DPTR
   \   000039   740B         MOV       A,#0xb
   \   00003B   F0           MOVX      @DPTR,A
    204          
    205            // Setup a NULL block that is never freed so that the small-block bucket
    206            // is never coalesced with the wilderness.
    207            ff1 = tmp;
   \   00003C   90....       MOV       DPTR,#ff1
   \   00003F   E8           MOV       A,R0
   \   000040   F0           MOVX      @DPTR,A
   \   000041   A3           INC       DPTR
   \   000042   E9           MOV       A,R1
   \   000043   F0           MOVX      @DPTR,A
    208            ff2 = osal_mem_alloc( 0 );
   \   000044                ; Setup parameters for call to function osal_mem_alloc
   \   000044   7A00         MOV       R2,#0x0
   \   000046   7B00         MOV       R3,#0x0
   \   000048   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00004B   90....       MOV       DPTR,#ff2
   \   00004E   EA           MOV       A,R2
   \   00004F   F0           MOVX      @DPTR,A
   \   000050   A3           INC       DPTR
   \   000051   EB           MOV       A,R3
   \   000052   12....       LCALL     ?Subroutine1 & 0xFFFF
    209            ff1 = (osalMemHdr_t *)theHeap;
   \                     ??CrossCallReturnLabel_1:
   \   000055   F9           MOV       R1,A
   \   000056   90....       MOV       DPTR,#ff1
   \   000059   E8           MOV       A,R0
   \   00005A   F0           MOVX      @DPTR,A
   \   00005B   A3           INC       DPTR
   \   00005C   E9           MOV       A,R1
   \   00005D   F0           MOVX      @DPTR,A
    210          
    211          #if ( OSALMEM_METRICS )
    212            /* Start with the small-block bucket and the wilderness - don't count the
    213             * end-of-heap NULL block nor the end-of-small-block NULL block.
    214             */
    215            blkCnt = blkFree = 2;
    216          #endif
    217          }
   \   00005E   80..         SJMP      ??Subroutine2_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   90....       MOV       DPTR,#theHeap
   \   000004   E0           MOVX      A,@DPTR
   \   000005   F8           MOV       R0,A
   \   000006   A3           INC       DPTR
   \   000007   E0           MOVX      A,@DPTR
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine2_0:
   \   000000   D083         POP       DPH
   \   000002   D082         POP       DPL
   \   000004   02....       LJMP      ?BRET
    218          
    219          /*********************************************************************
    220           * @fn      osal_mem_kick
    221           *
    222           * @brief   Kick the ff1 pointer out past the long-lived OSAL Task blocks.
    223           *          Invoke this once after all long-lived blocks have been allocated -
    224           *          presently at the end of osal_init_system().
    225           *
    226           * @param   void
    227           *
    228           * @return  void
    229           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    230          void osal_mem_kick( void )
   \                     osal_mem_kick:
    231          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    232            halIntState_t intState;
    233          
    234            HAL_ENTER_CRITICAL_SECTION( intState );  // Hold off interrupts.
   \   000004   A8A8         MOV       R0,0xa8+0x0
   \   000006   C2AF         CLR       0xa8.7
    235          
    236            /* Logic in osal_mem_free() will ratchet ff1 back down to the first free
    237             * block in the small-block bucket.
    238             */
    239            ff1 = ff2;
   \   000008   90....       MOV       DPTR,#ff2
   \   00000B   E0           MOVX      A,@DPTR
   \   00000C   FA           MOV       R2,A
   \   00000D   A3           INC       DPTR
   \   00000E   E0           MOVX      A,@DPTR
   \   00000F   FB           MOV       R3,A
   \   000010   90....       MOV       DPTR,#ff1
   \   000013   EA           MOV       A,R2
   \   000014   F0           MOVX      @DPTR,A
   \   000015   A3           INC       DPTR
   \   000016   EB           MOV       A,R3
   \   000017   F0           MOVX      @DPTR,A
    240          
    241            HAL_EXIT_CRITICAL_SECTION( intState );  // Re-enable interrupts.
   \   000018   E8           MOV       A,R0
   \   000019   A2E7         MOV       C,0xE0 /* A   */.7
   \   00001B                REQUIRE ?Subroutine0
   \   00001B                REQUIRE _A_IEN0
   \   00001B                ; // Fall through to label ?Subroutine0
    242          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   92AF         MOV       0xa8.7,C
   \   000002                REQUIRE ??Subroutine2_0
   \   000002                ; // Fall through to label ??Subroutine2_0
    243          
    244          /*********************************************************************
    245           * @fn      osal_mem_alloc
    246           *
    247           * @brief   Implementation of the allocator functionality.
    248           *
    249           * @param   size - number of bytes to allocate from the heap.
    250           *
    251           * @return  void * - pointer to the heap allocation; NULL if error or failure.
    252           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    253          void *osal_mem_alloc( uint16 size )
   \                     osal_mem_alloc:
    254          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000   74F3         MOV       A,#-0xd
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 13
   \   000005                ; Auto size: 0
    255            osalMemHdr_t *prev;
    256            osalMemHdr_t *hdr;
    257            halIntState_t intState;
    258            uint16 tmp;
    259            uint8 coal = 0;
   \   000005   75..00       MOV       ?V1,#0x0
    260          
    261            OSALMEM_ASSERT( size );
    262          
    263            size += HDRSZ;
   \   000008   EA           MOV       A,R2
   \   000009   2402         ADD       A,#0x2
   \   00000B   FA           MOV       R2,A
   \   00000C   E4           CLR       A
   \   00000D   3B           ADDC      A,R3
   \   00000E   FB           MOV       R3,A
    264          
    265            // Calculate required bytes to add to 'size' to align to halDataAlign_t.
    266            if ( sizeof( halDataAlign_t ) == 2 )
    267            {
    268              size += (size & 0x01);
    269            }
    270            else if ( sizeof( halDataAlign_t ) != 1 )
    271            {
    272              const uint8 mod = size % sizeof( halDataAlign_t );
    273          
    274              if ( mod != 0 )
    275              {
    276                size += (sizeof( halDataAlign_t ) - mod);
    277              }
    278            }
    279          
    280            HAL_ENTER_CRITICAL_SECTION( intState );  // Hold off interrupts.
   \   00000F   A2AF         MOV       C,0xa8.7
   \   000011   E4           CLR       A
   \   000012   33           RLC       A
   \   000013   F5..         MOV       ?V0,A
   \   000015   C2AF         CLR       0xa8.7
    281          
    282            // Smaller allocations are first attempted in the small-block bucket.
    283            if ( size <= OSALMEM_SMALL_BLKSZ )
   \   000017   EA           MOV       A,R2
   \   000018   9411         SUBB      A,#0x11
   \   00001A   EB           MOV       A,R3
   \   00001B   9400         SUBB      A,#0x0
   \   00001D   5005         JNC       ??osal_mem_alloc_0
    284            {
    285              hdr = ff1;
   \   00001F   90....       MOV       DPTR,#ff1
   \   000022   8003         SJMP      ??osal_mem_alloc_1
    286            }
    287            else
    288            {
    289              hdr = ff2;
   \                     ??osal_mem_alloc_0:
   \   000024   90....       MOV       DPTR,#ff2
   \                     ??osal_mem_alloc_1:
   \   000027   E0           MOVX      A,@DPTR
   \   000028   F8           MOV       R0,A
   \   000029   A3           INC       DPTR
   \   00002A   E0           MOVX      A,@DPTR
   \   00002B   F9           MOV       R1,A
    290            }
    291            tmp = *hdr;
   \   00002C   8882         MOV       DPL,R0
   \   00002E   8983         MOV       DPH,R1
   \   000030   E0           MOVX      A,@DPTR
   \   000031   FE           MOV       R6,A
   \   000032   A3           INC       DPTR
   \   000033   E0           MOVX      A,@DPTR
   \   000034   FF           MOV       R7,A
    292          
    293            do
    294            {
    295              if ( tmp & OSALMEM_IN_USE )
   \                     ??osal_mem_alloc_2:
   \   000035   EF           MOV       A,R7
   \   000036   5480         ANL       A,#0x80
   \   000038   6009         JZ        ??osal_mem_alloc_3
    296              {
    297                tmp ^= OSALMEM_IN_USE;
   \   00003A   7480         MOV       A,#-0x80
   \   00003C   6F           XRL       A,R7
   \   00003D   FF           MOV       R7,A
    298                coal = 0;
   \   00003E   75..00       MOV       ?V1,#0x0
   \   000041   8074         SJMP      ??osal_mem_alloc_4
    299              }
    300              else
    301              {
    302                if ( coal != 0 )
   \                     ??osal_mem_alloc_3:
   \   000043   E5..         MOV       A,?V1
   \   000045   A2E0         MOV       C,0xE0 /* A   */.0
   \   000047   5060         JNC       ??osal_mem_alloc_5
    303                {
    304          #if ( OSALMEM_METRICS )
    305                  blkCnt--;
    306                  blkFree--;
    307          #endif
    308          
    309                  *prev += *hdr;
   \   000049   8882         MOV       DPL,R0
   \   00004B   8983         MOV       DPH,R1
   \   00004D   E0           MOVX      A,@DPTR
   \   00004E   F5..         MOV       ?V2,A
   \   000050   A3           INC       DPTR
   \   000051   E0           MOVX      A,@DPTR
   \   000052   F5..         MOV       ?V3,A
   \   000054   8C82         MOV       DPL,R4
   \   000056   8D83         MOV       DPH,R5
   \   000058   E0           MOVX      A,@DPTR
   \   000059   25..         ADD       A,?V2
   \   00005B   F0           MOVX      @DPTR,A
   \   00005C   A3           INC       DPTR
   \   00005D   E0           MOVX      A,@DPTR
   \   00005E   35..         ADDC      A,?V3
   \   000060   F0           MOVX      @DPTR,A
    310          
    311                  if ( *prev >= size )
   \   000061   8C82         MOV       DPL,R4
   \   000063   8D83         MOV       DPH,R5
   \   000065   C3           CLR       C
   \   000066   E0           MOVX      A,@DPTR
   \   000067   9A           SUBB      A,R2
   \   000068   A3           INC       DPTR
   \   000069   E0           MOVX      A,@DPTR
   \   00006A   9B           SUBB      A,R3
   \   00006B   404A         JC        ??osal_mem_alloc_4
    312                  {
    313                    hdr = prev;
   \   00006D   EC           MOV       A,R4
   \   00006E   F8           MOV       R0,A
   \   00006F   ED           MOV       A,R5
   \   000070   F9           MOV       R1,A
    314                    tmp = *hdr;
   \   000071   8882         MOV       DPL,R0
   \   000073   F583         MOV       DPH,A
   \   000075   E0           MOVX      A,@DPTR
   \   000076   FE           MOV       R6,A
   \   000077   A3           INC       DPTR
   \   000078   E0           MOVX      A,@DPTR
   \   000079   FF           MOV       R7,A
    315                    break;
    316                  }
    317                }
    318                else
    319                {
    320                  if ( tmp >= size )
    321                  {
    322                    break;
    323                  }
    324          
    325                  coal = 1;
    326                  prev = hdr;
    327                }
    328              }
    329          
    330              hdr = (osalMemHdr_t *)((uint8 *)hdr + tmp);
    331          
    332              tmp = *hdr;
    333              if ( tmp == 0 )
    334              {
    335                hdr = NULL;
    336                break;
    337              }
    338          
    339          
    340            } while ( 1 );
    341          
    342            if ( hdr != NULL )
   \                     ??osal_mem_alloc_6:
   \   00007A   E8           MOV       A,R0
   \   00007B   49           ORL       A,R1
   \   00007C   6065         JZ        ??osal_mem_alloc_7
    343            {
    344              tmp -= size;
   \   00007E   C3           CLR       C
   \   00007F   EE           MOV       A,R6
   \   000080   9A           SUBB      A,R2
   \   000081   FE           MOV       R6,A
   \   000082   EF           MOV       A,R7
   \   000083   9B           SUBB      A,R3
   \   000084   FF           MOV       R7,A
    345          
    346              // Determine whether the threshold for splitting is met.
    347              if ( tmp >= OSALMEM_MIN_BLKSZ )
   \   000085   C3           CLR       C
   \   000086   EE           MOV       A,R6
   \   000087   9404         SUBB      A,#0x4
   \   000089   EF           MOV       A,R7
   \   00008A   9400         SUBB      A,#0x0
   \   00008C   4045         JC        ??osal_mem_alloc_8
    348              {
    349                // Split the block before allocating it.
    350                osalMemHdr_t *next = (osalMemHdr_t *)((uint8 *)hdr + size);
    351                *next = tmp;
   \   00008E   E8           MOV       A,R0
   \   00008F   2A           ADD       A,R2
   \   000090   F582         MOV       DPL,A
   \   000092   E9           MOV       A,R1
   \   000093   3B           ADDC      A,R3
   \   000094   F583         MOV       DPH,A
   \   000096   EE           MOV       A,R6
   \   000097   F0           MOVX      @DPTR,A
   \   000098   A3           INC       DPTR
   \   000099   EF           MOV       A,R7
   \   00009A   F0           MOVX      @DPTR,A
    352                *hdr = (size | OSALMEM_IN_USE);
   \   00009B   EB           MOV       A,R3
   \   00009C   4480         ORL       A,#0x80
   \   00009E   FB           MOV       R3,A
   \   00009F   8882         MOV       DPL,R0
   \   0000A1   8983         MOV       DPH,R1
   \   0000A3   EA           MOV       A,R2
   \   0000A4   F0           MOVX      @DPTR,A
   \   0000A5   A3           INC       DPTR
   \   0000A6   EB           MOV       A,R3
   \   0000A7   8032         SJMP      ??osal_mem_alloc_9
    353          
    354          #if ( OSALMEM_METRICS )
    355                blkCnt++;
    356                if ( blkMax < blkCnt )
    357                {
    358                  blkMax = blkCnt;
    359                }
    360                memAlo += size;
    361          #endif
    362              }
   \                     ??osal_mem_alloc_5:
   \   0000A9   C3           CLR       C
   \   0000AA   EE           MOV       A,R6
   \   0000AB   9A           SUBB      A,R2
   \   0000AC   EF           MOV       A,R7
   \   0000AD   9B           SUBB      A,R3
   \   0000AE   50CA         JNC       ??osal_mem_alloc_6
   \   0000B0   75..01       MOV       ?V1,#0x1
   \   0000B3   E8           MOV       A,R0
   \   0000B4   FC           MOV       R4,A
   \   0000B5   E9           MOV       A,R1
   \   0000B6   FD           MOV       R5,A
   \                     ??osal_mem_alloc_4:
   \   0000B7   E8           MOV       A,R0
   \   0000B8   2E           ADD       A,R6
   \   0000B9   F8           MOV       R0,A
   \   0000BA   E9           MOV       A,R1
   \   0000BB   3F           ADDC      A,R7
   \   0000BC   F9           MOV       R1,A
   \   0000BD   8882         MOV       DPL,R0
   \   0000BF   F583         MOV       DPH,A
   \   0000C1   E0           MOVX      A,@DPTR
   \   0000C2   FE           MOV       R6,A
   \   0000C3   A3           INC       DPTR
   \   0000C4   E0           MOVX      A,@DPTR
   \   0000C5   FF           MOV       R7,A
   \   0000C6   EE           MOV       A,R6
   \   0000C7   4F           ORL       A,R7
   \   0000C8   6003         JZ        $+5
   \   0000CA   02....       LJMP      ??osal_mem_alloc_2 & 0xFFFF
   \   0000CD   7800         MOV       R0,#0x0
   \   0000CF   7900         MOV       R1,#0x0
   \   0000D1   8010         SJMP      ??osal_mem_alloc_7
    363              else
    364              {
    365          #if ( OSALMEM_METRICS )
    366                memAlo += *hdr;
    367                blkFree--;
    368          #endif
    369          
    370                *hdr |= OSALMEM_IN_USE;
   \                     ??osal_mem_alloc_8:
   \   0000D3   8882         MOV       DPL,R0
   \   0000D5   8983         MOV       DPH,R1
   \   0000D7   A3           INC       DPTR
   \   0000D8   E0           MOVX      A,@DPTR
   \   0000D9   4480         ORL       A,#0x80
   \                     ??osal_mem_alloc_9:
   \   0000DB   F0           MOVX      @DPTR,A
    371              }
    372          
    373          #if ( OSALMEM_METRICS )
    374              if ( memMax < memAlo )
    375              {
    376                memMax = memAlo;
    377              }
    378          #endif
    379          
    380          #if ( OSALMEM_PROFILER )
    381            {
    382              byte idx;
    383              size = *hdr ^ OSALMEM_IN_USE;
    384          
    385              for ( idx = 0; idx < OSALMEM_PROMAX; idx++ )
    386              {
    387                if ( size <= proCnt[idx] )
    388                {
    389                  break;
    390                }
    391              }
    392              proCur[idx]++;
    393              if ( proMax[idx] < proCur[idx] )
    394              {
    395                proMax[idx] = proCur[idx];
    396              }
    397              proTot[idx]++;
    398            }
    399          #endif
    400          
    401              hdr++;
   \   0000DC   E8           MOV       A,R0
   \   0000DD   2402         ADD       A,#0x2
   \   0000DF   F8           MOV       R0,A
   \   0000E0   5001         JNC       ??osal_mem_alloc_7
   \   0000E2   09           INC       R1
    402          
    403          #if ( OSALMEM_PROFILER )
    404              osal_memset( (byte *)hdr, OSALMEM_ALOC, (size - HDRSZ) );
    405          
    406              /* A small-block could not be allocated in the small-block bucket.
    407               * When this occurs significantly frequently, increase the size of the
    408               * bucket in order to restore better worst case run times. Set the first
    409               * profiling bucket size in proCnt[] to the small-block bucket size and
    410               * divide proSmallBlkMiss by the corresponding proTot[] size to get % miss.
    411               * Best worst case time on TrasmitApp was achieved at a 0-15% miss rate
    412               * during steady state Tx load, 0% during idle and steady state Rx load.
    413               */
    414              if ( (size <= OSALMEM_SMALL_BLKSZ) && (hdr > ff2) )
    415              {
    416                proSmallBlkMiss++;
    417              }
    418          #endif
    419            }
    420          
    421            HAL_EXIT_CRITICAL_SECTION( intState );  // Re-enable interrupts.
   \                     ??osal_mem_alloc_7:
   \   0000E3   E5..         MOV       A,?V0
   \   0000E5   A2E0         MOV       C,0xE0 /* A   */.0
   \   0000E7   92AF         MOV       0xa8.7,C
    422          
    423            return (void *)hdr;
   \   0000E9   E8           MOV       A,R0
   \   0000EA   FA           MOV       R2,A
   \   0000EB   E9           MOV       A,R1
   \   0000EC   FB           MOV       R3,A
   \   0000ED   7F05         MOV       R7,#0x5
   \   0000EF   02....       LJMP      ?BANKED_LEAVE_XDATA
   \   0000F2                REQUIRE _A_IEN0
    424          }
    425          
    426          /*********************************************************************
    427           * @fn      osal_mem_free
    428           *
    429           * @brief   Implementation of the de-allocator functionality.
    430           *
    431           * @param   ptr - pointer to the memory to free.
    432           *
    433           * @return  void
    434           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    435          void osal_mem_free( void *ptr )
   \                     osal_mem_free:
    436          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    437            osalMemHdr_t *currHdr;
    438            halIntState_t intState;
    439          
    440            HAL_ENTER_CRITICAL_SECTION( intState );  // Hold off interrupts.
   \   000004   A2AF         MOV       C,0xa8.7
   \   000006   E4           CLR       A
   \   000007   33           RLC       A
   \   000008   FC           MOV       R4,A
   \   000009   C2AF         CLR       0xa8.7
    441          
    442            OSALMEM_ASSERT( ptr );
    443          
    444            currHdr = (osalMemHdr_t *)ptr - 1;
   \   00000B   EA           MOV       A,R2
   \   00000C   24FE         ADD       A,#-0x2
   \   00000E   F8           MOV       R0,A
   \   00000F   EB           MOV       A,R3
   \   000010   34FF         ADDC      A,#-0x1
   \   000012   F9           MOV       R1,A
    445          
    446            // Has this block already been freed?
    447            OSALMEM_ASSERT( *currHdr & OSALMEM_IN_USE );
    448          
    449            *currHdr &= ~OSALMEM_IN_USE;
   \   000013   8882         MOV       DPL,R0
   \   000015   F583         MOV       DPH,A
   \   000017   A3           INC       DPTR
   \   000018   E0           MOVX      A,@DPTR
   \   000019   547F         ANL       A,#0x7f
   \   00001B   F0           MOVX      @DPTR,A
    450          
    451          #if ( OSALMEM_PROFILER )
    452            {
    453              uint16 size = *currHdr;
    454              byte idx;
    455          
    456              for ( idx = 0; idx < OSALMEM_PROMAX; idx++ )
    457              {
    458                if ( size <= proCnt[idx] )
    459                {
    460                  break;
    461                }
    462              }
    463          
    464              proCur[idx]--;
    465            }
    466          #endif
    467          
    468          #if ( OSALMEM_METRICS )
    469            memAlo -= *currHdr;
    470            blkFree++;
    471          #endif
    472          
    473            if ( ff1 > currHdr )
   \   00001C   90....       MOV       DPTR,#ff1
   \   00001F   E0           MOVX      A,@DPTR
   \   000020   FA           MOV       R2,A
   \   000021   A3           INC       DPTR
   \   000022   E0           MOVX      A,@DPTR
   \   000023   FB           MOV       R3,A
   \   000024   C3           CLR       C
   \   000025   E8           MOV       A,R0
   \   000026   9A           SUBB      A,R2
   \   000027   E9           MOV       A,R1
   \   000028   9B           SUBB      A,R3
   \   000029   5008         JNC       ??osal_mem_free_0
    474            {
    475              ff1 = currHdr;
   \   00002B   90....       MOV       DPTR,#ff1
   \   00002E   E8           MOV       A,R0
   \   00002F   F0           MOVX      @DPTR,A
   \   000030   A3           INC       DPTR
   \   000031   E9           MOV       A,R1
   \   000032   F0           MOVX      @DPTR,A
    476            }
    477          
    478          #if ( OSALMEM_PROFILER )
    479            osal_memset( (byte *)currHdr+HDRSZ, OSALMEM_REIN, (*currHdr - HDRSZ) );
    480          #endif
    481          
    482            HAL_EXIT_CRITICAL_SECTION( intState );  // Re-enable interrupts.
   \                     ??osal_mem_free_0:
   \   000033   EC           MOV       A,R4
   \   000034   A2E0         MOV       C,0xE0 /* A   */.0
   \   000036   02....       LJMP      ?Subroutine0 & 0xFFFF
   \   000039                REQUIRE _A_IEN0
    483          }

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for theHeap>`:
   \   000000   ....         DW _theHeap

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??osal_mem_init::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_mem_init

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??osal_mem_kick::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_mem_kick

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??osal_mem_alloc::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_mem_alloc

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??osal_mem_free::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_mem_free
    484          
    485          #if ( OSALMEM_METRICS )
    486          /*********************************************************************
    487           * @fn      osal_heap_block_max
    488           *
    489           * @brief   Return the maximum number of blocks ever allocated at once.
    490           *
    491           * @param   none
    492           *
    493           * @return  Maximum number of blocks ever allocated at once.
    494           */
    495          uint16 osal_heap_block_max( void )
    496          {
    497            return blkMax;
    498          }
    499          
    500          /*********************************************************************
    501           * @fn      osal_heap_block_cnt
    502           *
    503           * @brief   Return the current number of blocks now allocated.
    504           *
    505           * @param   none
    506           *
    507           * @return  Current number of blocks now allocated.
    508           */
    509          uint16 osal_heap_block_cnt( void )
    510          {
    511            return blkCnt;
    512          }
    513          
    514          /*********************************************************************
    515           * @fn      osal_heap_block_free
    516           *
    517           * @brief   Return the current number of free blocks.
    518           *
    519           * @param   none
    520           *
    521           * @return  Current number of free blocks.
    522           */
    523          uint16 osal_heap_block_free( void )
    524          {
    525            return blkFree;
    526          }
    527          
    528          /*********************************************************************
    529           * @fn      osal_heap_mem_used
    530           *
    531           * @brief   Return the current number of bytes allocated.
    532           *
    533           * @param   none
    534           *
    535           * @return  Current number of bytes allocated.
    536           */
    537          uint16 osal_heap_mem_used( void )
    538          {
    539            return memAlo;
    540          }
    541          #endif
    542          
    543          #if defined (ZTOOL_P1) || defined (ZTOOL_P2)
    544          /*********************************************************************
    545           * @fn      osal_heap_high_water
    546           *
    547           * @brief   Return the highest byte ever allocated in the heap.
    548           *
    549           * @param   none
    550           *
    551           * @return  Highest number of bytes ever used by the stack.
    552           */
    553          uint16 osal_heap_high_water( void )
    554          {
    555          #if ( OSALMEM_METRICS )
    556            return memMax;
    557          #else
    558            return MAXMEMHEAP;
    559          #endif
    560          }
    561          #endif
    562          
    563          /*********************************************************************
    564          *********************************************************************/

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      0     13   osal_mem_alloc
      2      0   osal_mem_free
      2      0   osal_mem_init
        2      0   -> osal_mem_alloc
      2      0   osal_mem_kick


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       2  ?<Initializer for theHeap>
       7  ??Subroutine2_0
       2  ?Subroutine0
       9  ?Subroutine1
       1  _A_IEN0
    3072  _theHeap
       2  ff1
       2  ff2
     242  osal_mem_alloc
       6  osal_mem_alloc::?relay
      57  osal_mem_free
       6  osal_mem_free::?relay
      96  osal_mem_init
       6  osal_mem_init::?relay
      27  osal_mem_kick
       6  osal_mem_kick::?relay
       2  theHeap

 
   440 bytes in segment BANKED_CODE
    24 bytes in segment BANK_RELAYS
     1 byte  in segment SFR_AN
     2 bytes in segment XDATA_I
     2 bytes in segment XDATA_ID
 3 076 bytes in segment XDATA_Z
 
    26 bytes of CODE     memory
     0 bytes of DATA     memory (+ 1 byte shared)
   440 bytes of HUGECODE memory
 3 078 bytes of XDATA    memory

Errors: none
Warnings: none
